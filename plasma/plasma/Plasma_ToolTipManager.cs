//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    /// <remarks>
    ///  @class ToolTipManager plasma/tooltipmanager.h <Plasma/ToolTipManager>
    ///  If you want a widget to have a tooltip displayed when the mouse is hovered over
    ///  it, you should do something like:
    ///  @code
    ///  // widget is a QGraphicsWidget
    ///  Plasma.ToolTipManager.ToolTipContent data;
    ///  data.mainText = i18n("My Title");
    ///  data.subText = i18n("This is a little tooltip");
    ///  data.image = KIcon("some-icon").pixmap(IconSize(KIconLoader.Desktop));
    ///  Plasma.ToolTipManager.Self().SetToolTipContent(widget, data);
    ///  @endcode
    ///  Note that, since a Plasma.Applet is a QGraphicsWidget, you can use
    ///  Plasma.ToolTipManager.Self().SetToolTipContent(this, data); in the
    ///  applet's init() method to set a tooltip for the whole applet.
    ///  The tooltip will be registered automatically by setToolTipContent().  It will be
    ///  automatically unregistered when the associated widget is deleted, freeing the
    ///  memory used by the tooltip, but you can manually unregister it at any time by
    ///  calling unregisterWidget().
    ///  When a tooltip for a widget is about to be shown, the widget's toolTipAboutToShow slot will be
    ///  invoked if it exists. Similarly, when a tooltip is hidden, the widget's toolTipHidden() slot
    ///  will be invoked if it exists. This allows widgets to provide on-demand tooltip data.
    ///  </remarks>        <short> Manages tooltips for QGraphicsWidgets in Plasma.</short>
    [SmokeClass("Plasma::ToolTipManager")]
    public class ToolTipManager : QObject, IDisposable {
        protected ToolTipManager(Type dummy) : base((Type) null) {}
        /// <remarks>
        ///  @struct ToolTipContent plasma/tooltipmanager.h <Plasma/ToolTipManager>
        ///  This provides the content for a tooltip.
        ///  Normally you will want to set at least the <code>mainText</code> and
        ///  <code>subText.</code>
        ///      </remarks>        <short>    @struct ToolTipContent plasma/tooltipmanager.</short>
        [SmokeClass("Plasma::ToolTipManager::ToolTipContent")]
        public class ToolTipContent : Object, IDisposable {
            protected SmokeInvocation interceptor = null;
            private IntPtr smokeObject;
            protected ToolTipContent(Type dummy) {}
            protected void CreateProxy() {
                interceptor = new SmokeInvocation(typeof(ToolTipContent), this);
            }
            public string MainText {
                get { return (string) interceptor.Invoke("mainText", "mainText()", typeof(string)); }
                set { interceptor.Invoke("setMainText$", "setMainText(QString)", typeof(void), typeof(string), value); }
            }
            public string SubText {
                get { return (string) interceptor.Invoke("subText", "subText()", typeof(string)); }
                set { interceptor.Invoke("setSubText$", "setSubText(QString)", typeof(void), typeof(string), value); }
            }
            public QPixmap Image {
                get { return (QPixmap) interceptor.Invoke("image", "image()", typeof(QPixmap)); }
                set { interceptor.Invoke("setImage#", "setImage(QPixmap)", typeof(void), typeof(QPixmap), value); }
            }
            public uint WindowToPreview {
                get { return (uint) interceptor.Invoke("windowToPreview", "windowToPreview()", typeof(uint)); }
                set { interceptor.Invoke("setWindowToPreview$", "setWindowToPreview(WId)", typeof(void), typeof(uint), value); }
            }
            /// <remarks> Creates an empty ToolTipContent </remarks>        <short>   Creates an empty ToolTipContent </short>
            public ToolTipContent() : this((Type) null) {
                CreateProxy();
                interceptor.Invoke("ToolTipContent", "ToolTipContent()", typeof(void));
            }
            /// <remarks> @return true if all the fields are empty </remarks>        <short>   @return true if all the fields are empty </short>
            public bool IsEmpty() {
                return (bool) interceptor.Invoke("isEmpty", "isEmpty() const", typeof(bool));
            }
            ~ToolTipContent() {
                interceptor.Invoke("~ToolTipContent", "~ToolTipContent()", typeof(void));
            }
            public void Dispose() {
                interceptor.Invoke("~ToolTipContent", "~ToolTipContent()", typeof(void));
            }
        }
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ToolTipManager), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static ToolTipManager() {
            staticInterceptor = new SmokeInvocation(typeof(ToolTipManager), null);
        }
        /// <remarks>
        ///  Default constructor.
        ///  You should normall use self() instead.
        ///      </remarks>        <short>    Default constructor.</short>
        public ToolTipManager(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ToolTipManager#", "ToolTipManager(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public ToolTipManager() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ToolTipManager", "ToolTipManager()", typeof(void));
        }
        /// <remarks>
        ///  Show the tooltip for a widget registered in the tooltip manager
        /// <param> name="widget" the widget for which the tooltip will be displayed
        ///      </param></remarks>        <short>    Show the tooltip for a widget registered in the tooltip manager </short>
        public void ShowToolTip(QGraphicsWidget widget) {
            interceptor.Invoke("showToolTip#", "showToolTip(QGraphicsWidget*)", typeof(void), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Find out whether the tooltip for a given widget is currently being displayed.
        /// <param> name="widget" the widget to check the tooltip for
        /// </param></remarks>        <return> true if the tooltip of the widget is currently displayed,
        ///          false if not
        ///      </return>
        ///         <short>    Find out whether the tooltip for a given widget is currently being displayed.</short>
        public bool IsWidgetToolTipDisplayed(QGraphicsWidget widget) {
            return (bool) interceptor.Invoke("isWidgetToolTipDisplayed#", "isWidgetToolTipDisplayed(QGraphicsWidget*)", typeof(bool), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Hides the currently showing tooltip after a short amount of time.
        ///      </remarks>        <short>    Hides the currently showing tooltip after a short amount of time.</short>
        public void DelayedHideToolTip() {
            interceptor.Invoke("delayedHideToolTip", "delayedHideToolTip()", typeof(void));
        }
        /// <remarks>
        ///  Hides the tooltip for a widget immediately.
        /// <param> name="widget" the widget to hide the tooltip for
        ///      </param></remarks>        <short>    Hides the tooltip for a widget immediately.</short>
        public void HideToolTip(QGraphicsWidget widget) {
            interceptor.Invoke("hideToolTip#", "hideToolTip(QGraphicsWidget*)", typeof(void), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Registers a widget with the tooltip manager.
        ///  Note that setToolTipContent() will register the widget if it
        ///  has not already been registered, and so you do not normally
        ///  need to use the method.
        ///  This is useful for creating tooltip content on demand.  You can
        ///  register your widget with registerWidget(), then implement
        ///  a slot named toolTipAboutToShow for the widget.  This will be
        ///  called before the tooltip is shown, allowing you to set the
        ///  data with setToolTipContent().
        ///  If the widget also has a toolTipHidden slot, this will be called
        ///  after the tooltip is hidden.
        /// <param> name="widget" the desired widget
        ///      </param></remarks>        <short>    Registers a widget with the tooltip manager.</short>
        public void RegisterWidget(QGraphicsWidget widget) {
            interceptor.Invoke("registerWidget#", "registerWidget(QGraphicsWidget*)", typeof(void), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Unregisters a widget from the tooltip manager.
        ///  This will free the memory used by the tooltip associated with the widget.
        /// <param> name="widget" the desired widget to delete
        ///      </param></remarks>        <short>    Unregisters a widget from the tooltip manager.</short>
        public void UnregisterWidget(QGraphicsWidget widget) {
            interceptor.Invoke("unregisterWidget#", "unregisterWidget(QGraphicsWidget*)", typeof(void), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Sets the content for the tooltip associated with a widget.
        ///  Note that this will register the widget with the ToolTipManager if
        ///  necessary, so there is usually no need to call registerWidget().
        /// <param> name="widget" the widget the tooltip should be associated with
        /// </param><param> name="data" the content of the tooltip. If an empty ToolTipContent
        ///                is passed in, the tooltip content will be reset.
        ///      </param></remarks>        <short>    Sets the content for the tooltip associated with a widget.</short>
        public void SetToolTipContent(QGraphicsWidget widget, Plasma.ToolTipManager.ToolTipContent data) {
            interceptor.Invoke("setToolTipContent##", "setToolTipContent(QGraphicsWidget*, const Plasma::ToolTipManager::ToolTipContent&)", typeof(void), typeof(QGraphicsWidget), widget, typeof(Plasma.ToolTipManager.ToolTipContent), data);
        }
        /// <remarks>
        ///  Checks whether a widget has a tooltip associated with it.
        /// <param> name="widget" the widget to check for an associated tooltip
        /// </param></remarks>        <return> true if the widget has a tooltip associated,
        ///          false if it does not
        ///      </return>
        ///         <short>    Checks whether a widget has a tooltip associated with it.</short>
        public bool WidgetHasToolTip(QGraphicsWidget widget) {
            return (bool) interceptor.Invoke("widgetHasToolTip#", "widgetHasToolTip(QGraphicsWidget*) const", typeof(bool), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///   Enable/or disable a Tooltip, this method is usefull is we want
        ///   to have a tooltip activated on demand.
        /// <param> name="widget" the widget to change tooltip behaviour
        /// </param><param> name="enable" if we need the tooltip or not
        ///      </param></remarks>        <short>     Enable/or disable a Tooltip, this method is usefull is we want   to have a tooltip activated on demand.</short>
        public void SetToolTipActivated(QGraphicsWidget widget, bool enable) {
            interceptor.Invoke("setToolTipActivated#$", "setToolTipActivated(QGraphicsWidget*, bool)", typeof(void), typeof(QGraphicsWidget), widget, typeof(bool), enable);
        }
        /// <remarks>
        ///  Return true is the tooltip will be displayed, false otherwise
        ///      </remarks>        <short>    Return true is the tooltip will be displayed, false otherwise      </short>
        public bool IsToolTipActivated(QGraphicsWidget widget) {
            return (bool) interceptor.Invoke("isToolTipActivated#", "isToolTipActivated(QGraphicsWidget*)", typeof(bool), typeof(QGraphicsWidget), widget);
        }
        ~ToolTipManager() {
            interceptor.Invoke("~ToolTipManager", "~ToolTipManager()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~ToolTipManager", "~ToolTipManager()", typeof(void));
        }
        /// <remarks>
        /// </remarks>        <return> The singleton instance of the manager.
        ///      </return>
        ///         <short>   </short>
        public static Plasma.ToolTipManager Self() {
            return (Plasma.ToolTipManager) staticInterceptor.Invoke("self", "self()", typeof(Plasma.ToolTipManager));
        }
        protected new IToolTipManagerSignals Emit {
            get { return (IToolTipManagerSignals) Q_EMIT; }
        }
    }

    public interface IToolTipManagerSignals : IQObjectSignals {
    }
}
