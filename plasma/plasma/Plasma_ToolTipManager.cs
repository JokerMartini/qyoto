//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    /// <remarks>
    ///  Manage tooltips on QGraphicsWidget. First you have to register your widget by calling
    ///  registerWidget on the ToolTipManager singleton. After this you have to set the content of
    ///  the tooltip by calling setToolTipContent using the struct ToolTipContent. Calling
    ///  setToolTipContent on a widget that is not registered will cause it to be registered.
    ///  The tooltip manager unregister automatically the widget when it is destroyed but if 
    ///  you want to do it manually call unregisterWidget. 
    ///  When a tooltip for a widget is about to be shown, the widget's toolTipAboutToShow slot will be
    ///  invoked if it exists. Similarly, when a tooltip is hidden, the widget's toolTipHidden() slow
    ///  will be invoked if it exists. This allows widgets to provide on-demand tooltip data.
    ///   </remarks>        <short> The class to manage tooltips on QGraphicsWidget in Plasma.</short>
    [SmokeClass("Plasma::ToolTipManager")]
    public class ToolTipManager : QObject, IDisposable {
        protected ToolTipManager(Type dummy) : base((Type) null) {}
        /// <remarks>
        ///  Content of a tooltip
        ///       </remarks>        <short>    Content of a tooltip       </short>
        [SmokeClass("Plasma::ToolTipManager::ToolTipContent")]
        public class ToolTipContent : Object, IDisposable {
            protected SmokeInvocation interceptor = null;
            private IntPtr smokeObject;
            protected ToolTipContent(Type dummy) {}
            protected void CreateProxy() {
                interceptor = new SmokeInvocation(typeof(ToolTipContent), this);
            }
            public string MainText {
                get { return (string) interceptor.Invoke("mainText", "mainText()", typeof(string)); }
                set { interceptor.Invoke("setMainText$", "setMainText(QString)", typeof(void), typeof(string), value); }
            }
            public string SubText {
                get { return (string) interceptor.Invoke("subText", "subText()", typeof(string)); }
                set { interceptor.Invoke("setSubText$", "setSubText(QString)", typeof(void), typeof(string), value); }
            }
            public QPixmap Image {
                get { return (QPixmap) interceptor.Invoke("image", "image()", typeof(QPixmap)); }
                set { interceptor.Invoke("setImage#", "setImage(QPixmap)", typeof(void), typeof(QPixmap), value); }
            }
            public uint WindowToPreview {
                get { return (uint) interceptor.Invoke("windowToPreview", "windowToPreview()", typeof(uint)); }
                set { interceptor.Invoke("setWindowToPreview$", "setWindowToPreview(WId)", typeof(void), typeof(uint), value); }
            }
            public ToolTipContent() : this((Type) null) {
                CreateProxy();
                interceptor.Invoke("ToolTipContent", "ToolTipContent()", typeof(void));
            }
            public bool IsEmpty() {
                return (bool) interceptor.Invoke("isEmpty", "isEmpty() const", typeof(bool));
            }
            ~ToolTipContent() {
                interceptor.Invoke("~ToolTipContent", "~ToolTipContent()", typeof(void));
            }
            public void Dispose() {
                interceptor.Invoke("~ToolTipContent", "~ToolTipContent()", typeof(void));
            }
        }
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ToolTipManager), this);
        }
        private static SmokeInvocation staticInterceptor = null;
        static ToolTipManager() {
            staticInterceptor = new SmokeInvocation(typeof(ToolTipManager), null);
        }
        /// <remarks>
        ///  Default constructor. Usually you want to use the singleton instead.
        ///         </remarks>        <short>    Default constructor.</short>
        public ToolTipManager(QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ToolTipManager#", "ToolTipManager(QObject*)", typeof(void), typeof(QObject), parent);
        }
        public ToolTipManager() : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ToolTipManager", "ToolTipManager()", typeof(void));
        }
        /// <remarks>
        ///  Function to show a tooltip of a widget registered in the tooltip manager
        /// <param> name="widget" the widget on which the tooltip will be displayed
        ///       </param></remarks>        <short>    Function to show a tooltip of a widget registered in the tooltip manager </short>
        public void ShowToolTip(QGraphicsWidget widget) {
            interceptor.Invoke("showToolTip#", "showToolTip(QGraphicsWidget*)", typeof(void), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Function to know if a tooltip of a widget is displayed
        /// <param> name="widget" the desired widget
        /// </param></remarks>        <return> true if te tooltip of the widget is currently displayed, otherwhise no
        ///       </return>
        ///         <short>    Function to know if a tooltip of a widget is displayed </short>
        public bool IsWidgetToolTipDisplayed(QGraphicsWidget widget) {
            return (bool) interceptor.Invoke("isWidgetToolTipDisplayed#", "isWidgetToolTipDisplayed(QGraphicsWidget*)", typeof(bool), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Function to launch a delayed hide of the current displayed tooltip
        /// <param> name="widget" the desired widget
        ///       </param></remarks>        <short>    Function to launch a delayed hide of the current displayed tooltip </short>
        public void DelayedHideToolTip() {
            interceptor.Invoke("delayedHideToolTip", "delayedHideToolTip()", typeof(void));
        }
        /// <remarks>
        ///  Function to hide the tooltip of the desired widget
        /// <param> name="widget" the desired widget
        ///       </param></remarks>        <short>    Function to hide the tooltip of the desired widget </short>
        public void HideToolTip(QGraphicsWidget widget) {
            interceptor.Invoke("hideToolTip#", "hideToolTip(QGraphicsWidget*)", typeof(void), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Function to register a widget to the tooltip manager, after this a setWidgetToolTipContent
        ///  must be called
        /// <param> name="widget" the desired widget
        ///       </param></remarks>        <short>    Function to register a widget to the tooltip manager, after this a setWidgetToolTipContent  must be called </short>
        public void RegisterWidget(QGraphicsWidget widget) {
            interceptor.Invoke("registerWidget#", "registerWidget(QGraphicsWidget*)", typeof(void), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Function to unregister a widget in the tooltip manager, i.e. means that memory will be free
        /// <param> name="widget" the desired widget to delete
        ///       </param></remarks>        <short>    Function to unregister a widget in the tooltip manager, i.</short>
        public void UnregisterWidget(QGraphicsWidget widget) {
            interceptor.Invoke("unregisterWidget#", "unregisterWidget(QGraphicsWidget*)", typeof(void), typeof(QGraphicsWidget), widget);
        }
        /// <remarks>
        ///  Function to set the content of a tooltip on a desired widget.
        /// <param> name="widget" the desired widget
        /// </param><param> name="data" the content of the tooltip. If an empty ToolTipContent is passed in,
        ///         the tooltip content will be reset.
        ///        </param></remarks>        <short>    Function to set the content of a tooltip on a desired widget.</short>
        public void SetToolTipContent(QGraphicsWidget widget, Plasma.ToolTipManager.ToolTipContent data) {
            interceptor.Invoke("setToolTipContent##", "setToolTipContent(QGraphicsWidget*, const Plasma::ToolTipManager::ToolTipContent&)", typeof(void), typeof(QGraphicsWidget), widget, typeof(Plasma.ToolTipManager.ToolTipContent), data);
        }
        /// <remarks>
        ///  Function to know if widget has a tooltip registered in the tooltip manager
        /// <param> name="widget" the widget
        /// </param></remarks>        <return> true if this widget has a tooltip
        ///       </return>
        ///         <short>    Function to know if widget has a tooltip registered in the tooltip manager </short>
        public bool WidgetHasToolTip(QGraphicsWidget widget) {
            return (bool) interceptor.Invoke("widgetHasToolTip#", "widgetHasToolTip(QGraphicsWidget*) const", typeof(bool), typeof(QGraphicsWidget), widget);
        }
        ~ToolTipManager() {
            interceptor.Invoke("~ToolTipManager", "~ToolTipManager()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~ToolTipManager", "~ToolTipManager()", typeof(void));
        }
        /// <remarks>
        /// </remarks>        <return> The singleton instance of the manager.
        /// </return>
        ///         <short>   </short>
        public static Plasma.ToolTipManager Self() {
            return (Plasma.ToolTipManager) staticInterceptor.Invoke("self", "self()", typeof(Plasma.ToolTipManager));
        }
        protected new IToolTipManagerSignals Emit {
            get { return (IToolTipManagerSignals) Q_EMIT; }
        }
    }

    public interface IToolTipManagerSignals : IQObjectSignals {
    }
}
