//Auto-generated by kalyptus. DO NOT EDIT.
namespace Plasma {
    using Plasma;
    using System;
    using Kimono;
    using Qyoto;
    [SmokeClass("Plasma::ConfigXml")]
    public class ConfigXml : KConfigSkeleton, IDisposable {
        protected ConfigXml(Type dummy) : base((Type) null) {}
        protected new void CreateProxy() {
            interceptor = new SmokeInvocation(typeof(ConfigXml), this);
        }
        /// <remarks>
        ///  Creates a KConfigSkeleton populated using the definition found in
        ///  the XML data passed in.
        /// <param> name="configFile" path to the configuration file to use
        /// </param><param> name="xml" the xml data; must be valid KConfigXT data
        /// </param><param> name="parent" optional QObject parent
        /// </param></remarks>        <short>    Creates a KConfigSkeleton populated using the definition found in  the XML data passed in.</short>
        public ConfigXml(string configFile, QIODevice xml, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ConfigXml$##", "ConfigXml(const QString&, QIODevice*, QObject*)", typeof(void), typeof(string), configFile, typeof(QIODevice), xml, typeof(QObject), parent);
        }
        public ConfigXml(string configFile, QIODevice xml) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ConfigXml$#", "ConfigXml(const QString&, QIODevice*)", typeof(void), typeof(string), configFile, typeof(QIODevice), xml);
        }
        /// <remarks>
        ///  Creates a KConfigSkeleton populated using the definition found in
        ///  the XML data passed in.
        ///  FIXME/WARNING: DOES NOT WORK IN KDE 4.1 - FIX KCONFIGSKELETON
        /// <param> name="config" the configuration object to use
        /// </param><param> name="xml" the xml data; must be valid KConfigXT data
        /// </param><param> name="parent" optional QObject parent
        /// </param></remarks>        <short>    Creates a KConfigSkeleton populated using the definition found in  the XML data passed in.</short>
        public ConfigXml(KSharedConfig config, QIODevice xml, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ConfigXml?##", "ConfigXml(KSharedPtr<KSharedConfig>, QIODevice*, QObject*)", typeof(void), typeof(KSharedConfig), config, typeof(QIODevice), xml, typeof(QObject), parent);
        }
        public ConfigXml(KSharedConfig config, QIODevice xml) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ConfigXml?#", "ConfigXml(KSharedPtr<KSharedConfig>, QIODevice*)", typeof(void), typeof(KSharedConfig), config, typeof(QIODevice), xml);
        }
        /// <remarks>
        ///  Creates a KConfigSkeleton populated using the definition found in
        ///  the XML data passed in.
        ///  FIXME/WARNING: DOES NOT WORK IN KDE 4.1 - FIX KCONFIGSKELETON
        /// <param> name="config" the group to use as the root for configuration items
        /// </param><param> name="xml" the xml data; must be valid KConfigXT data
        /// </param><param> name="parent" optional QObject parent
        /// </param></remarks>        <short>    Creates a KConfigSkeleton populated using the definition found in  the XML data passed in.</short>
        public ConfigXml(KConfigGroup config, QIODevice xml, QObject parent) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ConfigXml###", "ConfigXml(const KConfigGroup*, QIODevice*, QObject*)", typeof(void), typeof(KConfigGroup), config, typeof(QIODevice), xml, typeof(QObject), parent);
        }
        public ConfigXml(KConfigGroup config, QIODevice xml) : this((Type) null) {
            CreateProxy();
            interceptor.Invoke("ConfigXml##", "ConfigXml(const KConfigGroup*, QIODevice*)", typeof(void), typeof(KConfigGroup), config, typeof(QIODevice), xml);
        }
        public KConfigSkeletonItem FindItem(string group, string key) {
            return (KConfigSkeletonItem) interceptor.Invoke("findItem$$", "findItem(const QString&, const QString&)", typeof(KConfigSkeletonItem), typeof(string), group, typeof(string), key);
        }
        /// <remarks>
        ///  Check to see if a group exists
        /// <param> name="group" the name of the group to check for
        /// </param></remarks>        <return> true if the group exists, or false if it does not
        ///      </return>
        ///         <short>    Check to see if a group exists </short>
        public bool HasGroup(string group) {
            return (bool) interceptor.Invoke("hasGroup$", "hasGroup(const QString&) const", typeof(bool), typeof(string), group);
        }
        ~ConfigXml() {
            interceptor.Invoke("~ConfigXml", "~ConfigXml()", typeof(void));
        }
        public new void Dispose() {
            interceptor.Invoke("~ConfigXml", "~ConfigXml()", typeof(void));
        }
        protected new IConfigXmlSignals Emit {
            get { return (IConfigXmlSignals) Q_EMIT; }
        }
    }

    public interface IConfigXmlSignals : IKConfigSkeletonSignals {
    }
}
