//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KParts {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  URLArgs is a set of arguments bundled into a structure,
	///  to allow specifying how a URL should be opened by openUrl().
	///  In other words, this is like arguments to openUrl(), but without
	///  have to change the signature of openUrl() (since openUrl is a
	///  generic KParts method).
	///  The parts (with a browser extension) who care about urlargs will
	///  use those arguments, others will ignore them.
	///  This can also be used the other way round, when a part asks
	///  for a URL to be opened (with openUrlRequest or createNewWindow).
	///  </remarks>		<short>    URLArgs is a set of arguments bundled into a structure,  to allow specifying how a URL should be opened by openUrl().</short>

	[SmokeClass("KParts::URLArgs")]
	public class URLArgs : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected URLArgs(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(URLArgs), this);
		}
		public URLArgs() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("URLArgs", "URLArgs()", typeof(void));
		}
		public URLArgs(KParts.URLArgs args) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("URLArgs#", "URLArgs(const KParts::URLArgs&)", typeof(void), typeof(KParts.URLArgs), args);
		}
		public URLArgs(bool reload, int xOffset, int yOffset, string serviceType) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("URLArgs$$$$", "URLArgs(bool, int, int, const QString&)", typeof(void), typeof(bool), reload, typeof(int), xOffset, typeof(int), yOffset, typeof(string), serviceType);
		}
		public URLArgs(bool reload, int xOffset, int yOffset) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("URLArgs$$$", "URLArgs(bool, int, int)", typeof(void), typeof(bool), reload, typeof(int), xOffset, typeof(int), yOffset);
		}
		/// <remarks>
		///  KHTML-specific field, header defining the type of the POST data.
		///    </remarks>		<short>    KHTML-specific field, header defining the type of the POST data.</short>
		public void SetContentType(string contentType) {
			interceptor.Invoke("setContentType$", "setContentType(const QString&)", typeof(void), typeof(string), contentType);
		}
		/// <remarks>
		///  KHTML-specific field, header defining the type of the POST data.
		///    </remarks>		<short>    KHTML-specific field, header defining the type of the POST data.</short>
		public string ContentType() {
			return (string) interceptor.Invoke("contentType", "contentType() const", typeof(string));
		}
		/// <remarks>
		///  KHTML-specific field, whether to do a POST instead of a GET,
		///  for the next openURL.
		///    </remarks>		<short>    KHTML-specific field, whether to do a POST instead of a GET,  for the next openURL.</short>
		public void SetDoPost(bool enable) {
			interceptor.Invoke("setDoPost$", "setDoPost(bool)", typeof(void), typeof(bool), enable);
		}
		/// <remarks>
		///  KHTML-specific field, whether to do a POST instead of a GET,
		///  for the next openURL.
		///    </remarks>		<short>    KHTML-specific field, whether to do a POST instead of a GET,  for the next openURL.</short>
		public bool DoPost() {
			return (bool) interceptor.Invoke("doPost", "doPost() const", typeof(bool));
		}
		/// <remarks>
		///  Whether to lock the history when opening the next URL.
		///  This is used during e.g. a redirection, to avoid a new entry
		///  in the history.
		///    </remarks>		<short>    Whether to lock the history when opening the next URL.</short>
		public void SetLockHistory(bool arg1) {
			interceptor.Invoke("setLockHistory$", "setLockHistory(bool)", typeof(void), typeof(bool), arg1);
		}
		public bool LockHistory() {
			return (bool) interceptor.Invoke("lockHistory", "lockHistory() const", typeof(bool));
		}
		/// <remarks>
		///  Whether the URL should be opened in a new tab instead in a new window.
		///    </remarks>		<short>    Whether the URL should be opened in a new tab instead in a new window.</short>
		public void SetNewTab(bool newTab) {
			interceptor.Invoke("setNewTab$", "setNewTab(bool)", typeof(void), typeof(bool), newTab);
		}
		public bool NewTab() {
			return (bool) interceptor.Invoke("newTab", "newTab() const", typeof(bool));
		}
		/// <remarks>
		///  Meta-data to associate with the next KIO operation
		/// </remarks>		<short>    Meta-data to associate with the next KIO operation </short>
		/// 		<see> TransferJob</see>
		/// 		<see> etc.</see>
		public Dictionary<string, string> MetaData() {
			return (Dictionary<string, string>) interceptor.Invoke("metaData", "metaData()", typeof(Dictionary<string, string>));
		}
		/// <remarks>
		/// </remarks>		<return> true if the request was a result of a META refresh/redirect request or
		///  HTTP redirect.
		///    </return>
		/// 		<short>   </short>
		public bool RedirectedRequest() {
			return (bool) interceptor.Invoke("redirectedRequest", "redirectedRequest() const", typeof(bool));
		}
		/// <remarks>
		///  Set the redirect flag to indicate URL is a result of either a META redirect
		///  or HTTP redirect.
		/// <param> name="redirected"    </param></remarks>		<short>    Set the redirect flag to indicate URL is a result of either a META redirect  or HTTP redirect.</short>
		public void SetRedirectedRequest(bool redirected) {
			interceptor.Invoke("setRedirectedRequest$", "setRedirectedRequest(bool)", typeof(void), typeof(bool), redirected);
		}
		/// <remarks>
		///  Set whether the URL specifies to be opened in a new window
		///    </remarks>		<short>    Set whether the URL specifies to be opened in a new window    </short>
		public void SetForcesNewWindow(bool forcesNewWindow) {
			interceptor.Invoke("setForcesNewWindow$", "setForcesNewWindow(bool)", typeof(void), typeof(bool), forcesNewWindow);
		}
		/// <remarks>
		///  Whether the URL specifies to be opened in a new window
		///    </remarks>		<short>    Whether the URL specifies to be opened in a new window    </short>
		public bool ForcesNewWindow() {
			return (bool) interceptor.Invoke("forcesNewWindow", "forcesNewWindow() const", typeof(bool));
		}
		~URLArgs() {
			interceptor.Invoke("~URLArgs", "~URLArgs()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~URLArgs", "~URLArgs()", typeof(void));
		}
	}
	}
}
