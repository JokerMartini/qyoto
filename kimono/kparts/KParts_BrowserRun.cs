//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KParts {

	using System;
	using Qyoto;

	/// <remarks>
	///  This class extends KRun to provide additional functionality for browsers:
	///  - "save or open" dialog boxes
	///  - "save" functionality
	///  - support for HTTP POST (including saving the result to a temp file if
	///    opening a separate application)
	///  - warning before launching executables off the web
	///  - custom error handling (i.e. treating errors as HTML pages)
	///  - generation of SSL metadata depending on the previous URL shown by the part
	/// </remarks>		<author> David Faure <faure@kde.org>
	///      </author>
	/// 		<short>    This class extends KRun to provide additional functionality for browsers:  - "save or open" dialog boxes  - "save" functionality  - support for HTTP POST (including saving the result to a temp file if    opening a separate application)  - warning before launching executables off the web  - custom error handling (i.</short>

	[SmokeClass("KParts::BrowserRun")]
	public class BrowserRun : KRun, IDisposable {
 		protected BrowserRun(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(BrowserRun), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static BrowserRun() {
			staticInterceptor = new SmokeInvocation(typeof(BrowserRun), null);
		}
		// KParts::BrowserRun::AskSaveResult askSave(const KUrl& arg1,KService::Ptr arg2,const QString& arg3,const QString& arg4); >>>> NOT CONVERTED
		// KParts::BrowserRun::AskSaveResult askSave(const KUrl& arg1,KService::Ptr arg2,const QString& arg3); >>>> NOT CONVERTED
		// KParts::BrowserRun::AskSaveResult askEmbedOrSave(const KUrl& arg1,const QString& arg2,const QString& arg3,int arg4); >>>> NOT CONVERTED
		// KParts::BrowserRun::AskSaveResult askEmbedOrSave(const KUrl& arg1,const QString& arg2,const QString& arg3); >>>> NOT CONVERTED
		// KParts::BrowserRun::AskSaveResult askEmbedOrSave(const KUrl& arg1,const QString& arg2); >>>> NOT CONVERTED
		// KParts::BrowserRun::NonEmbeddableResult handleNonEmbeddable(const QString& arg1); >>>> NOT CONVERTED
		/// <remarks>
		/// <param> name="url" the URL we're probing
		/// </param><param> name="args" URL args - includes data for a HTTP POST, etc.
		/// </param><param> name="part" the part going to open this URL - can be null if not created yet
		/// </param><param> name="window" the mainwindow - passed to KIO.Job.SetWindow()
		/// </param><param> name="removeReferrer" if true, the "referrer" metadata from <code>args</code> isn't passed on
		/// </param><param> name="trustedSource" if false, a warning will be shown before launching an executable.
		///           Always pass false for <code>trustedSource</code>, except for local directory views.
		/// </param><param> name="hideErrorDialog" if true, no dialog will be shown in case of errors.
		///          </param></remarks>		<short>   </short>
		public BrowserRun(KUrl url, KParts.URLArgs args, KParts.ReadOnlyPart part, QWidget window, bool removeReferrer, bool trustedSource, bool hideErrorDialog) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("BrowserRun####$$$", "BrowserRun(const KUrl&, const KParts::URLArgs&, KParts::ReadOnlyPart*, QWidget*, bool, bool, bool)", typeof(void), typeof(KUrl), url, typeof(KParts.URLArgs), args, typeof(KParts.ReadOnlyPart), part, typeof(QWidget), window, typeof(bool), removeReferrer, typeof(bool), trustedSource, typeof(bool), hideErrorDialog);
		}
		public BrowserRun(KUrl url, KParts.URLArgs args, KParts.ReadOnlyPart part, QWidget window, bool removeReferrer, bool trustedSource) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("BrowserRun####$$", "BrowserRun(const KUrl&, const KParts::URLArgs&, KParts::ReadOnlyPart*, QWidget*, bool, bool)", typeof(void), typeof(KUrl), url, typeof(KParts.URLArgs), args, typeof(KParts.ReadOnlyPart), part, typeof(QWidget), window, typeof(bool), removeReferrer, typeof(bool), trustedSource);
		}
		public KUrl Url() {
			return (KUrl) interceptor.Invoke("url", "url() const", typeof(KUrl));
		}
		public bool HideErrorDialog() {
			return (bool) interceptor.Invoke("hideErrorDialog", "hideErrorDialog() const", typeof(bool));
		}
		[SmokeMethod("save(const KUrl&, const QString&)")]
		public virtual void Save(KUrl url, string suggestedFileName) {
			interceptor.Invoke("save#$", "save(const KUrl&, const QString&)", typeof(void), typeof(KUrl), url, typeof(string), suggestedFileName);
		}
		/// <remarks>
		///  Reimplemented from KRun
		///          </remarks>		<short>    Reimplemented from KRun          </short>
		[SmokeMethod("scanFile()")]
		protected override void ScanFile() {
			interceptor.Invoke("scanFile", "scanFile()", typeof(void));
		}
		/// <remarks>
		///  Reimplemented from KRun
		///          </remarks>		<short>    Reimplemented from KRun          </short>
		[SmokeMethod("init()")]
		protected override void Init() {
			interceptor.Invoke("init", "init()", typeof(void));
		}
		/// <remarks>
		///  Called when an error happens.
		///  NOTE: <code>job</code> could be null, if you passed hideErrorDialog=true.
		///  The default implementation shows a message box, but only when job != 0 ....
		///  It is strongly recommended to reimplement this method if
		///  you passed hideErrorDialog=true.
		///          </remarks>		<short>    Called when an error happens.</short>
		[SmokeMethod("handleError(KJob*)")]
		protected virtual void HandleError(KJob job) {
			interceptor.Invoke("handleError#", "handleError(KJob*)", typeof(void), typeof(KJob), job);
		}
		/// <remarks>
		///  Helper for foundMimeType: call this if the mimetype couldn't be embedded
		///          </remarks>		<short>    Helper for foundMimeType: call this if the mimetype couldn't be embedded          </short>
		[Q_SLOT("void slotBrowserScanFinished(KJob*)")]
		protected void SlotBrowserScanFinished(KJob job) {
			interceptor.Invoke("slotBrowserScanFinished#", "slotBrowserScanFinished(KJob*)", typeof(void), typeof(KJob), job);
		}
		[Q_SLOT("void slotBrowserMimetype(KIO::Job*, const QString&)")]
		protected void SlotBrowserMimetype(KIO.Job job, string type) {
			interceptor.Invoke("slotBrowserMimetype#$", "slotBrowserMimetype(KIO::Job*, const QString&)", typeof(void), typeof(KIO.Job), job, typeof(string), type);
		}
		[Q_SLOT("void slotCopyToTempFileResult(KJob*)")]
		protected void SlotCopyToTempFileResult(KJob job) {
			interceptor.Invoke("slotCopyToTempFileResult#", "slotCopyToTempFileResult(KJob*)", typeof(void), typeof(KJob), job);
		}
		[Q_SLOT("void slotStatResult(KJob*)")]
		[SmokeMethod("slotStatResult(KJob*)")]
		protected override void SlotStatResult(KJob job) {
			interceptor.Invoke("slotStatResult#", "slotStatResult(KJob*)", typeof(void), typeof(KJob), job);
		}
		~BrowserRun() {
			interceptor.Invoke("~BrowserRun", "~BrowserRun()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~BrowserRun", "~BrowserRun()", typeof(void));
		}
		/// <remarks>
		///  Ask the user whether to save or open a url in another application.
		/// <param> name="url" the URL in question
		/// </param><param> name="offer" the application that will be used to open the URL
		/// </param><param> name="mimeType" the mimetype of the URL
		/// </param><param> name="suggestedFileName" optional file name suggested by the server
		/// </param></remarks>		<return> Save, Open or Cancel.
		///          </return>
		/// 		<short>    Ask the user whether to save or open a url in another application.</short>
		/// <remarks>
		///  Similar to askSave but for the case where the current application is
		///  able to embed the url itself (instead of passing it to another app).
		/// <param> name="url" the URL in question
		/// </param><param> name="mimeType" the mimetype of the URL
		/// </param><param> name="suggestedFileName" optional filename suggested by the server
		/// </param><param> name="flags" reserved for later use
		/// </param></remarks>		<return> Save, Open or Cancel.
		///          </return>
		/// 		<short>    Similar to askSave but for the case where the current application is  able to embed the url itself (instead of passing it to another app).</short>
		public static void SimpleSave(KUrl url, string suggestedFileName, QWidget window) {
			staticInterceptor.Invoke("simpleSave#$#", "simpleSave(const KUrl&, const QString&, QWidget*)", typeof(void), typeof(KUrl), url, typeof(string), suggestedFileName, typeof(QWidget), window);
		}
		public static void SimpleSave(KUrl url, string suggestedFileName) {
			staticInterceptor.Invoke("simpleSave#$", "simpleSave(const KUrl&, const QString&)", typeof(void), typeof(KUrl), url, typeof(string), suggestedFileName);
		}
		public static bool AllowExecution(string mimeType, KUrl url) {
			return (bool) staticInterceptor.Invoke("allowExecution$#", "allowExecution(const QString&, const KUrl&)", typeof(bool), typeof(string), mimeType, typeof(KUrl), url);
		}
		public static bool IsTextExecutable(string mimeType) {
			return (bool) staticInterceptor.Invoke("isTextExecutable$", "isTextExecutable(const QString&)", typeof(bool), typeof(string), mimeType);
		}
		protected new IBrowserRunSignals Emit {
			get { return (IBrowserRunSignals) Q_EMIT; }
		}
	}

	public interface IBrowserRunSignals : IKRunSignals {
	}
	}
}
