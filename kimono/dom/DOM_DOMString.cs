//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace DOM {

	using System;
	using Qyoto;

	/// <remarks>
	///  This class implements the basic string we use in the DOM. We do not use
	///  string for 2 reasons: Memory overhead, and the missing explicit sharing
	///  of strings we need for the DOM.
	///  All DOMStrings are explicitly shared (they behave like pointers), meaning
	///  that modifications to one instance will also modify all others. If you
	///  wish to get a DOMString that is independent, use copy().
	///  </remarks>		<short>    This class implements the basic string we use in the DOM.</short>

	[SmokeClass("DOM::DOMString")]
	public class DOMString : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected DOMString(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(DOMString), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static DOMString() {
			staticInterceptor = new SmokeInvocation(typeof(DOMString), null);
		}
		/// <remarks>
		///  default constructor. Gives an empty DOMString
		///      </remarks>		<short>    default constructor.</short>
		public DOMString() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DOMString", "DOMString()", typeof(void));
		}
		public DOMString(char str, uint len) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DOMString#$", "DOMString(const QChar*, uint)", typeof(void), typeof(char), str, typeof(uint), len);
		}
		public DOMString(string arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DOMString$", "DOMString(const QString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  add two DOMString's
		///      </remarks>		<short>    add two DOMString's      </short>
		public void Insert(string str, uint pos) {
			interceptor.Invoke("insert#$", "insert(DOM::DOMString, uint)", typeof(void), typeof(string), str, typeof(uint), pos);
		}
		public int Find(char c, int start) {
			return (int) interceptor.Invoke("find#$", "find(const QChar, int) const", typeof(int), typeof(char), c, typeof(int), start);
		}
		public int Find(char c) {
			return (int) interceptor.Invoke("find#", "find(const QChar) const", typeof(int), typeof(char), c);
		}
		public uint Length() {
			return (uint) interceptor.Invoke("length", "length() const", typeof(uint));
		}
		public void Truncate(uint len) {
			interceptor.Invoke("truncate$", "truncate(unsigned int)", typeof(void), typeof(uint), len);
		}
		public void Remove(uint pos, int len) {
			interceptor.Invoke("remove$$", "remove(unsigned int, int)", typeof(void), typeof(uint), pos, typeof(int), len);
		}
		public void Remove(uint pos) {
			interceptor.Invoke("remove$", "remove(unsigned int)", typeof(void), typeof(uint), pos);
		}
		/// <remarks>
		///  Splits the string into two. The original string gets truncated to pos, and the rest is returned.
		///      </remarks>		<short>    Splits the string into two.</short>
		public string Split(uint pos) {
			return (string) interceptor.Invoke("split$", "split(unsigned int)", typeof(string), typeof(uint), pos);
		}
		/// <remarks>
		///  Returns a lowercase version of the string
		///      </remarks>		<short>    Returns a lowercase version of the string      </short>
		public string Lower() {
			return (string) interceptor.Invoke("lower", "lower() const", typeof(string));
		}
		/// <remarks>
		///  Returns an uppercase version of the string
		///      </remarks>		<short>    Returns an uppercase version of the string      </short>
		public string Upper() {
			return (string) interceptor.Invoke("upper", "upper() const", typeof(string));
		}
		public char Unicode() {
			return (char) interceptor.Invoke("unicode", "unicode() const", typeof(char));
		}
		public string String() {
			return (string) interceptor.Invoke("string", "string() const", typeof(string));
		}
		public int ToInt() {
			return (int) interceptor.Invoke("toInt", "toInt() const", typeof(int));
		}
		public bool Percentage(ref int _percentage) {
			StackItem[] stack = new StackItem[2];
			stack[1].s_int = _percentage;
			interceptor.Invoke("percentage$", "percentage(int&) const", stack);
			_percentage = stack[1].s_int;
			return stack[0].s_bool;
		}
		public string Copy() {
			return (string) interceptor.Invoke("copy", "copy() const", typeof(string));
		}
		public bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		public bool IsEmpty() {
			return (bool) interceptor.Invoke("isEmpty", "isEmpty() const", typeof(bool));
		}
		/// <remarks>
		///  Use at own risk!!!
		///      </remarks>		<short>   </short>
		public string Implementation() {
			return (string) interceptor.Invoke("implementation", "implementation() const", typeof(string));
		}
		~DOMString() {
			interceptor.Invoke("~DOMString", "~DOMString()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~DOMString", "~DOMString()", typeof(void));
		}
		public static string operator+(DOMString lhs, string str) {
			return (string) staticInterceptor.Invoke("operator+#", "operator+(const DOM::DOMString&)", typeof(string), typeof(DOMString), lhs, typeof(string), str);
		}
	}
	}
}
