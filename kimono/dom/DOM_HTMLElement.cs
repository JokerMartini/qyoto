//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace DOM {

	using System;
	using Qyoto;

	/// <remarks>
	///  All HTML element interfaces derive from this class. Elements that
	///  only expose the HTML core attributes are represented by the base
	///  <code>HTMLElement</code> interface. These elements are as
	///  follows:
	///   \li <code>HEAD</code>
	///   <li>special</li>: <tt> SUB, SUP, SPAN, BDO </tt>
	///   <li>font</li>: <tt> TT, I, B, U, S, STRIKE, BIG, SMALL </tt>
	///   <li>phrase</li>: <tt> EM, STRONG, DFN, CODE, SAMP, KBD, VAR,
	///  CITE, ACRONYM, ABBR</tt>
	///   <li>list</li>: <tt> DD, DT </tt>
	///   \li <tt> NOFRAMES, NOSCRIPT </tt>
	///   \li <tt> ADDRESS, CENTER </tt>
	///   Note: The <code>style</code> attribute for this
	///  interface is reserved for future usage.
	///  </remarks>		<short>    All HTML element interfaces derive from this class.</short>

	[SmokeClass("DOM::HTMLElement")]
	public class HTMLElement : DOM.Element, IDisposable {
 		protected HTMLElement(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(HTMLElement), this);
		}
		// DOM::HTMLElement* HTMLElement(DOM::HTMLElementImpl* arg1); >>>> NOT CONVERTED
		public HTMLElement() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLElement", "HTMLElement()", typeof(void));
		}
		public HTMLElement(DOM.HTMLElement other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLElement#", "HTMLElement(const DOM::HTMLElement&)", typeof(void), typeof(DOM.HTMLElement), other);
		}
		public HTMLElement(DOM.Node other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLElement#", "HTMLElement(const DOM::Node&)", typeof(void), typeof(DOM.Node), other);
		}
		/// <remarks>
		///  The element's identifier. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/global.html#adef-id">
		///  id attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    The element's identifier.</short>
		public string Id() {
			return (string) interceptor.Invoke("id", "id() const", typeof(string));
		}
		/// <remarks>
		///  see id
		///      </remarks>		<short>    see id      </short>
		public void SetId(string arg1) {
			interceptor.Invoke("setId#", "setId(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  The element's advisory title. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/global.html#adef-title">
		///  title attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    The element's advisory title.</short>
		public string Title() {
			return (string) interceptor.Invoke("title", "title() const", typeof(string));
		}
		/// <remarks>
		///  see title
		///      </remarks>		<short>    see title      </short>
		public void SetTitle(string arg1) {
			interceptor.Invoke("setTitle#", "setTitle(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Language code defined in RFC 1766. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/dirlang.html#adef-lang">
		///  lang attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Language code defined in RFC 1766.</short>
		public string Lang() {
			return (string) interceptor.Invoke("lang", "lang() const", typeof(string));
		}
		/// <remarks>
		///  see lang
		///      </remarks>		<short>    see lang      </short>
		public void SetLang(string arg1) {
			interceptor.Invoke("setLang#", "setLang(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Specifies the base direction of directionally neutral text and
		///  the directionality of tables. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/dirlang.html#adef-dir">
		///  dir attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Specifies the base direction of directionally neutral text and  the directionality of tables.</short>
		public string Dir() {
			return (string) interceptor.Invoke("dir", "dir() const", typeof(string));
		}
		/// <remarks>
		///  see dir
		///      </remarks>		<short>    see dir      </short>
		public void SetDir(string arg1) {
			interceptor.Invoke("setDir#", "setDir(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  The class attribute of the element. This attribute has been
		///  renamed due to conflicts with the "class" keyword exposed by
		///  many languages. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/global.html#adef-class">
		///  class attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    The class attribute of the element.</short>
		public string ClassName() {
			return (string) interceptor.Invoke("className", "className() const", typeof(string));
		}
		/// <remarks>
		///  see className
		///      </remarks>		<short>    see className      </short>
		public void SetClassName(string arg1) {
			interceptor.Invoke("setClassName#", "setClassName(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  The HTML code contained in this element.
		///  This function is not part of the DOM specifications as defined by the w3c.
		///      </remarks>		<short>    The HTML code contained in this element.</short>
		public string InnerHTML() {
			return (string) interceptor.Invoke("innerHTML", "innerHTML() const", typeof(string));
		}
		/// <remarks>
		///  Set the HTML content of this node.
		/// </remarks>		<short>    Set the HTML content of this node.</short>
		public void SetInnerHTML(string html) {
			interceptor.Invoke("setInnerHTML#", "setInnerHTML(const DOM::DOMString&)", typeof(void), typeof(string), html);
		}
		/// <remarks>
		///  The text contained in this element.
		///  This function is not part of the DOM specifications as defined by the w3c.
		///      </remarks>		<short>    The text contained in this element.</short>
		public string InnerText() {
			return (string) interceptor.Invoke("innerText", "innerText() const", typeof(string));
		}
		/// <remarks>
		///  Set the text content of this node.
		/// </remarks>		<short>    Set the text content of this node.</short>
		public void SetInnerText(string text) {
			interceptor.Invoke("setInnerText#", "setInnerText(const DOM::DOMString&)", typeof(void), typeof(string), text);
		}
		/// <remarks>
		///  Retrieves a collection of nodes that are direct descendants of this node.
		///  IE-specific extension.
		///      </remarks>		<short>    Retrieves a collection of nodes that are direct descendants of this node.</short>
		public DOM.HTMLCollection Children() {
			return (DOM.HTMLCollection) interceptor.Invoke("children", "children() const", typeof(DOM.HTMLCollection));
		}
		/// <remarks>
		///  Retrieves a collection of all nodes that descend from this node.
		///  IE-specific extension.
		///      </remarks>		<short>    Retrieves a collection of all nodes that descend from this node.</short>
		public DOM.HTMLCollection All() {
			return (DOM.HTMLCollection) interceptor.Invoke("all", "all() const", typeof(DOM.HTMLCollection));
		}
		public void RemoveCSSProperty(string property) {
			interceptor.Invoke("removeCSSProperty#", "removeCSSProperty(const DOM::DOMString&)", typeof(void), typeof(string), property);
		}
		public void AddCSSProperty(string property, string value) {
			interceptor.Invoke("addCSSProperty##", "addCSSProperty(const DOM::DOMString&, const DOM::DOMString&)", typeof(void), typeof(string), property, typeof(string), value);
		}
		protected void AssignOther(DOM.Node other, int elementId) {
			interceptor.Invoke("assignOther#$", "assignOther(const DOM::Node&, int)", typeof(void), typeof(DOM.Node), other, typeof(int), elementId);
		}
		~HTMLElement() {
			interceptor.Invoke("~HTMLElement", "~HTMLElement()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~HTMLElement", "~HTMLElement()", typeof(void));
		}
	}
	}
}
