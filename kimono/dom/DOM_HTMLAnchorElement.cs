//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace DOM {

	using System;
	using Qyoto;

	/// <remarks>
	///  The anchor element. See the <a
	///  href="http://www.w3.org/TR/REC-html40/struct/links.html#edef-A"> A
	///  element definition </a> in HTML 4.0.
	///  </remarks>		<short>    The anchor element.</short>

	[SmokeClass("DOM::HTMLAnchorElement")]
	public class HTMLAnchorElement : DOM.HTMLElement, IDisposable {
 		protected HTMLAnchorElement(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(HTMLAnchorElement), this);
		}
		// DOM::HTMLAnchorElement* HTMLAnchorElement(DOM::HTMLAnchorElementImpl* arg1); >>>> NOT CONVERTED
		public HTMLAnchorElement() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLAnchorElement", "HTMLAnchorElement()", typeof(void));
		}
		public HTMLAnchorElement(DOM.HTMLAnchorElement other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLAnchorElement#", "HTMLAnchorElement(const DOM::HTMLAnchorElement&)", typeof(void), typeof(DOM.HTMLAnchorElement), other);
		}
		public HTMLAnchorElement(DOM.Node other) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("HTMLAnchorElement#", "HTMLAnchorElement(const DOM::Node&)", typeof(void), typeof(DOM.Node), other);
		}
		/// <remarks>
		///  A single character access key to give access to the form
		///  control. See the <a
		///  href="http://www.w3.org/TR/REC-html40/interact/forms.html#adef-accesskey">
		///  accesskey attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    A single character access key to give access to the form  control.</short>
		public string AccessKey() {
			return (string) interceptor.Invoke("accessKey", "accessKey() const", typeof(string));
		}
		/// <remarks>
		///  see accessKey
		///      </remarks>		<short>    see accessKey      </short>
		public void SetAccessKey(string arg1) {
			interceptor.Invoke("setAccessKey#", "setAccessKey(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  The character encoding of the linked resource. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/links.html#adef-charset">
		///  charset attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    The character encoding of the linked resource.</short>
		public string Charset() {
			return (string) interceptor.Invoke("charset", "charset() const", typeof(string));
		}
		/// <remarks>
		///  see charset
		///      </remarks>		<short>    see charset      </short>
		public void SetCharset(string arg1) {
			interceptor.Invoke("setCharset#", "setCharset(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Comma-separated list of lengths, defining an active region
		///  geometry. See also <code>shape</code> for the shape of the
		///  region. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/objects.html#adef-coords">
		///  coords attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Comma-separated list of lengths, defining an active region  geometry.</short>
		public string Coords() {
			return (string) interceptor.Invoke("coords", "coords() const", typeof(string));
		}
		/// <remarks>
		///  see coords
		///      </remarks>		<short>    see coords      </short>
		public void SetCoords(string arg1) {
			interceptor.Invoke("setCoords#", "setCoords(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  The URI of the linked resource. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/links.html#adef-href">
		///  href attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    The URI of the linked resource.</short>
		public string Href() {
			return (string) interceptor.Invoke("href", "href() const", typeof(string));
		}
		/// <remarks>
		///  see href
		///      </remarks>		<short>    see href      </short>
		public void SetHref(string arg1) {
			interceptor.Invoke("setHref#", "setHref(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Language code of the linked resource. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/links.html#adef-hreflang">
		///  hreflang attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Language code of the linked resource.</short>
		public string Hreflang() {
			return (string) interceptor.Invoke("hreflang", "hreflang() const", typeof(string));
		}
		/// <remarks>
		///  see hreflang
		///      </remarks>		<short>    see hreflang      </short>
		public void SetHreflang(string arg1) {
			interceptor.Invoke("setHreflang#", "setHreflang(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Anchor name. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/links.html#adef-name-A">
		///  name attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Anchor name.</short>
		public string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		/// <remarks>
		///  see name
		///      </remarks>		<short>    see name      </short>
		public void SetName(string arg1) {
			interceptor.Invoke("setName#", "setName(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Forward link type. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/links.html#adef-rel">
		///  rel attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Forward link type.</short>
		public string Rel() {
			return (string) interceptor.Invoke("rel", "rel() const", typeof(string));
		}
		/// <remarks>
		///  see rel
		///      </remarks>		<short>    see rel      </short>
		public void SetRel(string arg1) {
			interceptor.Invoke("setRel#", "setRel(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Reverse link type. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/links.html#adef-rev">
		///  rev attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Reverse link type.</short>
		public string Rev() {
			return (string) interceptor.Invoke("rev", "rev() const", typeof(string));
		}
		/// <remarks>
		///  see rev
		///      </remarks>		<short>    see rev      </short>
		public void SetRev(string arg1) {
			interceptor.Invoke("setRev#", "setRev(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  The shape of the active area. The coordinates are given by
		///  <code>coords</code> . See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/objects.html#adef-shape">
		///  shape attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    The shape of the active area.</short>
		public string Shape() {
			return (string) interceptor.Invoke("shape", "shape() const", typeof(string));
		}
		/// <remarks>
		///  see shape
		///      </remarks>		<short>    see shape      </short>
		public void SetShape(string arg1) {
			interceptor.Invoke("setShape#", "setShape(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Index that represents the element's position in the tabbing
		///  order. See the <a
		///  href="http://www.w3.org/TR/REC-html40/interact/forms.html#adef-tabindex">
		///  tabindex attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Index that represents the element's position in the tabbing  order.</short>
		public long TabIndex() {
			return (long) interceptor.Invoke("tabIndex", "tabIndex() const", typeof(long));
		}
		/// <remarks>
		///  see tabIndex
		///      </remarks>		<short>    see tabIndex      </short>
		public void SetTabIndex(long arg1) {
			interceptor.Invoke("setTabIndex$", "setTabIndex(long)", typeof(void), typeof(long), arg1);
		}
		/// <remarks>
		///  Frame to render the resource in. See the <a
		///  href="http://www.w3.org/TR/REC-html40/present/frames.html#adef-target">
		///  target attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Frame to render the resource in.</short>
		public string Target() {
			return (string) interceptor.Invoke("target", "target() const", typeof(string));
		}
		/// <remarks>
		///  see target
		///      </remarks>		<short>    see target      </short>
		public void SetTarget(string arg1) {
			interceptor.Invoke("setTarget#", "setTarget(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Advisory content type. See the <a
		///  href="http://www.w3.org/TR/REC-html40/struct/links.html#adef-type-A">
		///  type attribute definition </a> in HTML 4.0.
		///      </remarks>		<short>    Advisory content type.</short>
		public string type() {
			return (string) interceptor.Invoke("type", "type() const", typeof(string));
		}
		/// <remarks>
		///  see type
		///      </remarks>		<short>    see type      </short>
		public void SetType(string arg1) {
			interceptor.Invoke("setType#", "setType(const DOM::DOMString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Removes keyboard focus from this element.
		///      </remarks>		<short>    Removes keyboard focus from this element.</short>
		public void Blur() {
			interceptor.Invoke("blur", "blur()", typeof(void));
		}
		/// <remarks>
		///  Gives keyboard focus to this element.
		///      </remarks>		<short>    Gives keyboard focus to this element.</short>
		public void Focus() {
			interceptor.Invoke("focus", "focus()", typeof(void));
		}
		~HTMLAnchorElement() {
			interceptor.Invoke("~HTMLAnchorElement", "~HTMLAnchorElement()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~HTMLAnchorElement", "~HTMLAnchorElement()", typeof(void));
		}
	}
	}
}
