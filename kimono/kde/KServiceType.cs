//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  A service type is, well, a type of service, where a service is an application or plugin.
	///  For instance, "KOfficeFilter", which is the type of all koffice filters, is a service type.
	///  In order to discover services of a given type, using KServiceTypeTrader.
	///  Service types are stored as desktop files in $KDEDIR/share/servicetypes.
	/// </remarks>		<short>    A service type is, well, a type of service, where a service is an application or plugin.</short>
	/// 		<see> KService</see>
	/// 		<see> KServiceTypeTrader</see>

	[SmokeClass("KServiceType")]
	public class KServiceType : KSycocaEntry, IDisposable {
 		protected KServiceType(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KServiceType), this);
		}
		// KServiceType::Ptr parentType(); >>>> NOT CONVERTED
		// KServiceType::Ptr serviceType(const QString& arg1); >>>> NOT CONVERTED
		// KServiceType::List allServiceTypes(); >>>> NOT CONVERTED
		/// <remarks>
		///  Construct a service type and take all information from a desktop file.
		/// <param> name="config" the configuration file
		///      </param></remarks>		<short>    Construct a service type and take all information from a desktop file.</short>
		public KServiceType(KDesktopFile config) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KServiceType#", "KServiceType(KDesktopFile*)", typeof(void), typeof(KDesktopFile), config);
		}
		/// <remarks>
		///  The stream must already be positionned at the correct offset
		///      </remarks>		<short>   </short>
		public KServiceType(QDataStream _str, int offset) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KServiceType#$", "KServiceType(QDataStream&, int)", typeof(void), typeof(QDataStream), _str, typeof(int), offset);
		}
		/// <remarks>
		///  Returns the descriptive comment associated, if any.
		/// </remarks>		<return> the comment, or string()
		///      </return>
		/// 		<short>    Returns the descriptive comment associated, if any.</short>
		public string Comment() {
			return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
		}
		/// <remarks>
		///  Returns the name of this service type.
		/// </remarks>		<return> the name of the service type
		///      </return>
		/// 		<short>    Returns the name of this service type.</short>
		[SmokeMethod("name() const")]
		public override string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		/// <remarks>
		///  Returns the relative path to the desktop entry file responsible for
		///          this servicetype.
		///  For instance inode/directory.desktop, or kpart.desktop
		/// </remarks>		<return> the path of the desktop file
		///      </return>
		/// 		<short>    Returns the relative path to the desktop entry file responsible for          this servicetype.</short>
		public string DesktopEntryPath() {
			return (string) interceptor.Invoke("desktopEntryPath", "desktopEntryPath() const", typeof(string));
		}
		/// <remarks>
		///  Checks whether this service type inherits another one.
		/// </remarks>		<return> true if this service type inherits another one
		/// </return>
		/// 		<short>    Checks whether this service type inherits another one.</short>
		/// 		<see> parentServiceType</see>
		public bool IsDerived() {
			return (bool) interceptor.Invoke("isDerived", "isDerived() const", typeof(bool));
		}
		/// <remarks>
		///  If this service type inherits from another service type,
		///  return the name of the parent.
		/// </remarks>		<return> the parent service type, or string. null if not set
		/// </return>
		/// 		<short>    If this service type inherits from another service type,  return the name of the parent.</short>
		/// 		<see> isDerived</see>
		public string ParentServiceType() {
			return (string) interceptor.Invoke("parentServiceType", "parentServiceType() const", typeof(string));
		}
		/// <remarks>
		///  Checks whether this service type is or inherits from <code>servTypeName.</code>
		/// </remarks>		<return> true if this servicetype is or inherits from <code>servTypeName</code>
		///      </return>
		/// 		<short>    Checks whether this service type is or inherits from <code>servTypeName.</code></short>
		public bool Inherits(string servTypeName) {
			return (bool) interceptor.Invoke("inherits$", "inherits(const QString&) const", typeof(bool), typeof(string), servTypeName);
		}
		/// <remarks>
		///  Returns the requested property. Some often used properties
		///  have convenience access functions like name(),
		///  comment().
		/// <param> name="_name" the name of the property
		/// </param></remarks>		<return> the property, or invalid if not found
		///      </return>
		/// 		<short>    Returns the requested property.</short>
		[SmokeMethod("property(const QString&) const")]
		public virtual QVariant Property(string _name) {
			return (QVariant) interceptor.Invoke("property$", "property(const QString&) const", typeof(QVariant), typeof(string), _name);
		}
		/// <remarks>
		///  Returns the list of all properties of this service type.
		///  Properties, apart from Name, and Comment, are defined in
		///  the servicetype .desktop file using
		///  @code
		///  [Property.MyPropertyName]
		///  Type=<the name of a type supported by QVariant>
		///  Value=<the value>
		///  @endcode
		/// </remarks>		<return> the list of properties
		///      </return>
		/// 		<short>    Returns the list of all properties of this service type.</short>
		[SmokeMethod("propertyNames() const")]
		public virtual List<string> PropertyNames() {
			return (List<string>) interceptor.Invoke("propertyNames", "propertyNames() const", typeof(List<string>));
		}
		/// <remarks>
		///  Checks whether the service type is valid.
		/// </remarks>		<return> true if the service is valid (e.g. name is not empty)
		///      </return>
		/// 		<short>    Checks whether the service type is valid.</short>
		[SmokeMethod("isValid() const")]
		public override bool IsValid() {
			return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
		}
		/// <remarks>
		///  Returns the type of the property definition with the given <code>_name.</code>
		/// <param> name="_name" the name of the property
		/// </param></remarks>		<return> the property type, or null if not found
		/// </return>
		/// 		<short>    Returns the type of the property definition with the given <code>_name.</code></short>
		/// 		<see> propertyDefNames</see>
		public QVariant.TypeOf PropertyDef(string _name) {
			return (QVariant.TypeOf) interceptor.Invoke("propertyDef$", "propertyDef(const QString&) const", typeof(QVariant.TypeOf), typeof(string), _name);
		}
		/// <remarks>
		///  Returns the list of all property definitions for this servicetype.
		///  Those are properties of the services implementing this servicetype.
		///  For instance,
		///  @code
		///  [PropertyDef.X-KDevelop-Version]
		///  Type=int
		///  @endcode
		///  means that all kdevelop plugins have in their .desktop file a line like
		///  @code
		///  X-KDevelop-Version=<some value>
		///  @endcode
		///      </remarks>		<short>    Returns the list of all property definitions for this servicetype.</short>
		public List<string> PropertyDefNames() {
			return (List<string>) interceptor.Invoke("propertyDefNames", "propertyDefNames() const", typeof(List<string>));
		}
		public Dictionary<string, QVariant.TypeOf> PropertyDefs() {
			return (Dictionary<string, QVariant.TypeOf>) interceptor.Invoke("propertyDefs", "propertyDefs() const", typeof(Dictionary<string, QVariant.TypeOf>));
		}
		/// <remarks>
		///  Save ourselves to the data stream.
		///      </remarks>		<short>   </short>
		[SmokeMethod("save(QDataStream&)")]
		public override void Save(QDataStream arg1) {
			interceptor.Invoke("save#", "save(QDataStream&)", typeof(void), typeof(QDataStream), arg1);
		}
		/// <remarks>
		///  Load ourselves from the data stream.
		///      </remarks>		<short>   </short>
		[SmokeMethod("load(QDataStream&)")]
		public override void Load(QDataStream arg1) {
			interceptor.Invoke("load#", "load(QDataStream&)", typeof(void), typeof(QDataStream), arg1);
		}
		/// <remarks>
		///  Pointer to parent service type
		///      </remarks>		<short>   </short>
		/// <remarks>
		///  Register offset into offers list
		///      </remarks>		<short>   </short>
		public void SetServiceOffersOffset(int offset) {
			interceptor.Invoke("setServiceOffersOffset$", "setServiceOffersOffset(int)", typeof(void), typeof(int), offset);
		}
		/// <remarks>
		///      </remarks>		<short>   </short>
		public int ServiceOffersOffset() {
			return (int) interceptor.Invoke("serviceOffersOffset", "serviceOffersOffset() const", typeof(int));
		}
		~KServiceType() {
			interceptor.Invoke("~KServiceType", "~KServiceType()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KServiceType", "~KServiceType()", typeof(void));
		}
		/// <remarks>
		///  Returns a pointer to the servicetype '_name' or null if the
		///          service type is unknown.
		///  VERY IMPORTANT : don't store the result in a KServiceType  !
		/// <param> name="_name" the name of the service type to search
		/// </param></remarks>		<return> the pointer to the service type, or 0
		///      </return>
		/// 		<short>    Returns a pointer to the servicetype '_name' or 0L if the          service type is unknown.</short>
		/// <remarks>
		///  Returns a list of all the supported servicetypes. Useful for
		///          showing the list of available servicetypes in a listbox,
		///          for example.
		///  More memory consuming than the ones above, don't use unless
		///  really necessary.
		/// </remarks>		<return> the list of all services
		///      </return>
		/// 		<short>    Returns a list of all the supported servicetypes.</short>
	}
}
