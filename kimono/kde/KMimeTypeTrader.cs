//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Text;
	using System.Collections.Generic;

	/// <remarks>
	///  KDE's trader for services associated to a given mimetype.
	///  Note: If Service means Application or Component/Plugin, see
	///  KServiceTypeTrader and KService.
	///  Example: say that you want to the list of all KParts components that can handle HTML.
	///  Our code would look like:
	///  <pre>
	///  KServiceOfferList lst = KMimeTypeTrader.Self().Query("text/html",
	///                                                         "KParts/ReadOnlyPart");
	///  </pre>
	///  If you want to get the preferred KParts component for text/html you could use
	///  preferredService("text/html", "KParts/ReadOnlyPart"), although if this is about
	///  loading that component you would rather use KParts.ComponentFactory directly.
	/// </remarks>		<short>    KDE's trader for services associated to a given mimetype.</short>
	/// 		<see> KServiceTypeTrader</see>
	/// 		<see> KService</see>

	[SmokeClass("KMimeTypeTrader")]
	public class KMimeTypeTrader : Object {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KMimeTypeTrader(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KMimeTypeTrader), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KMimeTypeTrader() {
			staticInterceptor = new SmokeInvocation(typeof(KMimeTypeTrader), null);
		}
		// KService::Ptr preferredService(const QString& arg1,const QString& arg2); >>>> NOT CONVERTED
		// KService::Ptr preferredService(const QString& arg1); >>>> NOT CONVERTED
		// template <T>  T* createPartInstanceFromQuery(const QString& arg1,QWidget* arg2,QObject* arg3,const QString& arg4,const QVariantList& arg5,QString* arg6); >>>> NOT CONVERTED
		// template <T>  T* createPartInstanceFromQuery(const QString& arg1,QWidget* arg2,QObject* arg3,const QString& arg4,const QVariantList& arg5); >>>> NOT CONVERTED
		// template <T>  T* createPartInstanceFromQuery(const QString& arg1,QWidget* arg2,QObject* arg3,const QString& arg4); >>>> NOT CONVERTED
		// template <T>  T* createPartInstanceFromQuery(const QString& arg1,QWidget* arg2,QObject* arg3); >>>> NOT CONVERTED
		// template <T>  T* createPartInstanceFromQuery(const QString& arg1,QWidget* arg2); >>>> NOT CONVERTED
		// template <T>  T* createPartInstanceFromQuery(const QString& arg1); >>>> NOT CONVERTED
		// template <T>  T* createInstanceFromQuery(const QString& arg1,const QString& arg2,QObject* arg3,const QString& arg4,const QVariantList& arg5,QString* arg6); >>>> NOT CONVERTED
		// template <T>  T* createInstanceFromQuery(const QString& arg1,const QString& arg2,QObject* arg3,const QString& arg4,const QVariantList& arg5); >>>> NOT CONVERTED
		// template <T>  T* createInstanceFromQuery(const QString& arg1,const QString& arg2,QObject* arg3,const QString& arg4); >>>> NOT CONVERTED
		// template <T>  T* createInstanceFromQuery(const QString& arg1,const QString& arg2,QObject* arg3); >>>> NOT CONVERTED
		// template <T>  T* createInstanceFromQuery(const QString& arg1,const QString& arg2); >>>> NOT CONVERTED
		/// <remarks>
		///  This method returns a list of services which are associated with a given mimetype.
		///  Example usage:
		///  To get list of applications that can handle a given mimetype,
		///  set <code>genericServiceType</code> to "Application" (which is the default).
		///  To get list of embeddable components that can handle a given mimetype,
		///  set <code>genericServiceType</code> to "KParts/ReadOnlyPart".
		///  The constraint parameter is used to limit the possible choices
		///  returned based on the constraints you give it.
		///  The <code>constraint</code> language is rather full.  The most common
		///  keywords are AND, OR, NOT, IN, and EXIST, all used in an
		///  almost spoken-word form.  An example is:
		///  <pre>
		///  (Type == 'Service') and (('Browser/View' in ServiceTypes) and (exist Library))
		///  </pre>
		///  The keys used in the query (Type, ServiceTypes, Library) are all
		///  fields found in the .desktop files.
		/// <param> name="mimeType" A mime type like 'text/plain' or 'text/html'.
		/// </param><param> name="genericServiceType" a basic service type, like 'KParts/ReadOnlyPart' or 'Application'
		/// </param><param> name="constraint" A constraint to limit the choices returned, string() to
		///                     get all services that can handle the given <code>mimetype</code>
		/// </param></remarks>		<return> A list of services that satisfy the query, sorted by preference
		///  (preferred service first)
		/// </return>
		/// 		<short>    This method returns a list of services which are associated with a given mimetype.</short>
		/// 		<see> http://developer.kde.org/documentation/library/kdeqt/tradersyntax.html</see>
		public List<KService> Query(string mimeType, string genericServiceType, string constraint) {
			return (List<KService>) interceptor.Invoke("query$$$", "query(const QString&, const QString&, const QString&) const", typeof(List<KService>), typeof(string), mimeType, typeof(string), genericServiceType, typeof(string), constraint);
		}
		public List<KService> Query(string mimeType, string genericServiceType) {
			return (List<KService>) interceptor.Invoke("query$$", "query(const QString&, const QString&) const", typeof(List<KService>), typeof(string), mimeType, typeof(string), genericServiceType);
		}
		public List<KService> Query(string mimeType) {
			return (List<KService>) interceptor.Invoke("query$", "query(const QString&) const", typeof(List<KService>), typeof(string), mimeType);
		}
		/// <remarks>
		///  Returns the preferred service for <code>mimeType</code> and <code>genericServiceType</code>
		///  This is almost like offers().first(), except that it also checks
		///  if the service is allowed as a preferred service (see KService.AllowAsDefault).
		/// <param> name="mimeType" the mime type (see offers())
		/// </param><param> name="genericServiceType" the service type (see offers())
		/// </param></remarks>		<return> the preferred service, or 0 if no service is available
		///      </return>
		/// 		<short>    Returns the preferred service for <code>mimeType</code> and <code>genericServiceType</code> </short>
		/// <remarks>
		///  This method creates and returns a part object from the trader query for a given <pre>mimeType</pre>.
		///  Example:
		///  <pre>
		///  KParts.ReadOnlyPart part = KMimeTypeTrader.CreateInstanceFromQuery<KParts.ReadOnlyPart>("text/plain", parentWidget, parentObject);
		///  if (part) {
		///      part.OpenUrl(url);
		///      part.Widget().Show();  // also insert the widget into a layout, or simply use a KVBox as parentWidget
		///  }
		///  </pre>
		/// <param> name="mimeType" the mimetype which this part is associated with
		/// </param><param> name="parentWidget" the parent widget, will be set as the parent of the part's widget
		/// </param><param> name="parent" the parent object for the part itself
		/// </param><param> name="constraint" an optional constraint to pass to the trader
		/// </param><param> name="args" A list of arguments passed to the service component
		/// </param><param> name="error" The string passed here will contain an error description.
		/// </param></remarks>		<return> A pointer to the newly created object or a null pointer if the
		///          factory was unable to create an object of the given type.
		///      </return>
		/// 		<short>    This method creates and returns a part object from the trader query for a given \p mimeType.</short>
		/// <remarks>
		///  This can be used to create a service instance from a mime type query
		/// <param> name="mimeType" A mime type like 'text/plain' or 'text/html'.
		/// </param><param> name="genericServiceType" a basic service type
		/// </param><param> name="parent" the parent object for the plugin itself
		/// </param><param> name="constraint" A constraint to limit the choices returned, string() to
		///                     get all services that can handle the given <code>mimetype</code>
		/// </param><param> name="args" A list of arguments passed to the service component
		/// </param><param> name="error" The string passed here will contain an error description.
		/// </param></remarks>		<return> A pointer to the newly created object or a null pointer if the
		///          factory was unable to create an object of the given type.
		///      </return>
		/// 		<short>    This can be used to create a service instance from a mime type query </short>
		/// <remarks>
		///  This is a static pointer to the KMimeTypeTrader singleton.
		///  You will need to use this to access the KMimeTypeTrader functionality since the
		///  constructors are protected.
		/// </remarks>		<return> Static KMimeTypeTrader instance
		///      </return>
		/// 		<short>    This is a static pointer to the KMimeTypeTrader singleton.</short>
		public static KMimeTypeTrader Self() {
			return (KMimeTypeTrader) staticInterceptor.Invoke("self", "self()", typeof(KMimeTypeTrader));
		}
	}
}
