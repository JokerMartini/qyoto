//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  If you have a pixmap containing several items (icons), you can use this
	///  class to get the coordinates of each item.
	///  For example, if you have a pixmap with 25 items and you want to get the
	///  4th item as a pixmap (every item being 20x10 pixels):
	///  <pre>
	///  KPixmapSplitter splitter;
	///  splitter.setPixmap( somePixmap );
	///  splitter.setItemSize( QSize( 20, 10 ));
	///  QPixmap item( 20, 10 );
	///  item.fill( Qt.White );
	///  QRect rect = splitter.coordinates( 4 );
	///  if ( !rect.isEmpty() )
	///      bitBlt( &item, QPoint(0,0), &somePixmap, rect, CopyROP );
	///  </pre>
	/// </remarks>		<author> Carsten Pfeiffer <pfeiffer@kde.org>
	///  </author>
	/// 		<short> A class to split a pixmap into several items. </short>

	[SmokeClass("KPixmapSplitter")]
	public class KPixmapSplitter : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KPixmapSplitter(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KPixmapSplitter), this);
		}
		/// <remarks>
		///  Constructor, does nothing but initialize some default-values.
		///      </remarks>		<short>    Constructor, does nothing but initialize some default-values.</short>
		public KPixmapSplitter() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPixmapSplitter", "KPixmapSplitter()", typeof(void));
		}
		/// <remarks>
		///  Sets the pixmap to be split.
		///      </remarks>		<short>    Sets the pixmap to be split.</short>
		public void SetPixmap(QPixmap pixmap) {
			interceptor.Invoke("setPixmap#", "setPixmap(const QPixmap&)", typeof(void), typeof(QPixmap), pixmap);
		}
		/// <remarks>
		/// </remarks>		<return> the pixmap that has been set via setPixmap().
		///      </return>
		/// 		<short>   </short>
		public QPixmap Pixmap() {
			return (QPixmap) interceptor.Invoke("pixmap", "pixmap() const", typeof(QPixmap));
		}
		/// <remarks>
		///  Sets the size of the items you want to get out of the given pixmap.
		///  The QRect of #coordinates(int) will have the width and height of exactly
		///  this <code>size.</code>
		///      </remarks>		<short>    Sets the size of the items you want to get out of the given pixmap.</short>
		public void SetItemSize(QSize size) {
			interceptor.Invoke("setItemSize#", "setItemSize(const QSize&)", typeof(void), typeof(QSize), size);
		}
		/// <remarks>
		/// </remarks>		<return> the set size of the items (coordinates) you want to get
		///  out of the given pixmap.
		///      </return>
		/// 		<short>   </short>
		public QSize ItemSize() {
			return (QSize) interceptor.Invoke("itemSize", "itemSize() const", typeof(QSize));
		}
		/// <remarks>
		///  If there is space between rows in the given pixmap, you have to specify
		///  how many pixels there are.
		///      </remarks>		<short>    If there is space between rows in the given pixmap, you have to specify  how many pixels there are.</short>
		public void SetVSpacing(int spacing) {
			interceptor.Invoke("setVSpacing$", "setVSpacing(int)", typeof(void), typeof(int), spacing);
		}
		/// <remarks>
		///  If there is space between columns in the given pixmap, you have to
		///  specify how many pixels there are.
		///      </remarks>		<short>    If there is space between columns in the given pixmap, you have to  specify how many pixels there are.</short>
		public void SetHSpacing(int spacing) {
			interceptor.Invoke("setHSpacing$", "setHSpacing(int)", typeof(void), typeof(int), spacing);
		}
		/// <remarks>
		/// </remarks>		<return> the coordinates of the item at position pos in the given
		///  pixmap.
		///      </return>
		/// 		<short>   </short>
		public QRect Coordinates(int pos) {
			return (QRect) interceptor.Invoke("coordinates$", "coordinates(int)", typeof(QRect), typeof(int), pos);
		}
		/// <remarks>
		///  Overloaded for convenience. Returns the item at the position of the
		///  given character (when using a latin1 font-pixmap)
		///      </remarks>		<short>    Overloaded for convenience.</short>
		public QRect Coordinates(char ch) {
			return (QRect) interceptor.Invoke("coordinates#", "coordinates(const QChar&)", typeof(QRect), typeof(char), ch);
		}
		~KPixmapSplitter() {
			interceptor.Invoke("~KPixmapSplitter", "~KPixmapSplitter()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KPixmapSplitter", "~KPixmapSplitter()", typeof(void));
		}
	}
}
