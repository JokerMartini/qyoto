//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;


	[SmokeClass("KSettings")]
	public class KSettings : Object {
		protected SmokeInvocation interceptor = null;

		/// <remarks>
		///  For more information see \ref KSettings.
		///  This class aims to standardize the use of configuration dialogs in KDE
		///  applications. Especially when using KParts and/or Plugins you face problems
		///  creating a consistent config dialog.
		///  To show a configuration dialog you only have to call the show method and be
		///  done with it. A code example:
		///  You initialize <pre>m_cfgdlg</pre> with
		///  <pre>
		///  m_cfgdlg = new Dialog( this );
		///  </pre>
		///  If you use a KPart that was not especially designed for your app you can use
		///  the second constructor:
		///  <pre>
		///  List<string> kpartslist;
		///  for( all my kparts )
		///    kpartslist += m_mypart.ComponentData().componentName();
		///  m_cfgdlg = new Dialog( kpartslist, this );
		///  </pre>
		///  and the action for the config dialog is connected to the show slot:
		///  <pre>
		///  KStdAction.Preferences( m_cfgdlg, SLOT("show()"), actionCollection() );
		///  </pre>
		///  If you need to be informed when the config was changed and applied in the
		///  dialog you might want to take a look at Dispatcher.
		///  For more information see \ref KSettings.
		///  See <see cref="IDialogSignals"></see> for signals emitted by Dialog
		/// </remarks>		<author> Matthias Kretz <kretz@kde.org>
		///  </author>
		/// 		<short> Generic configuration dialog that works over component boundaries.</short>

		[SmokeClass("KSettings::Dialog")]
		public class Dialog : KCMultiDialog, IDisposable {
	 		protected Dialog(Type dummy) : base((Type) null) {}
			protected new void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(Dialog), this);
			}
			// QList<KPluginInfo*> pluginInfos(); >>>> NOT CONVERTED
			/// <remarks>
			///  Construct a new Preferences Dialog for the application. It uses all
			///  KCMs with X-KDE-ParentApp set to KGlobal.MainComponent().componentName().
			/// <param> name="content" Select whether you want a static or configurable
			///                      config dialog.
			/// </param><param> name="parent" The parent is only used as the parent for the
			///                      dialog - centering the dialog over the parent
			///                      widget.
			///          </param></remarks>		<short>    Construct a new Preferences Dialog for the application.</short>
			public Dialog(QWidget parent) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Dialog#", "Dialog(QWidget*)", typeof(void), typeof(QWidget), parent);
			}
			public Dialog() : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Dialog", "Dialog()", typeof(void));
			}
			/// <remarks>
			///  Construct a new Preferences Dialog with the pages for the selected
			///  instance names. For example if you want to have the configuration
			///  pages for the kviewviewer KPart you would pass a
			///  List<string> consisting of only the name of the part "kviewviewer".
			/// <param> name="components" A list of the names of the components that your
			///                      config dialog should merge the config pages in.
			/// </param><param> name="parent" The parent is only used as the parent for the
			///                      dialog - centering the dialog over the parent
			///                      widget.
			///          </param></remarks>		<short>    Construct a new Preferences Dialog with the pages for the selected  instance names.</short>
			public Dialog(List<string> components, QWidget parent) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Dialog?#", "Dialog(const QStringList&, QWidget*)", typeof(void), typeof(List<string>), components, typeof(QWidget), parent);
			}
			public Dialog(List<string> components) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Dialog?", "Dialog(const QStringList&)", typeof(void), typeof(List<string>), components);
			}
			/// <remarks>
			///  If you use a Configurable dialog you need to pass KPluginInfo
			///  objects that the dialog should configure.
			///          </remarks>		<short>    If you use a Configurable dialog you need to pass KPluginInfo  objects that the dialog should configure.</short>
			public void AddPluginInfos(List<KPluginInfo> plugininfos) {
				interceptor.Invoke("addPluginInfos?", "addPluginInfos(const QList<KPluginInfo*>&)", typeof(void), typeof(List<KPluginInfo>), plugininfos);
			}
			/// <remarks>
			///  Sets the argument list that is given to all the KControlModule's when
			///  they are created.
			///  Use this if you have KControlModule's that need special arguments to
			///  work
			///  Note that this function only works before showing the
			///  KSettings.Dialog for the first time.
			/// <param> name="arguments" The list of arguments passed to each KCM
			///          </param></remarks>		<short>    Sets the argument list that is given to all the KControlModule's when  they are created.</short>
			public void SetKCMArguments(List<string> arguments) {
				interceptor.Invoke("setKCMArguments?", "setKCMArguments(const QStringList&)", typeof(void), typeof(List<string>), arguments);
			}
			/// <remarks>
			///  Set the blacklisted component list. Any KCM that lists one
			///  of the components in the given blacklist is not loaded even if it
			///  would fit otherwise. This is a way to explicitly prevent loading of
			///  certain KControlModules.
			///  Note that this function only works before showing the
			///  KSettings.Dialog for the first time.
			/// <param> name="blacklist" the list of components that prevent a KCM from being
			///  loaded
			///          </param></remarks>		<short>    Set the blacklisted component list.</short>
			public void SetComponentBlacklist(List<string> blacklist) {
				interceptor.Invoke("setComponentBlacklist?", "setComponentBlacklist(const QStringList&)", typeof(void), typeof(List<string>), blacklist);
			}
			/// <remarks>
			///  Tells the dialog whether the entries in the listview are all static
			///  or whether it should add checkboxes to select which parts
			///  of the optional functionality should be active or not.
			///  Note that this function only works before showing the dialog for the first time.
			///  Defaults to <pre>false</pre>.
			/// <param> name="allowSelection" <pre>true</pre> The user can select what functionality he wants.
			/// </param><param> name="allowSelection" <pre>false</pre> While running no entries are added or deleted
			///          </param></remarks>		<short>    Tells the dialog whether the entries in the listview are all static  or whether it should add checkboxes to select which parts  of the optional functionality should be active or not.</short>
			public void SetAllowComponentSelection(bool allowSelection) {
				interceptor.Invoke("setAllowComponentSelection$", "setAllowComponentSelection(bool)", typeof(void), typeof(bool), allowSelection);
			}
			public bool AllowComponentSelection() {
				return (bool) interceptor.Invoke("allowComponentSelection", "allowComponentSelection() const", typeof(bool));
			}
			/// <remarks>
			///  Returns a list of all KPluginInfo objects the dialog uses.
			///          </remarks>		<short>    Returns a list of all KPluginInfo objects the dialog uses.</short>
			/// <remarks>
			///  Reimplemented to lazy create the dialog on first show.
			///          </remarks>		<short>    Reimplemented to lazy create the dialog on first show.</short>
			[SmokeMethod("showEvent(QShowEvent*)")]
			protected override void ShowEvent(QShowEvent arg1) {
				interceptor.Invoke("showEvent#", "showEvent(QShowEvent*)", typeof(void), typeof(QShowEvent), arg1);
			}
			~Dialog() {
				interceptor.Invoke("~Dialog", "~Dialog()", typeof(void));
			}
			public new void Dispose() {
				interceptor.Invoke("~Dialog", "~Dialog()", typeof(void));
			}
			protected new IDialogSignals Emit {
				get { return (IDialogSignals) Q_EMIT; }
			}
		}

		public interface IDialogSignals : IKCMultiDialogSignals {
		/// <remarks>
		///  If you use the dialog in Configurable mode and want to be notified
		///  when the user changes the plugin selections use this signal. It's
		///  emitted if the selection has changed and the user pressed Apply or
		///  Ok. In the slot you would then load and unload the plugins as
		///  requested.
		///          </remarks>		<short>    If you use the dialog in Configurable mode and want to be notified  when the user changes the plugin selections use this signal.</short>
		[Q_SIGNAL("void pluginSelectionChanged()")]
		void PluginSelectionChanged();
		}

		/// <remarks>
		///  This class makes it very easy to create a plugins configuration page to your
		///  program. All you need to do is create a class that is derived from
		///  PluginPage and add the appropriate plugin infos to the KPluginSelector.
		///  This is done using the pluginSelector() method:
		///  <pre>
		///  typedef KGenericFactory<MyAppPluginConfig, QWidget> MyAppPluginConfigFactory;
		///  K_EXPORT_COMPONENT_FACTORY( kcm_myapppluginconfig, MyAppPluginConfigFactory( "kcm_myapppluginconfig" ) );
		///  MyAppPluginConfig( QWidget  parent, List<string> args ), parent, args )
		///  {
		///      pluginSelector().AddPlugins( KGlobal.MainComponent().componentName(), i18n( "General Plugins" ), "General" );
		///      pluginSelector().AddPlugins( KGlobal.MainComponent().componentName(), i18n( "Effects" ), "Effects" );
		///  }
		///  </pre>
		///  All that remains to be done is to create the appropriate .desktop file
		///  <pre>
		///    [Desktop Entry]
		///    Encoding=UTF-8
		///    Icon=plugin
		///    Type=Service
		///    ServiceTypes=KCModule
		///    X-KDE-Library=myapppluginconfig
		///    X-KDE-FactoryName=MyAppPluginConfigFactory
		///    X-KDE-ParentApp=myapp
		///    X-KDE-ParentComponents=myapp
		///    Name=Plugins
		///    Comment=Select and configure your plugins:
		///    </pre>
		/// </remarks>		<author> Matthias Kretz <kretz@kde.org>
		///  </author>
		/// 		<short> Convenience KCModule for creating a plugins config page. </short>

		[SmokeClass("KSettings::PluginPage")]
		public class PluginPage : KCModule, IDisposable {
	 		protected PluginPage(Type dummy) : base((Type) null) {}
			protected new void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(PluginPage), this);
			}
			/// <remarks>
			///  Standard KCModule constructor.
			///  Automatically creates the KPluginSelector widget.
			///          </remarks>		<short>    Standard KCModule constructor.</short>
			public PluginPage(KComponentData componentData, QWidget parent, List<string> args) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("PluginPage##?", "PluginPage(const KComponentData&, QWidget*, const QStringList&)", typeof(void), typeof(KComponentData), componentData, typeof(QWidget), parent, typeof(List<string>), args);
			}
			public PluginPage(KComponentData componentData, QWidget parent) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("PluginPage##", "PluginPage(const KComponentData&, QWidget*)", typeof(void), typeof(KComponentData), componentData, typeof(QWidget), parent);
			}
			public PluginPage(KComponentData componentData) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("PluginPage#", "PluginPage(const KComponentData&)", typeof(void), typeof(KComponentData), componentData);
			}
			/// <remarks>
			/// </remarks>		<return> a reference to the KPluginSelector.
			///          </return>
			/// 		<short>   </short>
			public KPluginSelector PluginSelector() {
				return (KPluginSelector) interceptor.Invoke("pluginSelector", "pluginSelector()", typeof(KPluginSelector));
			}
			/// <remarks>
			///  Load the state of the plugins (selected or not) from the KPluginInfo
			///  objects. For KParts plugins everything should work automatically. For
			///  your own type of plugins you might need to reimplement the
			///  KPluginInfo.PluginLoaded() method. If that doesn't fit your needs
			///  you can also reimplement this method.
			///          </remarks>		<short>    Load the state of the plugins (selected or not) from the KPluginInfo  objects.</short>
			[SmokeMethod("load()")]
			public override void Load() {
				interceptor.Invoke("load", "load()", typeof(void));
			}
			/// <remarks>
			///  Save the state of the plugins to KConfig objects
			///          </remarks>		<short>    Save the state of the plugins to KConfig objects          </short>
			[SmokeMethod("save()")]
			public override void Save() {
				interceptor.Invoke("save", "save()", typeof(void));
			}
			[SmokeMethod("defaults()")]
			public override void Defaults() {
				interceptor.Invoke("defaults", "defaults()", typeof(void));
			}
			~PluginPage() {
				interceptor.Invoke("~PluginPage", "~PluginPage()", typeof(void));
			}
			public new void Dispose() {
				interceptor.Invoke("~PluginPage", "~PluginPage()", typeof(void));
			}
			protected new IPluginPageSignals Emit {
				get { return (IPluginPageSignals) Q_EMIT; }
			}
		}

		public interface IPluginPageSignals : IKCModuleSignals {
		}
	}
}
