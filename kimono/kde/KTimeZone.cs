//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Runtime.InteropServices;
	using System.Collections.Generic;

	/// <remarks>
	///  Base class representing a time zone.
	///  The KTimeZone base class contains general descriptive data about the time zone, and
	///  provides an interface for methods to read and parse time zone definitions, and to
	///  translate between UTC and local time. Derived classes must implement these methods,
	///  and may also hold the actual details of the dates and times of daylight savings
	///  changes, offsets from UTC, etc. They should be tailored to deal with the type and
	///  format of data held by a particular type of time zone database.
	///  If this base class is instantiated, it represents the UTC time zone.
	///  KTimeZone is designed to work in partnership with KTimeZoneSource. KTimeZone
	///  provides access to individual time zones, while classes derived from
	///  KTimeZoneSource read and parse a particular format of time zone definition.
	///  Because time zone sources can differ in what information they provide about time zones,
	///  the parsed data retured by KTimeZoneSource can vary between different sources,
	///  resulting in the need to create different KTimeZone classes to handle the data.
	///  KTimeZone instances are often grouped into KTimeZones collections. If a KTimeZone is
	///  part of such a collection, it is owned by the KTimeZones instance and should not be
	///  deleted.
	/// </remarks>		<author> S.R.Haque <srhaque@iee.org>.
	///  </author>
	/// 		<short> Base class representing a time zone.</short>
	/// 		<see> KTimeZoneSource</see>
	/// 		<see> KTimeZoneData</see>
	/// 		<see> @ingroup</see>
	/// 		<see> timezones</see>

	[SmokeClass("KTimeZone")]
	public class KTimeZone : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KTimeZone(Type dummy) {}


		[SmokeClass("KTimeZone::Phase")]
		public class Phase : Object, IDisposable {
			protected SmokeInvocation interceptor = null;
			private IntPtr smokeObject;
			protected Phase(Type dummy) {}
			protected void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(Phase), this);
			}
			private static SmokeInvocation staticInterceptor = null;
			static Phase() {
				staticInterceptor = new SmokeInvocation(typeof(Phase), null);
			}
			public Phase() : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Phase", "Phase()", typeof(void));
			}
			/// <remarks>
			///  Constructor.
			/// <param> name="utcOffset" number of seconds to add to UTC to get local time in this phase
			/// </param><param> name="abbreviations" time zone abbreviation for this phase. If translations exist,
			///                       concatenate all abbreviations as null-terminated strings.
			/// </param><param> name="dst" true if daylight savings time, false if standard time
			/// </param><param> name="comment" optional comment
			///          </param></remarks>		<short>    Constructor.</short>
			public Phase(int utcOffset, QByteArray abbreviations, bool dst, string comment) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Phase$#$$", "Phase(int, const QByteArray&, bool, const QString&)", typeof(void), typeof(int), utcOffset, typeof(QByteArray), abbreviations, typeof(bool), dst, typeof(string), comment);
			}
			public Phase(int utcOffset, QByteArray abbreviations, bool dst) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Phase$#$", "Phase(int, const QByteArray&, bool)", typeof(void), typeof(int), utcOffset, typeof(QByteArray), abbreviations, typeof(bool), dst);
			}
			/// <remarks>
			///  Constructor.
			/// <param> name="utcOffset" number of seconds to add to UTC to get local time in this phase
			/// </param><param> name="abbreviations" time zone abbreviation for this phase, plus any translations
			/// </param><param> name="dst" true if daylight savings time, false if standard time
			/// </param><param> name="comment" optional comment
			///          </param></remarks>		<short>    Constructor.</short>
			public Phase(int utcOffset, List<QByteArray> abbreviations, bool dst, string comment) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Phase$?$$", "Phase(int, const QList<QByteArray>&, bool, const QString&)", typeof(void), typeof(int), utcOffset, typeof(List<QByteArray>), abbreviations, typeof(bool), dst, typeof(string), comment);
			}
			public Phase(int utcOffset, List<QByteArray> abbreviations, bool dst) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Phase$?$", "Phase(int, const QList<QByteArray>&, bool)", typeof(void), typeof(int), utcOffset, typeof(List<QByteArray>), abbreviations, typeof(bool), dst);
			}
			public Phase(KTimeZone.Phase rhs) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Phase#", "Phase(const KTimeZone::Phase&)", typeof(void), typeof(KTimeZone.Phase), rhs);
			}
			public override bool Equals(object o) {
				if (!(o is Phase)) { return false; }
				return this == (Phase) o;
			}
			public override int GetHashCode() {
				return interceptor.GetHashCode();
			}
			/// <remarks>
			///  Return the UTC offset in seconds during this phase.
			///  The UTC offset is the number of seconds which you must add to UTC
			///  to get local time.
			/// </remarks>		<return> offset in seconds to add to UTC
			///          </return>
			/// 		<short>    Return the UTC offset in seconds during this phase.</short>
			public int UtcOffset() {
				return (int) interceptor.Invoke("utcOffset", "utcOffset() const", typeof(int));
			}
			/// <remarks>
			///  Return the time zone abbreviations which apply to this phase.
			///  More than one abbreviation may be returned, to allow for possible translations.
			/// </remarks>		<return> time zone abbreviations
			///          </return>
			/// 		<short>    Return the time zone abbreviations which apply to this phase.</short>
			public List<QByteArray> Abbreviations() {
				return (List<QByteArray>) interceptor.Invoke("abbreviations", "abbreviations() const", typeof(List<QByteArray>));
			}
			/// <remarks>
			///  Return whether daylight savings time applies during this phase.
			/// </remarks>		<return> true if daylight savings are in operation, false otherwise
			///          </return>
			/// 		<short>    Return whether daylight savings time applies during this phase.</short>
			public bool IsDst() {
				return (bool) interceptor.Invoke("isDst", "isDst() const", typeof(bool));
			}
			/// <remarks>
			///  Return the comment (if any) applying to this phase.
			/// </remarks>		<return> comment
			///          </return>
			/// 		<short>    Return the comment (if any) applying to this phase.</short>
			public string Comment() {
				return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
			}
			~Phase() {
				interceptor.Invoke("~Phase", "~Phase()", typeof(void));
			}
			public void Dispose() {
				interceptor.Invoke("~Phase", "~Phase()", typeof(void));
			}
			public static bool operator==(Phase lhs, KTimeZone.Phase rhs) {
				return (bool) staticInterceptor.Invoke("operator==#", "operator==(const KTimeZone::Phase&) const", typeof(bool), typeof(Phase), lhs, typeof(KTimeZone.Phase), rhs);
			}
			public static bool operator!=(Phase lhs, KTimeZone.Phase rhs) {
				return !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KTimeZone::Phase&) const", typeof(bool), typeof(Phase), lhs, typeof(KTimeZone.Phase), rhs);
			}
		}


		[SmokeClass("KTimeZone::Transition")]
		public class Transition : Object, IDisposable {
			protected SmokeInvocation interceptor = null;
			private IntPtr smokeObject;
			protected Transition(Type dummy) {}
			protected void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(Transition), this);
			}
			private static SmokeInvocation staticInterceptor = null;
			static Transition() {
				staticInterceptor = new SmokeInvocation(typeof(Transition), null);
			}
			// KTimeZone::Transition* Transition(const QDateTime& arg1,const Phase& arg2); >>>> NOT CONVERTED
			// Phase phase(); >>>> NOT CONVERTED
			public Transition() : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Transition", "Transition()", typeof(void));
			}
			public Transition(KTimeZone.Transition t) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Transition#", "Transition(const KTimeZone::Transition&)", typeof(void), typeof(KTimeZone.Transition), t);
			}
			/// <remarks>
			///  Return the UTC time of the transition.
			/// </remarks>		<return> UTC time
			///          </return>
			/// 		<short>    Return the UTC time of the transition.</short>
			public QDateTime Time() {
				return (QDateTime) interceptor.Invoke("time", "time() const", typeof(QDateTime));
			}
			/// <remarks>
			///  Return the time zone phase which takes effect after the transition.
			/// </remarks>		<return> time zone phase
			///          </return>
			/// 		<short>    Return the time zone phase which takes effect after the transition.</short>
			/// <remarks>
			///  Compare the date/time values of two transitions.
			/// <param> name="rhs" other instance
			/// </param></remarks>		<return> @c true if this Transition is earlier than <code>rhs</code>
			///          </return>
			/// 		<short>    Compare the date/time values of two transitions.</short>
			~Transition() {
				interceptor.Invoke("~Transition", "~Transition()", typeof(void));
			}
			public void Dispose() {
				interceptor.Invoke("~Transition", "~Transition()", typeof(void));
			}
			public static bool operator<(Transition lhs, KTimeZone.Transition rhs) {
				return (bool) staticInterceptor.Invoke("operator<#", "operator<(const KTimeZone::Transition&) const", typeof(bool), typeof(Transition), lhs, typeof(KTimeZone.Transition), rhs);
			}
			public static bool operator>(Transition lhs, KTimeZone.Transition rhs) {
				return !(bool) staticInterceptor.Invoke("operator<#", "operator<(const KTimeZone::Transition&) const", typeof(bool), typeof(Transition), lhs, typeof(KTimeZone.Transition), rhs)
							&& !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KTimeZone::Transition&) const", typeof(bool), typeof(Transition), lhs, typeof(KTimeZone.Transition), rhs);
			}
		}


		[SmokeClass("KTimeZone::LeapSeconds")]
		public class LeapSeconds : Object, IDisposable {
			protected SmokeInvocation interceptor = null;
			private IntPtr smokeObject;
			protected LeapSeconds(Type dummy) {}
			protected void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(LeapSeconds), this);
			}
			private static SmokeInvocation staticInterceptor = null;
			static LeapSeconds() {
				staticInterceptor = new SmokeInvocation(typeof(LeapSeconds), null);
			}
			public LeapSeconds() : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("LeapSeconds", "LeapSeconds()", typeof(void));
			}
			public LeapSeconds(QDateTime utcTime, int leapSeconds, string comment) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("LeapSeconds#$$", "LeapSeconds(const QDateTime&, int, const QString&)", typeof(void), typeof(QDateTime), utcTime, typeof(int), leapSeconds, typeof(string), comment);
			}
			public LeapSeconds(QDateTime utcTime, int leapSeconds) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("LeapSeconds#$", "LeapSeconds(const QDateTime&, int)", typeof(void), typeof(QDateTime), utcTime, typeof(int), leapSeconds);
			}
			public LeapSeconds(KTimeZone.LeapSeconds c) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("LeapSeconds#", "LeapSeconds(const KTimeZone::LeapSeconds&)", typeof(void), typeof(KTimeZone.LeapSeconds), c);
			}
			/// <remarks>
			///  Return whether this instance holds valid data.
			/// </remarks>		<return> true if valid, false if invalid
			///          </return>
			/// 		<short>    Return whether this instance holds valid data.</short>
			public bool IsValid() {
				return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
			}
			/// <remarks>
			///  Return the UTC date/time when this change occurred.
			/// </remarks>		<return> date/time
			///          </return>
			/// 		<short>    Return the UTC date/time when this change occurred.</short>
			public QDateTime DateTime() {
				return (QDateTime) interceptor.Invoke("dateTime", "dateTime() const", typeof(QDateTime));
			}
			/// <remarks>
			///  Return the cumulative number of leap seconds to be added after this
			///  change occurs.
			/// </remarks>		<return> number of leap seconds
			///          </return>
			/// 		<short>    Return the cumulative number of leap seconds to be added after this  change occurs.</short>
			public int leapSeconds() {
				return (int) interceptor.Invoke("leapSeconds", "leapSeconds() const", typeof(int));
			}
			/// <remarks>
			///  Return the comment (if any) applying to this change.
			/// </remarks>		<return> comment
			///          </return>
			/// 		<short>    Return the comment (if any) applying to this change.</short>
			public string Comment() {
				return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
			}
			~LeapSeconds() {
				interceptor.Invoke("~LeapSeconds", "~LeapSeconds()", typeof(void));
			}
			public void Dispose() {
				interceptor.Invoke("~LeapSeconds", "~LeapSeconds()", typeof(void));
			}
			public static bool operator<(LeapSeconds lhs, KTimeZone.LeapSeconds c) {
				return (bool) staticInterceptor.Invoke("operator<#", "operator<(const KTimeZone::LeapSeconds&) const", typeof(bool), typeof(LeapSeconds), lhs, typeof(KTimeZone.LeapSeconds), c);
			}
			public static bool operator>(LeapSeconds lhs, KTimeZone.LeapSeconds c) {
				return !(bool) staticInterceptor.Invoke("operator<#", "operator<(const KTimeZone::LeapSeconds&) const", typeof(bool), typeof(LeapSeconds), lhs, typeof(KTimeZone.LeapSeconds), c)
							&& !(bool) staticInterceptor.Invoke("operator==#", "operator==(const KTimeZone::LeapSeconds&) const", typeof(bool), typeof(LeapSeconds), lhs, typeof(KTimeZone.LeapSeconds), c);
			}
		}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KTimeZone), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KTimeZone() {
			staticInterceptor = new SmokeInvocation(typeof(KTimeZone), null);
		}
		public static int InvalidOffset() {
			return (int) staticInterceptor.Invoke("InvalidOffset", "InvalidOffset()", typeof(int));
		}
		public static int InvalidTime_t() {
			return (int) staticInterceptor.Invoke("InvalidTime_t", "InvalidTime_t()", typeof(int));
		}
		public static float UNKNOWN() {
			return (float) staticInterceptor.Invoke("UNKNOWN", "UNKNOWN()", typeof(float));
		}
		// QList<KTimeZone::Phase> phases(); >>>> NOT CONVERTED
		// QList<KTimeZone::Transition> transitions(const QDateTime& arg1,const QDateTime& arg2); >>>> NOT CONVERTED
		// QList<KTimeZone::Transition> transitions(const QDateTime& arg1); >>>> NOT CONVERTED
		// QList<KTimeZone::Transition> transitions(); >>>> NOT CONVERTED
		// const KTimeZone::Transition* transition(const QDateTime& arg1,const KTimeZone::Transition** arg2,bool* arg3); >>>> NOT CONVERTED
		// const KTimeZone::Transition* transition(const QDateTime& arg1,const KTimeZone::Transition** arg2); >>>> NOT CONVERTED
		// QList<QDateTime> transitionTimes(const KTimeZone::Phase& arg1,const QDateTime& arg2,const QDateTime& arg3); >>>> NOT CONVERTED
		// QList<QDateTime> transitionTimes(const KTimeZone::Phase& arg1,const QDateTime& arg2); >>>> NOT CONVERTED
		// QList<QDateTime> transitionTimes(const KTimeZone::Phase& arg1); >>>> NOT CONVERTED
		// QList<KTimeZone::LeapSeconds> leapSecondChanges(); >>>> NOT CONVERTED
		/// <remarks>
		///  Construct a UTC time zone.
		///      </remarks>		<short>    Construct a UTC time zone.</short>
		public KTimeZone(string name) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KTimeZone$", "KTimeZone(const QString&)", typeof(void), typeof(string), name);
		}
		public KTimeZone() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KTimeZone", "KTimeZone()", typeof(void));
		}
		public KTimeZone(KTimeZone arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KTimeZone#", "KTimeZone(const KTimeZone&)", typeof(void), typeof(KTimeZone), arg1);
		}
		/// <remarks>
		///  Returns the name of the time zone.
		///  If it is held in a KTimeZones container, the name is the time zone's unique
		///  identifier within that KTimeZones instance.
		/// </remarks>		<return> name in system-dependent format
		///      </return>
		/// 		<short>    Returns the name of the time zone.</short>
		public string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		/// <remarks>
		///  Returns the two-letter country code of the time zone.
		/// </remarks>		<return> upper case ISO 3166 2-character country code, empty if unknown
		///      </return>
		/// 		<short>    Returns the two-letter country code of the time zone.</short>
		public string CountryCode() {
			return (string) interceptor.Invoke("countryCode", "countryCode() const", typeof(string));
		}
		/// <remarks>
		///  Returns the latitude of the time zone.
		/// </remarks>		<return> latitude in degrees, UNKNOWN if not known
		///      </return>
		/// 		<short>    Returns the latitude of the time zone.</short>
		public float Latitude() {
			return (float) interceptor.Invoke("latitude", "latitude() const", typeof(float));
		}
		/// <remarks>
		///  Returns the latitude of the time zone.
		/// </remarks>		<return> latitude in degrees, UNKNOWN if not known
		///      </return>
		/// 		<short>    Returns the latitude of the time zone.</short>
		public float Longitude() {
			return (float) interceptor.Invoke("longitude", "longitude() const", typeof(float));
		}
		/// <remarks>
		///  Returns any comment for the time zone.
		/// </remarks>		<return> comment, may be empty
		///      </return>
		/// 		<short>    Returns any comment for the time zone.</short>
		public string Comment() {
			return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
		}
		/// <remarks>
		///  Returns the list of time zone abbreviations used by the time zone.
		///  This may include historical ones which are no longer in use or have
		///  been superseded.
		/// </remarks>		<return> list of abbreviations
		/// </return>
		/// 		<short>    Returns the list of time zone abbreviations used by the time zone.</short>
		/// 		<see> abbreviation</see>
		public List<QByteArray> Abbreviations() {
			return (List<QByteArray>) interceptor.Invoke("abbreviations", "abbreviations() const", typeof(List<QByteArray>));
		}
		/// <remarks>
		///  Returns the time zone abbreviation current at a specified time.
		/// <param> name="utcDateTime" UTC date/time. An error occurs if
		///                     <code>utcDateTime.timeSpec</code>() is not Qt.UTC.
		/// </param></remarks>		<return> time zone abbreviation, or empty string if error
		/// </return>
		/// 		<short>    Returns the time zone abbreviation current at a specified time.</short>
		/// 		<see> abbreviations</see>
		public QByteArray Abbreviation(QDateTime utcDateTime) {
			return (QByteArray) interceptor.Invoke("abbreviation#", "abbreviation(const QDateTime&) const", typeof(QByteArray), typeof(QDateTime), utcDateTime);
		}
		/// <remarks>
		///  Returns the complete list of UTC offsets used by the time zone. This may
		///  include historical ones which are no longer in use or have been
		///  superseded.
		///  A UTC offset is the number of seconds which you must add to UTC to get
		///  local time in this time zone.
		///  If due to the nature of the source data for the time zone, compiling a
		///  complete list would require significant processing, an empty list is
		///  returned instead.
		/// </remarks>		<return> sorted list of UTC offsets, or empty list if not readily available.
		///      </return>
		/// 		<short>    Returns the complete list of UTC offsets used by the time zone.</short>
		public List<int> UtcOffsets() {
			return (List<int>) interceptor.Invoke("utcOffsets", "utcOffsets() const", typeof(List<int>));
		}
		/// <remarks>
		///  Converts a date/time, which is interpreted as being local time in this
		///  time zone, into local time in another time zone.
		/// <param> name="newZone" other time zone which the time is to be converted into
		/// </param><param> name="zoneDateTime" local date/time. An error occurs if
		///                      <code>zoneDateTime.timeSpec</code>() is not Qt.LocalTime.
		/// </param></remarks>		<return> converted date/time, or invalid date/time if error
		/// </return>
		/// 		<short>    Converts a date/time, which is interpreted as being local time in this  time zone, into local time in another time zone.</short>
		/// 		<see> toUtc</see>
		/// 		<see> toZoneTime</see>
		public QDateTime Convert(KTimeZone newZone, QDateTime zoneDateTime) {
			return (QDateTime) interceptor.Invoke("convert##", "convert(const KTimeZone*, const QDateTime&) const", typeof(QDateTime), typeof(KTimeZone), newZone, typeof(QDateTime), zoneDateTime);
		}
		/// <remarks>
		///  Converts a date/time, which is interpreted as local time in this time
		///  zone, into UTC.
		///  Because of daylight savings time shifts, the date/time may occur twice. In
		///  such cases, this method returns the UTC time for the first occurrence.
		///  If you need the UTC time of the second occurrence, use offsetAtZoneTime().
		/// <param> name="zoneDateTime" local date/time. An error occurs if
		///                      <code>zoneDateTime.timeSpec</code>() is not Qt.LocalTime.
		/// </param></remarks>		<return> UTC date/time, or invalid date/time if error
		/// </return>
		/// 		<short>    Converts a date/time, which is interpreted as local time in this time  zone, into UTC.</short>
		/// 		<see> toZoneTime</see>
		/// 		<see> convert</see>
		public QDateTime ToUtc(QDateTime zoneDateTime) {
			return (QDateTime) interceptor.Invoke("toUtc#", "toUtc(const QDateTime&) const", typeof(QDateTime), typeof(QDateTime), zoneDateTime);
		}
		/// <remarks>
		///  Converts a UTC date/time into local time in this time zone.
		///  Because of daylight savings time shifts, some local date/time values occur
		///  twice. The <code>secondOccurrence</code> parameter may be used to determine whether
		///  the time returned is the first or second occurrence of that time.
		/// <param> name="utcDateTime" UTC date/time. An error occurs if
		///                     <code>utcDateTime.timeSpec</code>() is not Qt.UTC.
		/// </param><param> name="secondOccurrence" if non-null, returns <code>true</code> if the return value
		///                     is the second occurrence of that time, else <code>false</code>
		/// </param></remarks>		<return> local date/time, or invalid date/time if error
		/// </return>
		/// 		<short>    Converts a UTC date/time into local time in this time zone.</short>
		/// 		<see> toUtc</see>
		/// 		<see> convert</see>
		public QDateTime ToZoneTime(QDateTime utcDateTime, ref bool secondOccurrence) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(utcDateTime);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(utcDateTime);
#endif
			stack[2].s_bool = secondOccurrence;
			interceptor.Invoke("toZoneTime#$", "toZoneTime(const QDateTime&, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			secondOccurrence = stack[2].s_bool;
			object returnValue = ((GCHandle) stack[0].s_class).Target;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[0].s_class);
#else
			((GCHandle) stack[0].s_class).Free();
#endif
			return (QDateTime) returnValue;
		}
		public QDateTime ToZoneTime(QDateTime utcDateTime) {
			return (QDateTime) interceptor.Invoke("toZoneTime#", "toZoneTime(const QDateTime&) const", typeof(QDateTime), typeof(QDateTime), utcDateTime);
		}
		/// <remarks>
		///  Returns the current offset of this time zone to UTC or the local
		///  system time zone. The offset is the number of seconds which you must
		///  add to UTC or the local system time to get local time in this time zone.
		///  Take care if you cache the results of this routine; that would
		///  break if the result were stored across a daylight savings change.
		/// <param> name="basis" Qt.UTC to return the offset to UTC, Qt.LocalTime
		///                   to return the offset to local system time
		/// </param></remarks>		<return> offset in seconds
		/// </return>
		/// 		<short>    Returns the current offset of this time zone to UTC or the local  system time zone.</short>
		/// 		<see> offsetAtZoneTime</see>
		/// 		<see> offsetAtUtc</see>
		public int CurrentOffset(Qt.TimeSpec basis) {
			return (int) interceptor.Invoke("currentOffset$", "currentOffset(Qt::TimeSpec) const", typeof(int), typeof(Qt.TimeSpec), basis);
		}
		public int CurrentOffset() {
			return (int) interceptor.Invoke("currentOffset", "currentOffset() const", typeof(int));
		}
		/// <remarks>
		///  Returns the offset of this time zone to UTC at the given local date/time.
		///  Because of daylight savings time shifts, the date/time may occur twice. Optionally,
		///  the offsets at both occurrences of <code>dateTime</code> are calculated.
		///  The offset is the number of seconds which you must add to UTC to get
		///  local time in this time zone.
		/// <param> name="zoneDateTime" the date/time at which the offset is to be calculated. This
		///                      is interpreted as a local time in this time zone. An error
		///                      occurs if <code>zoneDateTime.timeSpec</code>() is not Qt.LocalTime.
		/// </param><param> name="secondOffset" if non-null, and the <code>zoneDateTime</code> occurs twice, receives the
		///                      UTC offset for the second occurrence. Otherwise, it is set
		///                      the same as the return value.
		/// </param></remarks>		<return> offset in seconds. If <code>zoneDateTime</code> occurs twice, it is the offset at the
		///          first occurrence which is returned. If <code>zoneDateTime</code> does not exist because
		///          of daylight savings time shifts, InvalidOffset is returned. If any other error
		///          occurs, 0 is returned.
		/// </return>
		/// 		<short>    Returns the offset of this time zone to UTC at the given local date/time.</short>
		/// 		<see> offsetAtUtc</see>
		/// 		<see> currentOffset</see>
		[SmokeMethod("offsetAtZoneTime(const QDateTime&, int*) const")]
		public virtual int OffsetAtZoneTime(QDateTime zoneDateTime, ref int secondOffset) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(zoneDateTime);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(zoneDateTime);
#endif
			stack[2].s_int = secondOffset;
			interceptor.Invoke("offsetAtZoneTime#$", "offsetAtZoneTime(const QDateTime&, int*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			secondOffset = stack[2].s_int;
			return stack[0].s_int;
		}
		[SmokeMethod("offsetAtZoneTime(const QDateTime&) const")]
		public virtual int OffsetAtZoneTime(QDateTime zoneDateTime) {
			return (int) interceptor.Invoke("offsetAtZoneTime#", "offsetAtZoneTime(const QDateTime&) const", typeof(int), typeof(QDateTime), zoneDateTime);
		}
		/// <remarks>
		///  Returns the offset of this time zone to UTC at the given UTC date/time.
		///  The offset is the number of seconds which you must add to UTC to get
		///  local time in this time zone.
		///  If a derived class needs to work in terms of time_t (as when accessing the
		///  system time functions, for example), it should override both this method and
		///  offset() so as to implement its offset calculations in offset(), and
		///  reimplement this method simply as
		///  <pre>
		///      offset(toTime_t(utcDateTime));
		///  </pre>
		/// <param> name="utcDateTime" the UTC date/time at which the offset is to be calculated.
		///                     An error occurs if <code>utcDateTime.timeSpec</code>() is not Qt.UTC.
		/// </param></remarks>		<return> offset in seconds, or 0 if error
		/// </return>
		/// 		<short>    Returns the offset of this time zone to UTC at the given UTC date/time.</short>
		/// 		<see> offset</see>
		/// 		<see> offsetAtZoneTime</see>
		/// 		<see> currentOffset</see>
		[SmokeMethod("offsetAtUtc(const QDateTime&) const")]
		public virtual int OffsetAtUtc(QDateTime utcDateTime) {
			return (int) interceptor.Invoke("offsetAtUtc#", "offsetAtUtc(const QDateTime&) const", typeof(int), typeof(QDateTime), utcDateTime);
		}
		/// <remarks>
		///  Returns the offset of this time zone to UTC at a specified UTC time.
		///  The offset is the number of seconds which you must add to UTC to get
		///  local time in this time zone.
		///  Note that time_t has a more limited range than QDateTime, so consider using
		///  offsetAtUtc() instead.
		/// <param> name="t" the UTC time at which the offset is to be calculated, measured in seconds
		///           since 00:00:00 UTC 1st January 1970 (as returned by time(2))
		/// </param></remarks>		<return> offset in seconds, or 0 if error
		/// </return>
		/// 		<short>    Returns the offset of this time zone to UTC at a specified UTC time.</short>
		/// 		<see> offsetAtUtc</see>
		[SmokeMethod("offset(time_t) const")]
		public virtual int Offset(int t) {
			return (int) interceptor.Invoke("offset$", "offset(time_t) const", typeof(int), typeof(int), t);
		}
		/// <remarks>
		///  Returns whether daylight savings time is in operation at the given UTC date/time.
		///  If a derived class needs to work in terms of time_t (as when accessing the
		///  system time functions, for example), it should override both this method and
		///  isDst() so as to implement its offset calculations in isDst(), and reimplement
		///  this method simply as
		///  <pre>
		///      isDst(toTime_t(utcDateTime));
		///  </pre>
		/// <param> name="utcDateTime" the UTC date/time. An error occurs if
		///                     <code>utcDateTime.timeSpec</code>() is not Qt.UTC.
		/// </param></remarks>		<return> @c true if daylight savings time is in operation, @c false otherwise
		/// </return>
		/// 		<short>    Returns whether daylight savings time is in operation at the given UTC date/time.</short>
		/// 		<see> isDst</see>
		[SmokeMethod("isDstAtUtc(const QDateTime&) const")]
		public virtual bool IsDstAtUtc(QDateTime utcDateTime) {
			return (bool) interceptor.Invoke("isDstAtUtc#", "isDstAtUtc(const QDateTime&) const", typeof(bool), typeof(QDateTime), utcDateTime);
		}
		/// <remarks>
		///  Returns whether daylight savings time is in operation at a specified UTC time.
		///  Note that time_t has a more limited range than QDateTime, so consider using
		///  isDstAtUtc() instead.
		/// <param> name="t" the UTC time, measured in seconds since 00:00:00 UTC 1st January 1970
		///           (as returned by time(2))
		/// </param></remarks>		<return> @c true if daylight savings time is in operation, @c false otherwise
		/// </return>
		/// 		<short>    Returns whether daylight savings time is in operation at a specified UTC time.</short>
		/// 		<see> isDstAtUtc</see>
		[SmokeMethod("isDst(time_t) const")]
		public virtual bool IsDst(int t) {
			return (bool) interceptor.Invoke("isDst$", "isDst(time_t) const", typeof(bool), typeof(int), t);
		}
		/// <remarks>
		///  Return all daylight savings time phases for the time zone.
		///  Note that some time zone data sources (such as system time zones accessed
		///  via the system libraries) may not allow a list of daylight savings time
		///  changes to be compiled easily. In such cases, this method will return an
		///  empty list.
		/// </remarks>		<return> list of phases
		///      </return>
		/// 		<short>    Return all daylight savings time phases for the time zone.</short>
		/// <remarks>
		///  Return whether daylight saving transitions are available for the time zone.
		///  The base class returns <code>false.</code>
		/// </remarks>		<return> @c true if transitions are available, @c false if not
		/// </return>
		/// 		<short>    Return whether daylight saving transitions are available for the time zone.</short>
		/// 		<see> transitions</see>
		/// 		<see> transition</see>
		[SmokeMethod("hasTransitions() const")]
		public virtual bool HasTransitions() {
			return (bool) interceptor.Invoke("hasTransitions", "hasTransitions() const", typeof(bool));
		}
		/// <remarks>
		///  Return all daylight saving transitions, in time order. If desired, the
		///  transitions returned may be restricted to a specified time range.
		///  Note that some time zone data sources (such as system time zones accessed
		///  via the system libraries) may not allow a list of daylight saving time
		///  changes to be compiled easily. In such cases, this method will return an
		///  empty list.
		/// <param> name="start" start UTC date/time, or invalid date/time to return all transitions
		///               up to <code>end.</code> <code>start.timeSpec</code>() must be Qt.UTC, else
		///               <code>start</code> will be considered invalid.
		/// </param><param> name="end" end UTC date/time, or invalid date/time for no end. <code>end.timeSpec</code>()
		///                 must be Qt.UTC, else <code>end</code> will be considered invalid.
		/// </param></remarks>		<return> list of transitions, in time order
		/// </return>
		/// 		<short>    Return all daylight saving transitions, in time order.</short>
		/// 		<see> hasTransitions</see>
		/// 		<see> transition</see>
		/// 		<see> transitionTimes</see>
		/// <remarks>
		///  Find the last daylight savings time transition at or before a given
		///  UTC or local time.
		///  Because of daylight savings time shifts, a local time may occur twice or
		///  may not occur at all. In the former case, the transitions at or before
		///  both occurrences of <code>dt</code> may optionally be calculated and returned in
		///  <code>secondTransition.</code> The latter case may optionally be detected by use of
		///  <code>validTime.</code>
		/// <param> name="dt" date/time. <code>dt.timeSpec</code>() may be set to Qt.UTC or Qt.LocalTime.
		/// </param><param> name="secondTransition" if non-null, and the <code>dt</code> occurs twice, receives the
		///                      transition for the second occurrence. Otherwise, it is set
		///                      the same as the return value.
		/// </param><param> name="validTime" if non-null, is set to false if <code>dt</code> does not occur, or
		///                   to true otherwise
		/// </param></remarks>		<return> time zone transition, or null either if <code>dt</code> is either outside the
		///          defined range of the transition data or if <code>dt</code> does not occur
		/// </return>
		/// 		<short>    Find the last daylight savings time transition at or before a given  UTC or local time.</short>
		/// 		<see> transitionIndex</see>
		/// 		<see> hasTransitions</see>
		/// 		<see> transitions</see>
		public KTimeZone.Transition transition(QDateTime dt) {
			return (KTimeZone.Transition) interceptor.Invoke("transition#", "transition(const QDateTime&) const", typeof(KTimeZone.Transition), typeof(QDateTime), dt);
		}
		/// <remarks>
		///  Find the index to the last daylight savings time transition at or before
		///  a given UTC or local time. The return value is the index into the transition
		///  list returned by transitions().
		///  Because of daylight savings time shifts, a local time may occur twice or
		///  may not occur at all. In the former case, the transitions at or before
		///  both occurrences of <code>dt</code> may optionally be calculated and returned in
		///  <code>secondIndex.</code> The latter case may optionally be detected by use of
		///  <code>validTime.</code>
		/// <param> name="dt" date/time. <code>dt.timeSpec</code>() may be set to Qt.UTC or Qt.LocalTime.
		/// </param><param> name="secondIndex" if non-null, and the <code>dt</code> occurs twice, receives the
		///                     index to the transition for the second occurrence. Otherwise,
		///                     it is set the same as the return value.
		/// </param><param> name="validTime" if non-null, is set to false if <code>dt</code> does not occur, or
		///                   to true otherwise
		/// </param></remarks>		<return> index into the time zone transition list, or -1 either if <code>dt</code> is
		///          either outside the defined range of the transition data or if <code>dt</code>
		///          does not occur
		/// </return>
		/// 		<short>    Find the index to the last daylight savings time transition at or before  a given UTC or local time.</short>
		/// 		<see> transition</see>
		/// 		<see> transitions</see>
		/// 		<see> hasTransitions</see>
		public int TransitionIndex(QDateTime dt, ref int secondIndex, ref bool validTime) {
			StackItem[] stack = new StackItem[4];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(dt);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(dt);
#endif
			stack[2].s_int = secondIndex;
			stack[3].s_bool = validTime;
			interceptor.Invoke("transitionIndex#$$", "transitionIndex(const QDateTime&, int*, bool*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			secondIndex = stack[2].s_int;
			validTime = stack[3].s_bool;
			return stack[0].s_int;
		}
		public int TransitionIndex(QDateTime dt, ref int secondIndex) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(dt);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(dt);
#endif
			stack[2].s_int = secondIndex;
			interceptor.Invoke("transitionIndex#$", "transitionIndex(const QDateTime&, int*) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			secondIndex = stack[2].s_int;
			return stack[0].s_int;
		}
		public int TransitionIndex(QDateTime dt) {
			return (int) interceptor.Invoke("transitionIndex#", "transitionIndex(const QDateTime&) const", typeof(int), typeof(QDateTime), dt);
		}
		/// <remarks>
		///  Return the times of all daylight saving transitions to a given time zone
		///  phase, in time order. If desired, the times returned may be restricted to
		///  a specified time range.
		///  Note that some time zone data sources (such as system time zones accessed
		///  via the system libraries) may not allow a list of daylight saving time
		///  changes to be compiled easily. In such cases, this method will return an
		///  empty list.
		/// <param> name="phase" time zone phase
		/// </param><param> name="start" start UTC date/time, or invalid date/time to return all transitions
		///               up to <code>end.</code> <code>start.timeSpec</code>() must be Qt.UTC, else
		///               <code>start</code> will be considered invalid.
		/// </param><param> name="end" end UTC date/time, or invalid date/time for no end. <code>end.timeSpec</code>()
		///                 must be Qt.UTC, else <code>end</code> will be considered invalid.
		/// </param></remarks>		<return> ordered list of transition times
		/// </return>
		/// 		<short>    Return the times of all daylight saving transitions to a given time zone  phase, in time order.</short>
		/// 		<see> hasTransitions</see>
		/// 		<see> transition</see>
		/// 		<see> transitions</see>
		/// <remarks>
		///  Return all leap second adjustments, in time order.
		///  Note that some time zone data sources (such as system time zones accessed
		///  via the system libraries) may not provide information on leap second
		///  adjustments. In such cases, this method will return an empty list.
		/// </remarks>		<return> list of adjustments
		///      </return>
		/// 		<short>    Return all leap second adjustments, in time order.</short>
		/// <remarks>
		///  Returns the source reader/parser for the time zone's source database.
		/// </remarks>		<return> reader/parser
		///      </return>
		/// 		<short>    Returns the source reader/parser for the time zone's source database.</short>
		public KTimeZoneSource Source() {
			return (KTimeZoneSource) interceptor.Invoke("source", "source() const", typeof(KTimeZoneSource));
		}
		/// <remarks>
		///  Extracts time zone detail information for this time zone from the source database.
		/// </remarks>		<return> @c false if the parse encountered errors, @c true otherwise
		///      </return>
		/// 		<short>    Extracts time zone detail information for this time zone from the source database.</short>
		public bool Parse() {
			return (bool) interceptor.Invoke("parse", "parse() const", typeof(bool));
		}
		/// <remarks>
		///  Returns the detailed parsed data for the time zone.
		///  This will return null unless either parse() has been called beforehand, or
		///  <code>create</code> is true.
		/// <param> name="create" true to parse the zone's data first if not already parsed
		/// </param></remarks>		<return> pointer to data, or null if data has not been parsed
		///      </return>
		/// 		<short>    Returns the detailed parsed data for the time zone.</short>
		public KTimeZoneData Data(bool create) {
			return (KTimeZoneData) interceptor.Invoke("data$", "data(bool) const", typeof(KTimeZoneData), typeof(bool), create);
		}
		public KTimeZoneData Data() {
			return (KTimeZoneData) interceptor.Invoke("data", "data() const", typeof(KTimeZoneData));
		}
		/// <remarks>
		///  Constructs a time zone.
		/// <param> name="source" reader/parser for the database containing this time zone. This will
		///                     be an instance of a class derived from KTimeZoneSource.
		/// </param><param> name="name" in system-dependent format. The name must be unique within any
		///                     KTimeZones instance which contains this KTimeZone.
		/// </param><param> name="countryCode" ISO 3166 2-character country code, empty if unknown
		/// </param><param> name="latitude" in degrees (between -90 and +90), UNKNOWN if not known
		/// </param><param> name="longitude" in degrees (between -180 and +180), UNKNOWN if not known
		/// </param><param> name="comment" description of the time zone, if any
		///      </param></remarks>		<short>    Constructs a time zone.</short>
		public KTimeZone(KTimeZoneSource source, string name, string countryCode, float latitude, float longitude, string comment) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KTimeZone#$$$$$", "KTimeZone(KTimeZoneSource*, const QString&, const QString&, float, float, const QString&)", typeof(void), typeof(KTimeZoneSource), source, typeof(string), name, typeof(string), countryCode, typeof(float), latitude, typeof(float), longitude, typeof(string), comment);
		}
		public KTimeZone(KTimeZoneSource source, string name, string countryCode, float latitude, float longitude) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KTimeZone#$$$$", "KTimeZone(KTimeZoneSource*, const QString&, const QString&, float, float)", typeof(void), typeof(KTimeZoneSource), source, typeof(string), name, typeof(string), countryCode, typeof(float), latitude, typeof(float), longitude);
		}
		public KTimeZone(KTimeZoneSource source, string name, string countryCode, float latitude) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KTimeZone#$$$", "KTimeZone(KTimeZoneSource*, const QString&, const QString&, float)", typeof(void), typeof(KTimeZoneSource), source, typeof(string), name, typeof(string), countryCode, typeof(float), latitude);
		}
		public KTimeZone(KTimeZoneSource source, string name, string countryCode) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KTimeZone#$$", "KTimeZone(KTimeZoneSource*, const QString&, const QString&)", typeof(void), typeof(KTimeZoneSource), source, typeof(string), name, typeof(string), countryCode);
		}
		public KTimeZone(KTimeZoneSource source, string name) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KTimeZone#$", "KTimeZone(KTimeZoneSource*, const QString&)", typeof(void), typeof(KTimeZoneSource), source, typeof(string), name);
		}
		/// <remarks>
		///  Sets the detailed parsed data for the time zone.
		/// <param> name="data" parsed data
		/// </param></remarks>		<short>    Sets the detailed parsed data for the time zone.</short>
		/// 		<see> data</see>
		protected void SetData(KTimeZoneData data) {
			interceptor.Invoke("setData#", "setData(KTimeZoneData*)", typeof(void), typeof(KTimeZoneData), data);
		}
		~KTimeZone() {
			interceptor.Invoke("~KTimeZone", "~KTimeZone()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KTimeZone", "~KTimeZone()", typeof(void));
		}
		/// <remarks>
		///  Converts a UTC time, measured in seconds since 00:00:00 UTC 1st January 1970
		///  (as returned by time(2)), to a UTC QDateTime value.
		///  QDateTime.SetTime_t() is limited to handling <code>t</code> >= 0, since its parameter
		///  is unsigned. This method takes a parameter of time_t which is signed.
		/// </remarks>		<return> converted time
		/// </return>
		/// 		<short>    Converts a UTC time, measured in seconds since 00:00:00 UTC 1st January 1970  (as returned by time(2)), to a UTC QDateTime value.</short>
		/// 		<see> toTime_t</see>
		public static QDateTime FromTime_t(int t) {
			return (QDateTime) staticInterceptor.Invoke("fromTime_t$", "fromTime_t(time_t)", typeof(QDateTime), typeof(int), t);
		}
		/// <remarks>
		///  Converts a UTC QDateTime to a UTC time, measured in seconds since 00:00:00 UTC
		///  1st January 1970 (as returned by time(2)).
		///  QDateTime.ToTime_t() returns an unsigned value. This method returns a time_t
		///  value, which is signed.
		/// <param> name="utcDateTime" date/time. An error occurs if <code>utcDateTime.timeSpec</code>() is
		///                     not Qt.UTC.
		/// </param></remarks>		<return> converted time, or -1 if the date is out of range for time_t or
		///          <code>utcDateTime.timeSpec</code>() is not Qt.UTC
		/// </return>
		/// 		<short>    Converts a UTC QDateTime to a UTC time, measured in seconds since 00:00:00 UTC  1st January 1970 (as returned by time(2)).</short>
		/// 		<see> fromTime_t</see>
		public static int ToTime_t(QDateTime utcDateTime) {
			return (int) staticInterceptor.Invoke("toTime_t#", "toTime_t(const QDateTime&)", typeof(int), typeof(QDateTime), utcDateTime);
		}
	}
}
