//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  See <see cref="IKCMultiDialogSignals"></see> for signals emitted by KCMultiDialog
	/// </remarks>		<author> Matthias Elter <elter@kde.org>, Daniel Molkentin <molkentin@kde.org>
	///  </author>
	/// 		<short> A method that offers a KPageDialog containing arbitrary         KControl Modules. </short>

	[SmokeClass("KCMultiDialog")]
	public class KCMultiDialog : KPageDialog, IDisposable {
 		protected KCMultiDialog(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KCMultiDialog), this);
		}
		/// <remarks>
		///  Constructs a new KCMultiDialog
		/// <param> name="parent" The parent widget
		/// </param></remarks>		<short>    Constructs a new KCMultiDialog </short>
		public KCMultiDialog(QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCMultiDialog#", "KCMultiDialog(QWidget*)", typeof(void), typeof(QWidget), parent);
		}
		public KCMultiDialog() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCMultiDialog", "KCMultiDialog()", typeof(void));
		}
		/// <remarks>
		///  Add a module.
		///  The module is added according to its KCModuleInfo.Weight(). The weight determines where in the list
		///  the module will appear. Lighter modules on top, heavier modules at the bottom.
		/// <param> name="module" Specify the name of the module that is to be added
		///                to the list of modules the dialog will show.
		/// </param><param> name="args" The arguments that should be given to the KCModule when its created
		/// </param></remarks>		<return> The @see KPageWidgetItem associated with the new dialog page.
		/// </return>
		/// 		<short>    Add a module.</short>
		public KPageWidgetItem AddModule(string module, List<string> args) {
			return (KPageWidgetItem) interceptor.Invoke("addModule$?", "addModule(const QString&, const QStringList&)", typeof(KPageWidgetItem), typeof(string), module, typeof(List<string>), args);
		}
		public KPageWidgetItem AddModule(string module) {
			return (KPageWidgetItem) interceptor.Invoke("addModule$", "addModule(const QString&)", typeof(KPageWidgetItem), typeof(string), module);
		}
		/// <remarks>
		///  Add a module.
		///  The module is added according to its KCModuleInfo.Weight(). The weight determines where in the list
		///  the module will appear. Lighter modules on top, heavier modules at the bottom.
		/// <param> name="moduleinfo" Pass a KCModuleInfo object which will be
		///                    used for creating the module. It will be added
		///                    to the list of modules the dialog will show.
		/// </param><param> name="parent" The @see KPageWidgetItem that should appear as parents
		///                in the tree view or a 0 pointer if there is no parent.
		/// </param><param> name="args" The arguments that should be given to the KCModule when its created
		/// </param></remarks>		<short>    Add a module.</short>
		public KPageWidgetItem AddModule(KCModuleInfo moduleinfo, KPageWidgetItem parent, List<string> args) {
			return (KPageWidgetItem) interceptor.Invoke("addModule##?", "addModule(const KCModuleInfo&, KPageWidgetItem*, const QStringList&)", typeof(KPageWidgetItem), typeof(KCModuleInfo), moduleinfo, typeof(KPageWidgetItem), parent, typeof(List<string>), args);
		}
		public KPageWidgetItem AddModule(KCModuleInfo moduleinfo, KPageWidgetItem parent) {
			return (KPageWidgetItem) interceptor.Invoke("addModule##", "addModule(const KCModuleInfo&, KPageWidgetItem*)", typeof(KPageWidgetItem), typeof(KCModuleInfo), moduleinfo, typeof(KPageWidgetItem), parent);
		}
		public KPageWidgetItem AddModule(KCModuleInfo moduleinfo) {
			return (KPageWidgetItem) interceptor.Invoke("addModule#", "addModule(const KCModuleInfo&)", typeof(KPageWidgetItem), typeof(KCModuleInfo), moduleinfo);
		}
		/// <remarks>
		///  Removes all modules from the dialog.
		///      </remarks>		<short>    Removes all modules from the dialog.</short>
		public void Clear() {
			interceptor.Invoke("clear", "clear()", typeof(void));
		}
		/// <remarks>
		///  This constructor can be used by subclasses to provide a custom KPageWidget.
		///          </remarks>		<short>    This constructor can be used by subclasses to provide a custom KPageWidget.</short>
		public KCMultiDialog(KPageWidget pageWidget, QWidget parent, uint flags) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCMultiDialog##$", "KCMultiDialog(KPageWidget*, QWidget*, Qt::WFlags)", typeof(void), typeof(KPageWidget), pageWidget, typeof(QWidget), parent, typeof(uint), flags);
		}
		public KCMultiDialog(KPageWidget pageWidget, QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCMultiDialog##", "KCMultiDialog(KPageWidget*, QWidget*)", typeof(void), typeof(KPageWidget), pageWidget, typeof(QWidget), parent);
		}
		/// <remarks>
		///  This slot is called when the user presses the "Default" Button.
		///  You can reimplement it if needed.
		///  @note Make sure you call the original implementation.
		/// </remarks>		<short>    This slot is called when the user presses the "Default" Button.</short>
		[Q_SLOT("void slotDefaultClicked()")]
		protected void SlotDefaultClicked() {
			interceptor.Invoke("slotDefaultClicked", "slotDefaultClicked()", typeof(void));
		}
		/// <remarks>
		///  This slot is called when the user presses the "Reset" Button.
		///  You can reimplement it if needed.
		///  @note Make sure you call the original implementation.
		///      </remarks>		<short>    This slot is called when the user presses the "Reset" Button.</short>
		[Q_SLOT("void slotUser1Clicked()")]
		protected void SlotUser1Clicked() {
			interceptor.Invoke("slotUser1Clicked", "slotUser1Clicked()", typeof(void));
		}
		/// <remarks>
		///  This slot is called when the user presses the "Apply" Button.
		///  You can reimplement it if needed.
		///  @note Make sure you call the original implementation.
		/// </remarks>		<short>    This slot is called when the user presses the "Apply" Button.</short>
		[Q_SLOT("void slotApplyClicked()")]
		protected void SlotApplyClicked() {
			interceptor.Invoke("slotApplyClicked", "slotApplyClicked()", typeof(void));
		}
		/// <remarks>
		///  This slot is called when the user presses the "OK" Button.
		///  You can reimplement it if needed.
		///  @note Make sure you call the original implementation.
		/// </remarks>		<short>    This slot is called when the user presses the "OK" Button.</short>
		[Q_SLOT("void slotOkClicked()")]
		protected void SlotOkClicked() {
			interceptor.Invoke("slotOkClicked", "slotOkClicked()", typeof(void));
		}
		/// <remarks>
		///  This slot is called when the user presses the "Help" Button.
		///  It reads the X-DocPath field of the currently selected KControl
		///  module's .desktop file to find the path to the documentation,
		///  which it then attempts to load.
		///  You can reimplement this slot if needed.
		///  @note Make sure you call the original implementation.
		/// </remarks>		<short>    This slot is called when the user presses the "Help" Button.</short>
		[Q_SLOT("void slotHelpClicked()")]
		protected void SlotHelpClicked() {
			interceptor.Invoke("slotHelpClicked", "slotHelpClicked()", typeof(void));
		}
		~KCMultiDialog() {
			interceptor.Invoke("~KCMultiDialog", "~KCMultiDialog()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KCMultiDialog", "~KCMultiDialog()", typeof(void));
		}
		protected new IKCMultiDialogSignals Emit {
			get { return (IKCMultiDialogSignals) Q_EMIT; }
		}
	}

	public interface IKCMultiDialogSignals : IKPageDialogSignals {
		/// <remarks>
		///  Emitted after all KCModules have been told to save their configuration.
		///  The applyClicked and okClicked signals are emitted before the
		///  configuration is saved.
		///      </remarks>		<short>    Emitted after all KCModules have been told to save their configuration.</short>
		[Q_SIGNAL("void configCommitted()")]
		void ConfigCommitted();
		/// <remarks>
		///  Emitted after the KCModules have been told to save their configuration.
		///  It is emitted once for every instance the KCMs that were changed belong
		///  to.
		///  You can make use of this if you have more than one component in your
		///  application. componentName tells you the instance that has to reload its
		///  configuration.
		///  The applyClicked and okClicked signals are emitted before the
		///  configuration is saved.
		/// <param> name="componentName" The name of the instance that needs to reload its
		///                      configuration.
		///      </param></remarks>		<short>    Emitted after the KCModules have been told to save their configuration.</short>
		[Q_SIGNAL("void configCommitted(const QByteArray&)")]
		void ConfigCommitted(QByteArray componentName);
	}
}
