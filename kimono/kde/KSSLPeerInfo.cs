//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  KDE SSL Peer Data
	///  This class contains data about the peer of an SSL connection.
	/// </remarks>		<author> George Staikos <staikos@kde.org>
	/// </author>
	/// 		<short> KDE SSL Peer Data.</short>
	/// 		<see> KSSL</see>

	[SmokeClass("KSSLPeerInfo")]
	public class KSSLPeerInfo : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KSSLPeerInfo(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KSSLPeerInfo), this);
		}
		/// <remarks>
		///   Get a reference to the peer's certificate
		/// </remarks>		<return> a reference to the peer's certificate
		/// </return>
		/// 		<short>     Get a reference to the peer's certificate </short>
		/// 		<see> KSSLCertificate</see>
		public KSSLCertificate GetPeerCertificate() {
			return (KSSLCertificate) interceptor.Invoke("getPeerCertificate", "getPeerCertificate()", typeof(KSSLCertificate));
		}
		/// <remarks>
		///   Determine if the peer's certificate matches the address set with
		///   setPeerHost().  Note that this is a match in the "https"
		///   sense, taking into account, for instance,  wildcards.
		/// </remarks>		<return> true if it matches
		/// </return>
		/// 		<short>     Determine if the peer's certificate matches the address set with   setPeerHost().</short>
		/// 		<see> setPeerHost</see>
		public bool CertMatchesAddress() {
			return (bool) interceptor.Invoke("certMatchesAddress", "certMatchesAddress()", typeof(bool));
		}
		/// <remarks>
		///   Determine if the given "common name" matches the address set with
		///   setPeerHost().  Note that this is a match in the "https"
		///   sense, taking into account, for instance,  wildcards.
		/// </remarks>		<return> true if it matches
		/// </return>
		/// 		<short>     Determine if the given "common name" matches the address set with   setPeerHost().</short>
		/// 		<see> setPeerHost</see>
		public bool CnMatchesAddress(string cn) {
			return (bool) interceptor.Invoke("cnMatchesAddress$", "cnMatchesAddress(QString)", typeof(bool), typeof(string), cn);
		}
		/// <remarks>
		///   Set the host that we are connected to.  This is generally set by
		///   KSSL, and should be exactly what the user -thinks- he is connected
		///   to.  (for instance, the host name in the url)
		/// <param> name="host" the hostname
		/// 	 </param></remarks>		<short>     Set the host that we are connected to.</short>
		public void SetPeerHost(string host) {
			interceptor.Invoke("setPeerHost$", "setPeerHost(const QString&)", typeof(void), typeof(string), host);
		}
		public void SetPeerHost() {
			interceptor.Invoke("setPeerHost", "setPeerHost()", typeof(void));
		}
		/// <remarks>
		///   Returns the host we are connected to.
		/// 	 </remarks>		<short>     Returns the host we are connected to.</short>
		public string PeerHost() {
			return (string) interceptor.Invoke("peerHost", "peerHost() const", typeof(string));
		}
		/// <remarks>
		///   Clear out the host name.
		/// 	 </remarks>		<short>     Clear out the host name.</short>
		public void Reset() {
			interceptor.Invoke("reset", "reset()", typeof(void));
		}
		public KSSLPeerInfo() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSSLPeerInfo", "KSSLPeerInfo()", typeof(void));
		}
		~KSSLPeerInfo() {
			interceptor.Invoke("~KSSLPeerInfo", "~KSSLPeerInfo()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KSSLPeerInfo", "~KSSLPeerInfo()", typeof(void));
		}
	}
}
