//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;


	[SmokeClass("KConfigBase")]
	public abstract class KConfigBase : Object {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KConfigBase(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KConfigBase), this);
		}
		/// <remarks>
		///  Flags to control write entry
		///      </remarks>		<short>    Flags to control write entry      </short>
		public enum WriteConfigFlag {
			Persistent = 0x01,
			Global = 0x02,
			Localized = 0x04,
			NLS = Localized,
			Normal = Persistent,
		}
		/// <remarks>
		///  Possible return values for getConfigState().
		/// </remarks>		<short>    Possible return values for getConfigState().</short>
		/// 		<see> getConfigState</see>
		public enum ConfigState {
			NoAccess = 0,
			ReadOnly = 1,
			ReadWrite = 2,
		}
		/// <remarks>
		///  Returns true if the specified group is known about.
		/// <param> name="group" The group to search for.
		/// </param></remarks>		<return> true if the group exists.
		///      </return>
		/// 		<short>    Returns true if the specified group is known about.</short>
		public bool HasGroup(string group) {
			return (bool) interceptor.Invoke("hasGroup$", "hasGroup(const QString&) const", typeof(bool), typeof(string), group);
		}
		public bool HasGroup(QByteArray group) {
			return (bool) interceptor.Invoke("hasGroup#", "hasGroup(const QByteArray&) const", typeof(bool), typeof(QByteArray), group);
		}
		/// <remarks>
		///  Returns a list of groups that are known about.
		/// </remarks>		<return> The list of groups.
		/// </return>
		/// 		<short>    Returns a list of groups that are known about.</short>
		[SmokeMethod("groupList() const")]
		public abstract List<string> GroupList();
		public KConfigGroup Group(QByteArray b) {
			return (KConfigGroup) interceptor.Invoke("group#", "group(const QByteArray&)", typeof(KConfigGroup), typeof(QByteArray), b);
		}
		public KConfigGroup Group(string str) {
			return (KConfigGroup) interceptor.Invoke("group$", "group(const QString&)", typeof(KConfigGroup), typeof(string), str);
		}
		/// <remarks>
		///  Mark the config object as "clean," i.e. don't write dirty entries
		///  at destruction time. If <code>bDeep</code> is false, only the global dirty
		///  flag of the KConfig object gets cleared. If you then call
		///  writeEntry() again, the global dirty flag is set again and all
		///  dirty entries will be written at a subsequent sync() call.
		///    </remarks>		<short>    Mark the config object as "clean," i.</short>
		[SmokeMethod("clean()")]
		public abstract void Clean();
		/// <remarks>
		///  Checks whether this configuration object can be modified.
		/// </remarks>		<return> whether changes may be made to this configuration object.
		///    </return>
		/// 		<short>    Checks whether this configuration object can be modified.</short>
		[SmokeMethod("isImmutable() const")]
		public abstract bool IsImmutable();
		/// <remarks>
		///  Returns the state of the app-config object.
		///  Possible return values
		///  are NoAccess (the application-specific config file could not be
		///  opened neither read-write nor read-only), ReadOnly (the
		///  application-specific config file is opened read-only, but not
		///  read-write) and ReadWrite (the application-specific config
		///  file is opened read-write).
		/// </remarks>		<return> the state of the app-config object
		///    </return>
		/// 		<short>    Returns the state of the app-config object.</short>
		/// 		<see> ConfigState</see>
		[SmokeMethod("getConfigState() const")]
		public abstract KConfigBase.ConfigState GetConfigState();
		public void DeleteGroup(QByteArray group, uint flags) {
			interceptor.Invoke("deleteGroup#$", "deleteGroup(const QByteArray&, KConfigBase::WriteConfigFlags)", typeof(void), typeof(QByteArray), group, typeof(uint), flags);
		}
		public void DeleteGroup(QByteArray group) {
			interceptor.Invoke("deleteGroup#", "deleteGroup(const QByteArray&)", typeof(void), typeof(QByteArray), group);
		}
		public void DeleteGroup(string group, uint flags) {
			interceptor.Invoke("deleteGroup$$", "deleteGroup(const QString&, KConfigBase::WriteConfigFlags)", typeof(void), typeof(string), group, typeof(uint), flags);
		}
		public void DeleteGroup(string group) {
			interceptor.Invoke("deleteGroup$", "deleteGroup(const QString&)", typeof(void), typeof(string), group);
		}
		public bool GroupIsImmutable(QByteArray aGroup) {
			return (bool) interceptor.Invoke("groupIsImmutable#", "groupIsImmutable(const QByteArray&) const", typeof(bool), typeof(QByteArray), aGroup);
		}
		public bool GroupIsImmutable(string aGroup) {
			return (bool) interceptor.Invoke("groupIsImmutable$", "groupIsImmutable(const QString&) const", typeof(bool), typeof(string), aGroup);
		}
		[SmokeMethod("sync()")]
		public abstract void Sync();
		public KConfigBase() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfigBase", "KConfigBase()", typeof(void));
		}
		[SmokeMethod("hasGroupImpl(const QByteArray&) const")]
		protected abstract bool HasGroupImpl(QByteArray group);
		[SmokeMethod("groupImpl(const QByteArray&)")]
		protected abstract KConfigGroup GroupImpl(QByteArray b);
		[SmokeMethod("deleteGroupImpl(const QByteArray&, KConfigBase::WriteConfigFlags)")]
		protected abstract void DeleteGroupImpl(QByteArray group, uint flags);
		[SmokeMethod("groupIsImmutableImpl(const QByteArray&) const")]
		protected abstract bool GroupIsImmutableImpl(QByteArray aGroup);
	}
}
