//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  This dialog only works if your application uses the XML UI
	///  framework for creating menus and toolbars.  It depends on the XML
	///  files to describe the toolbar layouts and it requires the actions
	///  to determine which buttons are active.
	///  Typically, you would include the KStdAction.ConfigureToolBars()
	///  standard action in your application.  In your slot to this action,
	///  you would have something like so:
	///  <pre>
	///  KEditToolBar dlg(actionCollection());
	///  if (dlg.exec())
	///  {
	///    createGUI();
	///  }
	///  </pre>
	///  That code snippet also takes care of redrawing the menu and
	///  toolbars if you have made any changes.
	///  If you are using KMainWindow's settings methods (either save/apply manually
	///  or autoSaveSettings), you should write something like:
	///  <pre>
	///  void MyClass.SlotConfigureToolBars()
	///  {
	///    saveMainWindowSettings( KGlobal.Config(), "MainWindow" );
	///    KEditToolBar dlg(actionCollection());
	///    connect(&dlg,SIGNAL("newToolBarConfig()"),this,SLOT("slotNewToolBarConfig()"));
	///    dlg.exec();
	///  }
	///  void MyClass.SlotNewToolBarConfig() // This is called when OK, Apply or Defaults is clicked
	///  {
	///     ...if you use any action list, use plugActionList on each here...
	///     createGUI();
	///     applyMainWindowSettings( KGlobal.Config(), "MainWindow" );
	///  }
	///  </pre>
	///  Note that the procedure is a bit different for KParts applications.
	///  In this case, you need only pass along a pointer to your
	///  application's KXMLGUIFactory object.  The editor will take care of
	///  finding all of the action collections and XML files.  The editor
	///  aims to be semi-intelligent about where it assigns any
	///  modifications.  In other words, it will not write out part specific
	///  changes to your shell's XML file.
	///  An example would be:
	///  <pre>
	///  saveMainWindowSettings( KGlobal.Config(), "MainWindow" );
	///  KEditToolBar dlg(factory());
	///  connect(&dlg,SIGNAL("newToolBarConfig()"),this,SLOT("slotNewToolBarConfig()"));
	///  dlg.exec();
	///  void MyClass.SlotNewToolBarConfig() // This is called when OK, Apply or Defaults is clicked
	///  {
	///     ...if you use any action list, use plugActionList on each here...
	///     // Do NOT call createGUI()!
	///     applyMainWindowSettings( KGlobal.Config(), "MainWindow" );
	///  }
	///  </pre>
	///  See <see cref="IKEditToolBarSignals"></see> for signals emitted by KEditToolBar
	/// </remarks>		<author> Kurt Granroth <granroth@kde.org>
	///  </author>
	/// 		<short> A dialog used to customize or configure toolbars. </short>

	[SmokeClass("KEditToolBar")]
	public class KEditToolBar : KDialog, IDisposable {
 		protected KEditToolBar(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KEditToolBar), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KEditToolBar() {
			staticInterceptor = new SmokeInvocation(typeof(KEditToolBar), null);
		}
		/// <remarks>
		///  Constructor for apps that do not use components.
		///  This is the
		///  only entry point to this class.  You <b>must</b> pass along your
		///  collection of actions (some of which appear in your toolbars).
		///  The other two parameters are optional.
		/// <param> name="collection" The collection of actions to work on.
		/// </param><param> name="defaultToolBar" The toolbar with this name will appear for editing.
		///                        Pass in string() for the default behaviour,
		///                        generallyd desired for apps that do not use
		///                        components.
		/// </param><param> name="parent" The parent of the dialog.
		///    </param></remarks>		<short>    Constructor for apps that do not use components.</short>
		public KEditToolBar(KActionCollection collection, QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KEditToolBar##", "KEditToolBar(KActionCollection*, QWidget*)", typeof(void), typeof(KActionCollection), collection, typeof(QWidget), parent);
		}
		public KEditToolBar(KActionCollection collection) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KEditToolBar#", "KEditToolBar(KActionCollection*)", typeof(void), typeof(KActionCollection), collection);
		}
		/// <remarks>
		///  Constructor for KParts based apps.
		///  The main parameter, factory(), is a pointer to the
		///  XML GUI factory object for your application.  It contains a list
		///  of all of the GUI clients (along with the action collections and
		///  xml files) and the toolbar editor uses that.
		///  Use this like so:
		///  <pre>
		///  KEditToolBar edit(factory());
		///  if ( edit.exec() )
		///  ...
		///  </pre>
		/// <param> name="factory" Your application's factory object
		/// </param><param> name="defaultToolBar" The toolbar with this name will appear for editing.
		///                        Pass in string() for default behavior.
		/// </param><param> name="parent" The usual parent for the dialog.
		///    </param></remarks>		<short>    Constructor for KParts based apps.</short>
		public KEditToolBar(KXMLGUIFactory factory, QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KEditToolBar##", "KEditToolBar(KXMLGUIFactory*, QWidget*)", typeof(void), typeof(KXMLGUIFactory), factory, typeof(QWidget), parent);
		}
		public KEditToolBar(KXMLGUIFactory factory) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KEditToolBar#", "KEditToolBar(KXMLGUIFactory*)", typeof(void), typeof(KXMLGUIFactory), factory);
		}
		/// <remarks>
		///  Sets the default toolbar that will be selected when the dialog is shown.
		///  If not set, or string() is passed in, the global default tool bar name
		///  will be used.
		/// <param> name="toolBarName" the name of the tool bar
		/// </param></remarks>		<short>    Sets the default toolbar that will be selected when the dialog is shown.</short>
		/// 		<see> setGlobalDefaultToolBar</see>
		public void SetDefaultToolBar(string toolBarName) {
			interceptor.Invoke("setDefaultToolBar$", "setDefaultToolBar(const QString&)", typeof(void), typeof(string), toolBarName);
		}
		/// <remarks>
		///  The name (absolute or relative) of your application's UI resource file
		///  is assumed to be share/apps/appname/appnameui.rc though this can be
		///  overridden by calling this method.
		///  The global parameter controls whether or not the
		///  global resource file is used.  If this is <code>true</code>, then you may
		///  edit all of the actions in your toolbars -- global ones and
		///  local one.  If it is <code>false</code>, then you may edit only your
		///  application's entries.  The only time you should set this to
		///  false is if your application does not use the global resource
		///  file at all (very rare).
		/// <param> name="xmlfile" The application's local resource file.
		/// </param><param> name="global" If <code>true</code>, then the global resource file will also
		///                be parsed.
		///    </param></remarks>		<short>    The name (absolute or relative) of your application's UI resource file  is assumed to be share/apps/appname/appnameui.</short>
		public void SetResourceFile(string file, bool global) {
			interceptor.Invoke("setResourceFile$$", "setResourceFile(const QString&, bool)", typeof(void), typeof(string), file, typeof(bool), global);
		}
		public void SetResourceFile(string file) {
			interceptor.Invoke("setResourceFile$", "setResourceFile(const QString&)", typeof(void), typeof(string), file);
		}
		[SmokeMethod("showEvent(QShowEvent*)")]
		protected override void ShowEvent(QShowEvent arg1) {
			interceptor.Invoke("showEvent#", "showEvent(QShowEvent*)", typeof(void), typeof(QShowEvent), arg1);
		}
		[SmokeMethod("hideEvent(QHideEvent*)")]
		protected override void HideEvent(QHideEvent arg1) {
			interceptor.Invoke("hideEvent#", "hideEvent(QHideEvent*)", typeof(void), typeof(QHideEvent), arg1);
		}
		/// <remarks>
		///  Overridden in order to save any changes made to the toolbars
		///    </remarks>		<short>    Overridden in order to save any changes made to the toolbars    </short>
		[Q_SLOT("void slotOk()")]
		[SmokeMethod("slotOk()")]
		protected virtual void SlotOk() {
			interceptor.Invoke("slotOk", "slotOk()", typeof(void));
		}
		/// <remarks>
		///  idem
		///    </remarks>		<short>    idem    </short>
		[Q_SLOT("void slotApply()")]
		[SmokeMethod("slotApply()")]
		protected virtual void SlotApply() {
			interceptor.Invoke("slotApply", "slotApply()", typeof(void));
		}
		/// <remarks> should OK really save?
		/// </remarks>		<short>   should OK really save? </short>
		[Q_SLOT("void acceptOK(bool)")]
		protected void AcceptOK(bool b) {
			interceptor.Invoke("acceptOK$", "acceptOK(bool)", typeof(void), typeof(bool), b);
		}
		/// <remarks>
		///  Set toolbars to default value
		/// </remarks>		<short>    Set toolbars to default value </short>
		[Q_SLOT("void slotDefault()")]
		protected void SlotDefault() {
			interceptor.Invoke("slotDefault", "slotDefault()", typeof(void));
		}
		~KEditToolBar() {
			interceptor.Invoke("~KEditToolBar", "~KEditToolBar()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KEditToolBar", "~KEditToolBar()", typeof(void));
		}
		/// <remarks>
		///  Sets the default toolbar which will be auto-selected for all
		///  KEditToolBar instances. Can be overridden on a per-dialog basis
		///  by calling setDefaultToolBar( string ) on the dialog.
		/// <param> name="toolbarName" the name of the tool bar
		///    </param></remarks>		<short>    Sets the default toolbar which will be auto-selected for all  KEditToolBar instances.</short>
		public static void SetGlobalDefaultToolBar(string toolBarName) {
			staticInterceptor.Invoke("setGlobalDefaultToolBar$", "setGlobalDefaultToolBar(const char*)", typeof(void), typeof(string), toolBarName);
		}
		protected new IKEditToolBarSignals Emit {
			get { return (IKEditToolBarSignals) Q_EMIT; }
		}
	}

	public interface IKEditToolBarSignals : IKDialogSignals {
		/// <remarks>
		///  Signal emitted when 'apply' or 'ok' is clicked or toolbars were reset.
		///  Connect to it, to plug action lists and to call applyMainWindowSettings
		///  (see sample code in this class's documentation)
		///    </remarks>		<short>    Signal emitted when 'apply' or 'ok' is clicked or toolbars were reset.</short>
		[Q_SIGNAL("void newToolBarConfig()")]
		void NewToolBarConfig();
		[Q_SIGNAL("void newToolbarConfig()")]
		void NewToolbarConfig();
	}
}
