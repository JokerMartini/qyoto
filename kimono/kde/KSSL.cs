//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  KDE SSL Wrapper Class
	///  This class implements KDE's SSL support by wrapping OpenSSL.
	/// </remarks>		<author> George Staikos <staikos@kde.org>
	/// </author>
	/// 		<short> KDE SSL Class.</short>
	/// 		<see> KExtendedSocket</see>
	/// 		<see> TCPSlaveBase</see>

	[SmokeClass("KSSL")]
	public class KSSL : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KSSL(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KSSL), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KSSL() {
			staticInterceptor = new SmokeInvocation(typeof(KSSL), null);
		}
		/// <remarks>
		///   Construct a KSSL object
		/// <param> name="init" Set this to false if you do not want this class to
		///          immediately initialize OpenSSL.
		/// 	 </param></remarks>		<short>     Construct a KSSL object </short>
		public KSSL(bool init) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSSL$", "KSSL(bool)", typeof(void), typeof(bool), init);
		}
		public KSSL() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSSL", "KSSL()", typeof(void));
		}
		/// <remarks>
		///   Initialize OpenSSL.
		///   This will do nothing if it is already initialized.
		/// </remarks>		<return> true on success
		/// </return>
		/// 		<short>     Initialize OpenSSL.</short>
		/// 		<see> reInitialize</see>
		public bool Initialize() {
			return (bool) interceptor.Invoke("initialize", "initialize()", typeof(bool));
		}
		/// <remarks>
		///   This is used for applicationss which do STARTTLS or something
		///   similar. It creates a TLS method regardless of the user's settings.
		/// </remarks>		<return> true if TLS is successfully initialized
		/// 	 </return>
		/// 		<short>     This is used for applicationss which do STARTTLS or something   similar.</short>
		public bool TLSInit() {
			return (bool) interceptor.Invoke("TLSInit", "TLSInit()", typeof(bool));
		}
		/// <remarks>
		///   Set an SSL session to use.  This deep copies the session so it
		///   doesn't have to remain valid.  You need to call it after calling
		///   initialize or reInitialize.  The ID is cleared in close().
		/// <param> name="session" A valid session to reuse.  If null, it will clear the
		///                  session ID in memory.
		/// </param></remarks>		<return> true on success
		/// 	 </return>
		/// 		<short>     Set an SSL session to use.</short>
		public bool SetSession(KSSLSession session) {
			return (bool) interceptor.Invoke("setSession#", "setSession(const KSSLSession*)", typeof(bool), typeof(KSSLSession), session);
		}
		/// <remarks>
		///   Close the SSL session.
		/// 	 </remarks>		<short>     Close the SSL session.</short>
		public void Close() {
			interceptor.Invoke("close", "close()", typeof(void));
		}
		/// <remarks>
		///   Reinitialize OpenSSL.
		///   This is not generally needed unless you are reusing the KSSL object
		///   for a new session.
		/// </remarks>		<return> true on success
		/// </return>
		/// 		<short>     Reinitialize OpenSSL.</short>
		/// 		<see> initialize</see>
		public bool ReInitialize() {
			return (bool) interceptor.Invoke("reInitialize", "reInitialize()", typeof(bool));
		}
		/// <remarks>
		///   Trigger a reread of KSSL configuration and reInitialize() KSSL.
		///   If you setAutoReconfig() to false, then this will simply
		///  reInitialize() and not read in the new configuration.
		/// </remarks>		<return> true on successful reinitalizations
		/// </return>
		/// 		<short>     Trigger a reread of KSSL configuration and reInitialize() KSSL.</short>
		/// 		<see> setAutoReconfig</see>
		public bool Reconfig() {
			return (bool) interceptor.Invoke("reconfig", "reconfig()", typeof(bool));
		}
		/// <remarks>
		///   Enable or disable automatic reconfiguration on initialize().
		/// <param> name="ar" Set to false in order to disable auto-reloading of the
		///          KSSL configuration during initialize().
		/// </param>  By default, KSSL will read its configuration on initialize().  You
		///   might want to disable this for performance reasons.
		/// 	 </remarks>		<short>     Enable or disable automatic reconfiguration on initialize().</short>
		public void SetAutoReconfig(bool ar) {
			interceptor.Invoke("setAutoReconfig$", "setAutoReconfig(bool)", typeof(void), typeof(bool), ar);
		}
		/// <remarks>
		///   This will reseed the pseudo-random number generator with the EGD
		///   (entropy gathering daemon) if the EGD is configured and enabled.
		///   You don't need to call this yourself normally.
		/// </remarks>		<return> 0 on success
		/// 	 </return>
		/// 		<short>     This will reseed the pseudo-random number generator with the EGD   (entropy gathering daemon) if the EGD is configured and enabled.</short>
		public int SeedWithEGD() {
			return (int) interceptor.Invoke("seedWithEGD", "seedWithEGD()", typeof(int));
		}
		/// <remarks>
		///   Set a new KSSLSettings instance as the settings. This deletes the
		///   current instance of KSSLSettings.
		/// <param> name="settings" A new, valid settings object.
		/// </param></remarks>		<return> true on success
		/// 	 </return>
		/// 		<short>     Set a new KSSLSettings instance as the settings.</short>
		public bool SetSettings(KSSLSettings settings) {
			return (bool) interceptor.Invoke("setSettings#", "setSettings(KSSLSettings*)", typeof(bool), typeof(KSSLSettings), settings);
		}
		/// <remarks>
		///   One is built by the constructor, so this will only return a NULL
		///   pointer if you set one with setSettings().
		/// </remarks>		<return> the current settings instance
		/// 	 </return>
		/// 		<short>     One is built by the constructor, so this will only return a NULL   pointer if you set one with setSettings().</short>
		public KSSLSettings Settings() {
			return (KSSLSettings) interceptor.Invoke("settings", "settings()", typeof(KSSLSettings));
		}
		/// <remarks>
		///   Use this to set the certificate to send to the server.
		///   Do NOT delete the KSSLPKCS12 object until you are done with the
		///   session. It is not defined when KSSL will be done with this.
		/// <param> name="pkcs" the valid PKCS#12 object to send.
		/// </param></remarks>		<return> true if the certificate was properly set to the session.
		/// 	 </return>
		/// 		<short>     Use this to set the certificate to send to the server.</short>
		public bool SetClientCertificate(KSSLPKCS12 pkcs) {
			return (bool) interceptor.Invoke("setClientCertificate#", "setClientCertificate(KSSLPKCS12*)", typeof(bool), typeof(KSSLPKCS12), pkcs);
		}
		/// <remarks>
		///   Set the peer hostname to be used for certificate verification.
		/// <param> name="realHost" the remote hostname as the user believes to be
		///          connecting to
		/// 	 </param></remarks>		<short>     Set the peer hostname to be used for certificate verification.</short>
		public void SetPeerHost(string realHost) {
			interceptor.Invoke("setPeerHost$", "setPeerHost(const QString&)", typeof(void), typeof(string), realHost);
		}
		public void SetPeerHost() {
			interceptor.Invoke("setPeerHost", "setPeerHost()", typeof(void));
		}
		/// <remarks>
		///   Connect the SSL session to the remote host using the provided
		///   socket descriptor.
		/// <param> name="sock" the socket descriptor to connect with.  This must be
		///          an already connected socket.
		/// </param></remarks>		<return> 1 on success, 0 on error setting the file descriptor,
		///           -1 on other error.
		/// 	 </return>
		/// 		<short>     Connect the SSL session to the remote host using the provided   socket descriptor.</short>
		public int Connect(int sock) {
			return (int) interceptor.Invoke("connect$", "connect(int)", typeof(int), typeof(int), sock);
		}
		public int Connect(QIODevice sock) {
			return (int) interceptor.Invoke("connect#", "connect(QIODevice*)", typeof(int), typeof(QIODevice), sock);
		}
		/// <remarks>
		///   Connect the SSL session to the remote host using the provided
		///   socket descriptor.  This is for use with an SSL server application.
		/// <param> name="sock" the socket descriptor to connect with.  This must be
		///          an already connected socket.
		/// </param></remarks>		<return> 1 on success, 0 on error setting the file descriptor,
		///           -1 on other error.
		/// 	 </return>
		/// 		<short>     Connect the SSL session to the remote host using the provided   socket descriptor.</short>
		public int Accept(int sock) {
			return (int) interceptor.Invoke("accept$", "accept(int)", typeof(int), typeof(int), sock);
		}
		public int Accept(QIODevice sock) {
			return (int) interceptor.Invoke("accept#", "accept(QIODevice*)", typeof(int), typeof(QIODevice), sock);
		}
		/// <remarks>
		///   Read data from the remote host via SSL.
		/// <param> name="buf" the buffer to read the data into.
		/// </param><param> name="len" the maximum length of data to read.
		/// </param></remarks>		<return> the number of bytes read, 0 on an exception, or -1 on error.
		/// 	 </return>
		/// 		<short>     Read data from the remote host via SSL.</short>
		public int Read(string buf, int len) {
			return (int) interceptor.Invoke("read$$", "read(char*, int)", typeof(int), typeof(string), buf, typeof(int), len);
		}
		/// <remarks>
		///   Peek at available data from the remote host via SSL.
		/// <param> name="buf" the buffer to read the data into.
		/// </param><param> name="len" the maximum length of data to read.
		/// </param></remarks>		<return> the number of bytes read, 0 on an exception, or -1 on error.
		/// 	 </return>
		/// 		<short>     Peek at available data from the remote host via SSL.</short>
		public int Peek(string buf, int len) {
			return (int) interceptor.Invoke("peek$$", "peek(char*, int)", typeof(int), typeof(string), buf, typeof(int), len);
		}
		/// <remarks>
		///   Write data to the remote host via SSL.
		/// <param> name="buf" the buffer to read the data from.
		/// </param><param> name="len" the length of data to send from the buffer.
		/// </param></remarks>		<return> the number of bytes written, 0 on an exception,
		///           or -1 on error.
		/// 	 </return>
		/// 		<short>     Write data to the remote host via SSL.</short>
		public int Write(string buf, int len) {
			return (int) interceptor.Invoke("write$$", "write(const char*, int)", typeof(int), typeof(string), buf, typeof(int), len);
		}
		/// <remarks>
		///   Determine if data is waiting to be read.
		/// </remarks>		<return> -1 on error, 0 if no data is waiting, > 0 if data is waiting.
		/// 	 </return>
		/// 		<short>     Determine if data is waiting to be read.</short>
		public int Pending() {
			return (int) interceptor.Invoke("pending", "pending()", typeof(int));
		}
		/// <remarks>
		///   Obtain a reference to the connection information.
		/// </remarks>		<return> a reference to the connection information,
		///           valid after connected
		/// </return>
		/// 		<short>     Obtain a reference to the connection information.</short>
		/// 		<see> KSSLConnectionInfo</see>
		public KSSLConnectionInfo ConnectionInfo() {
			return (KSSLConnectionInfo) interceptor.Invoke("connectionInfo", "connectionInfo()", typeof(KSSLConnectionInfo));
		}
		/// <remarks>
		///   Obtain a reference to the information about the peer.
		/// </remarks>		<return> a reference to the peer information,
		///           valid after connected
		/// </return>
		/// 		<short>     Obtain a reference to the information about the peer.</short>
		/// 		<see> KSSLPeerInfo</see>
		public KSSLPeerInfo PeerInfo() {
			return (KSSLPeerInfo) interceptor.Invoke("peerInfo", "peerInfo()", typeof(KSSLPeerInfo));
		}
		/// <remarks>
		///   Obtain a pointer to the session information.
		/// </remarks>		<return> a pointer to the session information.
		///           This is valid after connected, while connected.
		///           It is deleted by the KSSL object which returns it.
		///           May return 0L if no valid session exists.
		/// </return>
		/// 		<short>     Obtain a pointer to the session information.</short>
		/// 		<see> KSSLSession</see>
		public KSSLSession Session() {
			return (KSSLSession) interceptor.Invoke("session", "session() const", typeof(KSSLSession));
		}
		/// <remarks>
		///   Determine if we are currently reusing an SSL session ID.
		/// </remarks>		<return> true if we are reusing a session ID.
		/// 	 </return>
		/// 		<short>     Determine if we are currently reusing an SSL session ID.</short>
		public bool ReusingSession() {
			return (bool) interceptor.Invoke("reusingSession", "reusingSession() const", typeof(bool));
		}
		~KSSL() {
			interceptor.Invoke("~KSSL", "~KSSL()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KSSL", "~KSSL()", typeof(void));
		}
		/// <remarks>
		///   Determine if SSL is available and works.
		/// </remarks>		<return> true is SSL is available and usable
		/// 	 </return>
		/// 		<short>     Determine if SSL is available and works.</short>
		public static bool DoesSSLWork() {
			return (bool) staticInterceptor.Invoke("doesSSLWork", "doesSSLWork()", typeof(bool));
		}
	}
}
