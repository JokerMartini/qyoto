//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks> See <see cref="IKFileFilterComboSignals"></see> for signals emitted by KFileFilterCombo
	/// </remarks>

	[SmokeClass("KFileFilterCombo")]
	public class KFileFilterCombo : KComboBox, IDisposable {
 		protected KFileFilterCombo(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KFileFilterCombo), this);
		}
		/// <remarks>
		///  Creates a new filter combo box.
		/// <param> name="parent" The parent widget.
		///      </param></remarks>		<short>    Creates a new filter combo box.</short>
		public KFileFilterCombo(QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KFileFilterCombo#", "KFileFilterCombo(QWidget*)", typeof(void), typeof(QWidget), parent);
		}
		public KFileFilterCombo() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KFileFilterCombo", "KFileFilterCombo()", typeof(void));
		}
		/// <remarks>
		///  Sets the <code>filter</code> string.
		///      </remarks>		<short>    Sets the <code>filter</code> string.</short>
		public void SetFilter(string filter) {
			interceptor.Invoke("setFilter$", "setFilter(const QString&)", typeof(void), typeof(string), filter);
		}
		/// <remarks>
		/// </remarks>		<return> the current filter, either something like "*.cpp *.h"
		///  or the current mimetype, like "text/html", or a list of those, like
		///      " "text/html text/plain image/png", all separated with one space.
		///      </return>
		/// 		<short>   </short>
		public string CurrentFilter() {
			return (string) interceptor.Invoke("currentFilter", "currentFilter() const", typeof(string));
		}
		/// <remarks>
		///  Sets the current filter. Filter must match one of the filter items
		///  passed before to this widget.
		///      </remarks>		<short>    Sets the current filter.</short>
		public void SetCurrentFilter(string filter) {
			interceptor.Invoke("setCurrentFilter$", "setCurrentFilter(const QString&)", typeof(void), typeof(string), filter);
		}
		/// <remarks>
		///  Sets a list of mimetypes.
		///  If <code>defaultType</code> is set, it will be set as the current item.
		///  Otherwise, a first item showing all the mimetypes will be created.
		///      </remarks>		<short>    Sets a list of mimetypes.</short>
		public void SetMimeFilter(List<string> types, string defaultType) {
			interceptor.Invoke("setMimeFilter?$", "setMimeFilter(const QStringList&, const QString&)", typeof(void), typeof(List<string>), types, typeof(string), defaultType);
		}
		/// <remarks>
		/// </remarks>		<return> true if the filter's first item is the list of all mimetypes
		///      </return>
		/// 		<short>   </short>
		public bool ShowsAllTypes() {
			return (bool) interceptor.Invoke("showsAllTypes", "showsAllTypes() const", typeof(bool));
		}
		/// <remarks>
		///  This method allows you to set a default-filter, that is used when an
		///  empty filter is set. Make sure you call this before calling
		///  setFilter().
		///  By default, this is set to i18n("*|All Files")
		/// </remarks>		<short>    This method allows you to set a default-filter, that is used when an  empty filter is set.</short>
		/// 		<see> defaultFilter</see>
		public void SetDefaultFilter(string filter) {
			interceptor.Invoke("setDefaultFilter$", "setDefaultFilter(const QString&)", typeof(void), typeof(string), filter);
		}
		/// <remarks>
		/// </remarks>		<return> the default filter, used when an empty filter is set.
		/// </return>
		/// 		<short>   </short>
		/// 		<see> setDefaultFilter</see>
		public string DefaultFilter() {
			return (string) interceptor.Invoke("defaultFilter", "defaultFilter() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> all filters (this can be a list of patterns or a list of mimetypes)
		///      </return>
		/// 		<short>   </short>
		public List<string> Filters() {
			return (List<string>) interceptor.Invoke("filters", "filters() const", typeof(List<string>));
		}
		[SmokeMethod("eventFilter(QObject*, QEvent*)")]
		protected new virtual bool EventFilter(QObject arg1, QEvent arg2) {
			return (bool) interceptor.Invoke("eventFilter##", "eventFilter(QObject*, QEvent*)", typeof(bool), typeof(QObject), arg1, typeof(QEvent), arg2);
		}
		~KFileFilterCombo() {
			interceptor.Invoke("~KFileFilterCombo", "~KFileFilterCombo()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KFileFilterCombo", "~KFileFilterCombo()", typeof(void));
		}
		protected new IKFileFilterComboSignals Emit {
			get { return (IKFileFilterComboSignals) Q_EMIT; }
		}
	}

	public interface IKFileFilterComboSignals : IKComboBoxSignals {
		/// <remarks>
		///  This signal is emitted whenever the filter has been changed.
		///      </remarks>		<short>    This signal is emitted whenever the filter has been changed.</short>
		[Q_SIGNAL("void filterChanged()")]
		void FilterChanged();
	}
}
