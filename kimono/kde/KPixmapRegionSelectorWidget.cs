//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  KPixmapRegionSelectorWidget is a widget that shows a picture and provides the
	///  user with a friendly way to select a rectangular subregion of the pixmap.
	///  NOTE: There are two copies of this .h and the .cpp file, with subtle differences.
	///  One copy is in kdelibs/kdeui, and the other copy is in kdepim/libkdepim
	///  This is because kdepim has to remain backwards compatible.  Any changes
	///  to either file should be made to the other.
	/// </remarks>		<author> Antonio Larrosa <larrosa@kde.org>
	///  </author>
	/// 		<short>    KPixmapRegionSelectorWidget is a widget that shows a picture and provides the  user with a friendly way to select a rectangular subregion of the pixmap.</short>

	[SmokeClass("KPixmapRegionSelectorWidget")]
	public class KPixmapRegionSelectorWidget : QWidget, IDisposable {
 		protected KPixmapRegionSelectorWidget(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KPixmapRegionSelectorWidget), this);
		}
		/// <remarks>
		///  Constructor for a KPixmapRegionSelectorWidget.
		///     </remarks>		<short>    Constructor for a KPixmapRegionSelectorWidget.</short>
		public KPixmapRegionSelectorWidget(QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPixmapRegionSelectorWidget#", "KPixmapRegionSelectorWidget(QWidget*)", typeof(void), typeof(QWidget), parent);
		}
		public KPixmapRegionSelectorWidget() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPixmapRegionSelectorWidget", "KPixmapRegionSelectorWidget()", typeof(void));
		}
		/// <remarks>
		///  Sets the pixmap which will be shown for the user to select a region from.
		/// <param> name="pixmap" The pixmap.  Must be non-null.
		/// </param>    </remarks>		<short>    Sets the pixmap which will be shown for the user to select a region from.</short>
		public void SetPixmap(QPixmap pixmap) {
			interceptor.Invoke("setPixmap#", "setPixmap(const QPixmap&)", typeof(void), typeof(QPixmap), pixmap);
		}
		/// <remarks>
		/// </remarks>		<return> the original whole pixmap that we're using in this widget as the
		///  pixmap the user is selecting a region from.
		///     </return>
		/// 		<short>   </short>
		public QPixmap Pixmap() {
			return (QPixmap) interceptor.Invoke("pixmap", "pixmap() const", typeof(QPixmap));
		}
		/// <remarks>
		///  Sets the selected region to be <code>rect</code> (in zoomed pixmap coordinates)
		///     </remarks>		<short>    Sets the selected region to be <code>rect</code> (in zoomed pixmap coordinates)     </short>
		public void SetSelectedRegion(QRect rect) {
			interceptor.Invoke("setSelectedRegion#", "setSelectedRegion(const QRect&)", typeof(void), typeof(QRect), rect);
		}
		/// <remarks>
		///  Returns the selected region ( in zoomed pixmap coordinates )
		///     </remarks>		<short>    Returns the selected region ( in zoomed pixmap coordinates )     </short>
		public QRect SelectedRegion() {
			return (QRect) interceptor.Invoke("selectedRegion", "selectedRegion() const", typeof(QRect));
		}
		/// <remarks>
		///  Returns the selected region ( in unzoomed, original pixmap coordinates )
		///     </remarks>		<short>    Returns the selected region ( in unzoomed, original pixmap coordinates )     </short>
		public QRect UnzoomedSelectedRegion() {
			return (QRect) interceptor.Invoke("unzoomedSelectedRegion", "unzoomedSelectedRegion() const", typeof(QRect));
		}
		/// <remarks>
		///  Resets the selection to use the whole image
		///     </remarks>		<short>    Resets the selection to use the whole image     </short>
		public void ResetSelection() {
			interceptor.Invoke("resetSelection", "resetSelection()", typeof(void));
		}
		/// <remarks>
		/// </remarks>		<return> a QImage object with just the region the user selected from the
		///  image
		///     </return>
		/// 		<short>   </short>
		public QImage SelectedImage() {
			return (QImage) interceptor.Invoke("selectedImage", "selectedImage() const", typeof(QImage));
		}
		/// <remarks>
		///  Sets the aspect ration that the selected subimage should have. The way to
		///  select it, is specifying an example valid <code>width</code> and <code>height.</code>
		/// </remarks>		<short>    Sets the aspect ration that the selected subimage should have.</short>
		/// 		<see> setFreeSelectionAspectRatio</see>
		public void SetSelectionAspectRatio(int width, int height) {
			interceptor.Invoke("setSelectionAspectRatio$$", "setSelectionAspectRatio(int, int)", typeof(void), typeof(int), width, typeof(int), height);
		}
		/// <remarks>
		///  Allows the user to do a selection which has any aspect ratio. This is
		///  the default.
		/// </remarks>		<short>    Allows the user to do a selection which has any aspect ratio.</short>
		/// 		<see> setSelectionAspectRatio</see>
		public void SetFreeSelectionAspectRatio() {
			interceptor.Invoke("setFreeSelectionAspectRatio", "setFreeSelectionAspectRatio()", typeof(void));
		}
		/// <remarks>
		///  Sets the maximum size for the widget. If the image is larger than this
		///  (either horizontally or vertically), it's scaled to adjust to the maximum
		///  size (preserving the aspect ratio)
		///     </remarks>		<short>    Sets the maximum size for the widget.</short>
		public void SetMaximumWidgetSize(int width, int height) {
			interceptor.Invoke("setMaximumWidgetSize$$", "setMaximumWidgetSize(int, int)", typeof(void), typeof(int), width, typeof(int), height);
		}
		/// <remarks>
		///  Rotates the image as specified by the <code>direction</code> parameter, also tries
		///  to rotate the selected region so that it doesn't change, as long as the
		///  forced aspect ratio setting is respected, in other case, the selected region
		///  is reset.
		///     </remarks>		<short>    Rotates the image as specified by the <code>direction</code> parameter, also tries  to rotate the selected region so that it doesn't change, as long as the  forced aspect ratio setting is respected, in other case, the selected region  is reset.</short>
		public void Rotate(KImageEffect.RotateDirection direction) {
			interceptor.Invoke("rotate$", "rotate(KImageEffect::RotateDirection)", typeof(void), typeof(KImageEffect.RotateDirection), direction);
		}
		/// <remarks>
		///  Rotates the current image 90ยบ clockwise
		///     </remarks>		<short>    Rotates the current image 90ยบ clockwise     </short>
		[Q_SLOT("void rotateClockwise()")]
		public void RotateClockwise() {
			interceptor.Invoke("rotateClockwise", "rotateClockwise()", typeof(void));
		}
		/// <remarks>
		///  Rotates the current image 90ยบ counterclockwise
		///     </remarks>		<short>    Rotates the current image 90ยบ counterclockwise     </short>
		[Q_SLOT("void rotateCounterclockwise()")]
		public void RotateCounterclockwise() {
			interceptor.Invoke("rotateCounterclockwise", "rotateCounterclockwise()", typeof(void));
		}
		/// <remarks>
		///  Creates a KMenu with the menu that appears when clicking with the right button on the label
		///     </remarks>		<short>    Creates a KMenu with the menu that appears when clicking with the right button on the label     </short>
		[SmokeMethod("createPopupMenu()")]
		protected virtual KMenu CreatePopupMenu() {
			return (KMenu) interceptor.Invoke("createPopupMenu", "createPopupMenu()", typeof(KMenu));
		}
		~KPixmapRegionSelectorWidget() {
			interceptor.Invoke("~KPixmapRegionSelectorWidget", "~KPixmapRegionSelectorWidget()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KPixmapRegionSelectorWidget", "~KPixmapRegionSelectorWidget()", typeof(void));
		}
		protected new IKPixmapRegionSelectorWidgetSignals Emit {
			get { return (IKPixmapRegionSelectorWidgetSignals) Q_EMIT; }
		}
	}

	public interface IKPixmapRegionSelectorWidgetSignals : IQWidgetSignals {
	}
}
