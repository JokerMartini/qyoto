//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  This view is designed to combine two KFileViews into one widget, to show
	///  directories on the left side and files on the right side.
	///  Methods like selectedItems() to query status _only_ work on the right side,
	///  i.e. on the files.
	///  After creating the KCombiView, you need to supply the view shown in the
	///  right, (see setRight()). Available KFileView implementations are
	///  K3FileIconView and KFileDetailView.
	///  Most of the below methods are just implementations of the baseclass
	///  KFileView, so look there for documentation.
	/// </remarks>		<short>    This view is designed to combine two KFileViews into one widget, to show  directories on the left side and files on the right side.</short>
	/// 		<see> KFileView</see>
	/// 		<see> K3FileIconView</see>
	/// 		<see> KFileDetailView</see>
	/// 		<see> KDirOperator</see>

	[SmokeClass("KCombiView")]
	public class KCombiView : QSplitter, IKFileView, IDisposable {
 		protected KCombiView(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KCombiView), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KCombiView() {
			staticInterceptor = new SmokeInvocation(typeof(KCombiView), null);
		}
		public KCombiView(QWidget parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCombiView#", "KCombiView(QWidget*)", typeof(void), typeof(QWidget), parent);
		}
		[SmokeMethod("widget()")]
		public virtual QWidget Widget() {
			return (QWidget) interceptor.Invoke("widget", "widget()", typeof(QWidget));
		}
		[SmokeMethod("clearView()")]
		public virtual void ClearView() {
			interceptor.Invoke("clearView", "clearView()", typeof(void));
		}
		[SmokeMethod("updateView(bool)")]
		public virtual void UpdateView(bool arg1) {
			interceptor.Invoke("updateView$", "updateView(bool)", typeof(void), typeof(bool), arg1);
		}
		[SmokeMethod("updateView(const KFileItem*)")]
		public virtual void UpdateView(KFileItem arg1) {
			interceptor.Invoke("updateView#", "updateView(const KFileItem*)", typeof(void), typeof(KFileItem), arg1);
		}
		[SmokeMethod("removeItem(const KFileItem*)")]
		public virtual void RemoveItem(KFileItem arg1) {
			interceptor.Invoke("removeItem#", "removeItem(const KFileItem*)", typeof(void), typeof(KFileItem), arg1);
		}
		[SmokeMethod("listingCompleted()")]
		public virtual void ListingCompleted() {
			interceptor.Invoke("listingCompleted", "listingCompleted()", typeof(void));
		}
		/// <remarks>
		///  Sets the view to be shown in the right. You need to call this before
		///  doing anything else with this widget.
		///      </remarks>		<short>    Sets the view to be shown in the right.</short>
		public void SetRight(KFileView view) {
			interceptor.Invoke("setRight#", "setRight(KFileView*)", typeof(void), typeof(KFileView), view);
		}
		[SmokeMethod("setSelectionMode(KFile::SelectionMode)")]
		public virtual void SetSelectionMode(KFile.SelectionMode sm) {
			interceptor.Invoke("setSelectionMode$", "setSelectionMode(KFile::SelectionMode)", typeof(void), typeof(KFile.SelectionMode), sm);
		}
		[SmokeMethod("setSelected(const KFileItem*, bool)")]
		public virtual void SetSelected(KFileItem arg1, bool arg2) {
			interceptor.Invoke("setSelected#$", "setSelected(const KFileItem*, bool)", typeof(void), typeof(KFileItem), arg1, typeof(bool), arg2);
		}
		[SmokeMethod("isSelected(const KFileItem*) const")]
		public virtual bool IsSelected(KFileItem arg1) {
			return (bool) interceptor.Invoke("isSelected#", "isSelected(const KFileItem*) const", typeof(bool), typeof(KFileItem), arg1);
		}
		[SmokeMethod("clearSelection()")]
		public virtual void ClearSelection() {
			interceptor.Invoke("clearSelection", "clearSelection()", typeof(void));
		}
		[SmokeMethod("selectAll()")]
		public virtual void SelectAll() {
			interceptor.Invoke("selectAll", "selectAll()", typeof(void));
		}
		[SmokeMethod("invertSelection()")]
		public virtual void InvertSelection() {
			interceptor.Invoke("invertSelection", "invertSelection()", typeof(void));
		}
		[SmokeMethod("setCurrentItem(const KFileItem*)")]
		public virtual void SetCurrentItem(KFileItem arg1) {
			interceptor.Invoke("setCurrentItem#", "setCurrentItem(const KFileItem*)", typeof(void), typeof(KFileItem), arg1);
		}
		[SmokeMethod("currentFileItem() const")]
		public virtual KFileItem CurrentFileItem() {
			return (KFileItem) interceptor.Invoke("currentFileItem", "currentFileItem() const", typeof(KFileItem));
		}
		[SmokeMethod("firstFileItem() const")]
		public virtual KFileItem FirstFileItem() {
			return (KFileItem) interceptor.Invoke("firstFileItem", "firstFileItem() const", typeof(KFileItem));
		}
		[SmokeMethod("nextItem(const KFileItem*) const")]
		public virtual KFileItem NextItem(KFileItem arg1) {
			return (KFileItem) interceptor.Invoke("nextItem#", "nextItem(const KFileItem*) const", typeof(KFileItem), typeof(KFileItem), arg1);
		}
		[SmokeMethod("prevItem(const KFileItem*) const")]
		public virtual KFileItem PrevItem(KFileItem arg1) {
			return (KFileItem) interceptor.Invoke("prevItem#", "prevItem(const KFileItem*) const", typeof(KFileItem), typeof(KFileItem), arg1);
		}
		[SmokeMethod("insertItem(KFileItem*)")]
		public virtual void InsertItem(KFileItem i) {
			interceptor.Invoke("insertItem#", "insertItem(KFileItem*)", typeof(void), typeof(KFileItem), i);
		}
		[SmokeMethod("clear()")]
		public virtual void Clear() {
			interceptor.Invoke("clear", "clear()", typeof(void));
		}
		[SmokeMethod("setSorting(QDir::SortFlags)")]
		public virtual void SetSorting(int sort) {
			interceptor.Invoke("setSorting$", "setSorting(QDir::SortFlags)", typeof(void), typeof(int), sort);
		}
		[SmokeMethod("readConfig(KConfigGroup*)")]
		public virtual void ReadConfig(KConfigGroup arg1) {
			interceptor.Invoke("readConfig#", "readConfig(KConfigGroup*)", typeof(void), typeof(KConfigGroup), arg1);
		}
		[SmokeMethod("writeConfig(KConfigGroup*)")]
		public virtual void WriteConfig(KConfigGroup arg1) {
			interceptor.Invoke("writeConfig#", "writeConfig(KConfigGroup*)", typeof(void), typeof(KConfigGroup), arg1);
		}
		[SmokeMethod("ensureItemVisible(const KFileItem*)")]
		public virtual void EnsureItemVisible(KFileItem arg1) {
			interceptor.Invoke("ensureItemVisible#", "ensureItemVisible(const KFileItem*)", typeof(void), typeof(KFileItem), arg1);
		}
		[SmokeMethod("actionCollection() const")]
		public virtual KActionCollection ActionCollection() {
			return (KActionCollection) interceptor.Invoke("actionCollection", "actionCollection() const", typeof(KActionCollection));
		}
		[SmokeMethod("setAcceptDrops(bool)")]
		public virtual void SetAcceptDrops(bool b) {
			interceptor.Invoke("setAcceptDrops$", "setAcceptDrops(bool)", typeof(void), typeof(bool), b);
		}
		[SmokeMethod("eventFilter(QObject*, QEvent*)")]
		protected new virtual bool EventFilter(QObject o, QEvent e) {
			return (bool) interceptor.Invoke("eventFilter##", "eventFilter(QObject*, QEvent*)", typeof(bool), typeof(QObject), o, typeof(QEvent), e);
		}
		[Q_SLOT("void slotSortingChanged(QDir::SortFlags)")]
		protected void SlotSortingChanged(int arg1) {
			interceptor.Invoke("slotSortingChanged$", "slotSortingChanged(QDir::SortFlags)", typeof(void), typeof(int), arg1);
		}
		~KCombiView() {
			interceptor.Invoke("~KCombiView", "~KCombiView()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KCombiView", "~KCombiView()", typeof(void));
		}
		/// <remarks>
		///  inserts a list of items.
		/// </remarks>		<short>    inserts a list of items.</short>
		public void AddItemList(List<KFileItem> list) {
			interceptor.Invoke("addItemList#", "addItemList(const KFileItemList&)", typeof(void), typeof(List<KFileItem>), list);
		}
		/// <remarks>
		///  Sets <code>filename</code> the current item in the view, if available.
		///      </remarks>		<short>    Sets <code>filename</code> the current item in the view, if available.</short>
		public void SetCurrentItem(string filename) {
			interceptor.Invoke("setCurrentItem$", "setCurrentItem(const QString&)", typeof(void), typeof(string), filename);
		}
		[SmokeMethod("updateView()")]
		public virtual void UpdateView() {
			interceptor.Invoke("updateView", "updateView()", typeof(void));
		}
		/// <remarks>
		///  Returns the sorting order of the internal list. Newly added files
		///  are added through this sorting.
		///       </remarks>		<short>    Returns the sorting order of the internal list.</short>
		public int Sorting() {
			return (int) interceptor.Invoke("sorting", "sorting() const", typeof(int));
		}
		/// <remarks>
		///  Tells whether the current items are in reversed order (shortcut to
		///  sorting() & QDir.Reversed).
		///      </remarks>		<short>    Tells whether the current items are in reversed order (shortcut to  sorting() & QDir.Reversed).</short>
		public bool IsReversed() {
			return (bool) interceptor.Invoke("isReversed", "isReversed() const", typeof(bool));
		}
		public void SortReversed() {
			interceptor.Invoke("sortReversed", "sortReversed()", typeof(void));
		}
		/// <remarks>
		/// </remarks>		<return> the number of dirs and files
		/// </return>
		/// 		<short>   </short>
		public uint Count() {
			return (uint) interceptor.Invoke("count", "count() const", typeof(uint));
		}
		/// <remarks>
		/// </remarks>		<return> the number of files.
		/// </return>
		/// 		<short>   </short>
		public uint NumFiles() {
			return (uint) interceptor.Invoke("numFiles", "numFiles() const", typeof(uint));
		}
		/// <remarks>
		/// </remarks>		<return> the number of directories
		/// </return>
		/// 		<short>   </short>
		public uint NumDirs() {
			return (uint) interceptor.Invoke("numDirs", "numDirs() const", typeof(uint));
		}
		[SmokeMethod("setViewMode(KFileView::ViewMode)")]
		public virtual void SetViewMode(KFileView.ViewMode vm) {
			interceptor.Invoke("setViewMode$", "setViewMode(KFileView::ViewMode)", typeof(void), typeof(KFileView.ViewMode), vm);
		}
		[SmokeMethod("viewMode() const")]
		public virtual KFileView.ViewMode viewMode() {
			return (KFileView.ViewMode) interceptor.Invoke("viewMode", "viewMode() const", typeof(KFileView.ViewMode));
		}
		/// <remarks>
		/// </remarks>		<return> the localized name of the view, which could be displayed
		///  somewhere, e.g. in a menu, where the user can choose between views.
		/// </return>
		/// 		<short>   </short>
		/// 		<see> setViewName</see>
		public string ViewName() {
			return (string) interceptor.Invoke("viewName", "viewName() const", typeof(string));
		}
		/// <remarks>
		///  Sets the name of the view, which could be displayed somewhere.
		///  E.g. "Image Preview".
		///      </remarks>		<short>    Sets the name of the view, which could be displayed somewhere.</short>
		public void SetViewName(string name) {
			interceptor.Invoke("setViewName$", "setViewName(const QString&)", typeof(void), typeof(string), name);
		}
		[SmokeMethod("setParentView(KFileView*)")]
		public virtual void SetParentView(KFileView parent) {
			interceptor.Invoke("setParentView#", "setParentView(KFileView*)", typeof(void), typeof(KFileView), parent);
		}
		/// <remarks>
		/// </remarks>		<return> all currently highlighted items.
		///      </return>
		/// 		<short>   </short>
		public List<KFileItem> SelectedItems() {
			return (List<KFileItem>) interceptor.Invoke("selectedItems", "selectedItems() const", typeof(List<KFileItem>));
		}
		/// <remarks>
		/// </remarks>		<return> all items currently available in the current sort-order
		///      </return>
		/// 		<short>   </short>
		public List<KFileItem> Items() {
			return (List<KFileItem>) interceptor.Invoke("items", "items() const", typeof(List<KFileItem>));
		}
		/// <remarks>
		///  This is a KFileDialog specific hack: we want to select directories with
		///  single click, but not files. But as a generic class, we have to be able
		///  to select files on single click as well.
		///  This gives us the opportunity to do both.
		///  Every view has to decide when to call select( item ) when a file was
		///  single-clicked, based on onlyDoubleClickSelectsFiles().
		///      </remarks>		<short>    This is a KFileDialog specific hack: we want to select directories with  single click, but not files.</short>
		public void SetOnlyDoubleClickSelectsFiles(bool enable) {
			interceptor.Invoke("setOnlyDoubleClickSelectsFiles$", "setOnlyDoubleClickSelectsFiles(bool)", typeof(void), typeof(bool), enable);
		}
		/// <remarks>
		/// </remarks>		<return> whether files (not directories) should only be select()ed by
		///  double-clicks.
		/// </return>
		/// 		<short>   </short>
		/// 		<see> setOnlyDoubleClickSelectsFiles</see>
		public bool OnlyDoubleClickSelectsFiles() {
			return (bool) interceptor.Invoke("onlyDoubleClickSelectsFiles", "onlyDoubleClickSelectsFiles() const", typeof(bool));
		}
		/// <remarks>
		///  increases the number of dirs and files.
		/// </remarks>		<return> true if the item fits the view mode
		///      </return>
		/// 		<short>    increases the number of dirs and files.</short>
		public bool UpdateNumbers(KFileItem i) {
			return (bool) interceptor.Invoke("updateNumbers#", "updateNumbers(const KFileItem*)", typeof(bool), typeof(KFileItem), i);
		}
		public KFileViewSignaler Signaler() {
			return (KFileViewSignaler) interceptor.Invoke("signaler", "signaler() const", typeof(KFileViewSignaler));
		}
		/// <remarks>
		///  Specify DND options. See DropOptions for details.
		///  All options are disabled by default.
		///      </remarks>		<short>    Specify DND options.</short>
		[SmokeMethod("setDropOptions(int)")]
		public virtual void SetDropOptions(int options) {
			interceptor.Invoke("setDropOptions$", "setDropOptions(int)", typeof(void), typeof(int), options);
		}
		/// <remarks>
		///  Returns the DND options in effect.
		///  See DropOptions for details.
		///      </remarks>		<short>    Returns the DND options in effect.</short>
		public int dropOptions() {
			return (int) interceptor.Invoke("dropOptions", "dropOptions()", typeof(int));
		}
		/// <remarks>
		///  This method calculates a string from the given parameters, that is
		///  suitable for sorting with e.g. QIconView or QListView. Their
		///  Item-classes usually have a setKey( string ) method or a virtual
		///  method string key() that is used for sorting.
		/// <param> name="value" Any string that should be used as sort criterion
		/// </param><param> name="isDir" Tells whether the key is computed for an item representing
		///               a directory (directories are usually sorted before files)
		/// </param><param> name="SortFlags" An ORed combination of QDir.SortFlag flags.
		///                   Currently, the values IgnoreCase, Reversed and
		///                   DirsFirst are taken into account.
		///      </param></remarks>		<short>    This method calculates a string from the given parameters, that is  suitable for sorting with e.</short>
		public static string SortingKey(string value, bool isDir, int SortFlags) {
			return (string) staticInterceptor.Invoke("sortingKey$$$", "sortingKey(const QString&, bool, QDir::SortFlags)", typeof(string), typeof(string), value, typeof(bool), isDir, typeof(int), SortFlags);
		}
		/// <remarks>
		///  An overloaded method that takes not a string, but a number as sort
		///  criterion. You can use this for file-sizes or dates/times for example.
		///  If you use a time_t, you need to cast that to KIO.Filesize_t because
		///  of ambiguity problems.
		///      </remarks>		<short>    An overloaded method that takes not a string, but a number as sort  criterion.</short>
		public static string SortingKey(long value, bool isDir, int SortFlags) {
			return (string) staticInterceptor.Invoke("sortingKey$$$", "sortingKey(KIO::filesize_t, bool, QDir::SortFlags)", typeof(string), typeof(long), value, typeof(bool), isDir, typeof(int), SortFlags);
		}
		/// <remarks>
		///  delay before auto opening a directory
		///      </remarks>		<short>   </short>
		public static int AutoOpenDelay() {
			return (int) staticInterceptor.Invoke("autoOpenDelay", "autoOpenDelay()", typeof(int));
		}
		protected new IKCombiViewSignals Emit {
			get { return (IKCombiViewSignals) Q_EMIT; }
		}
	}

	public interface IKCombiViewSignals : IQSplitterSignals {
	}
}
