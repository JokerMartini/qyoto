//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  If you develop a library that is to be loaded dynamically at runtime, then
	///  you should return a pointer to a KPluginFactory.
	///  For most cases it is enough to use the K_PLUGIN_FACTORY macro to create the factory.
	///  Example:
	///  <pre>
	///  #include <KPluginFactory>
	///  #include <KPluginLoader>
	///  #include <plugininterface.h>
	///  class MyPlugin;
	///  K_PLUGIN_FACTORY(MyPluginFactory,
	///                   registerPlugin<MyPlugin>();
	///                  )
	///  K_EXPORT_PLUGIN(MyPluginFactory("componentName"))
	///  class MyPlugin : public PluginInterface
	///  {
	///      ...
	///      KComponentData kcd = MyPluginFactory.ComponentData();
	///      ...
	///  }
	///  </pre>
	///  K_PLUGIN_FACTORY is a convenient macro that expands to a class derived from KPluginFactory
	///  providing two constructors and a static componentData() function. The second argument to
	///  K_PLUGIN_FACTORY is code that is called from the constructors. There you can use registerPlugin
	///  to register as many plugins for the factory as you want to.
	///  If you want to write a custom KPluginFactory not using the standard macro(s) you can reimplement
	///  the create(string iface, QWidget parentWidget, QObject parent, QVariantListargs, stringkeyword)
	///  function.
	///  Example:
	///  <pre>
	///  class SomeScriptLanguageFactory : public KPluginFactory
	///  {
	///       public      SomeScriptLanguageFactory()
	///      {}
	///  protected:
	///      QObject create(string iface, QWidget parentWidget, QObject parent, QVariantListargs, stringkeyword)
	///      {
	///          string identifier = QLatin1String(iface) + QLatin1Char('_') + keyword;
	///          // load scripting language module from the information in identifier
	///          // and return it:
	///          return object;
	///      }
	///  }
	///  </pre>
	///  If you want to load a library use KPluginLoader.
	///  The application that wants to instantiate plugin classes later on can do the following:
	///  <pre>
	///  KPluginFactory factory = KPluginLoader("libraryname").factory();
	///  if (factory) {
	///      PluginInterface p1 = factory.Create<PluginInterface>(parent);
	///      OtherInterface p2  = factory.Create<OtherInterface>(parent);
	///      NextInterface p3   = factory.Create<NextInterface>("keyword1", parent);
	///      NextInterface p3   = factory.Create<NextInterface>("keyword2", parent);
	///  }
	///  </pre>
	///  \author Matthias Kretz <kretz@kde.org>
	///  \author Bernhard Loos <nhuh.put@web.de>
	///   See <see cref="IKPluginFactorySignals"></see> for signals emitted by KPluginFactory
	/// </remarks>		<short>    If you develop a library that is to be loaded dynamically at runtime, then  you should return a pointer to a KPluginFactory.</short>

	[SmokeClass("KPluginFactory")]
	public class KPluginFactory : QObject, IDisposable {
 		protected KPluginFactory(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KPluginFactory), this);
		}
		// KPluginFactory* KPluginFactory(const char* arg1,const char* arg2,QObject* arg3); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(const char* arg1,const char* arg2); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(const char* arg1); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(const KAboutData& arg1,QObject* arg2); >>>> NOT CONVERTED
		// KPluginFactory* KPluginFactory(const KAboutData& arg1); >>>> NOT CONVERTED
		// template<typename T> T* create(QObject* arg1,const QVariantList& arg2); >>>> NOT CONVERTED
		// template<typename T> T* create(QObject* arg1); >>>> NOT CONVERTED
		// template<typename T> T* create(); >>>> NOT CONVERTED
		// template<typename T> T* create(const QString& arg1,QObject* arg2,const QVariantList& arg3); >>>> NOT CONVERTED
		// template<typename T> T* create(const QString& arg1,QObject* arg2); >>>> NOT CONVERTED
		// template<typename T> T* create(const QString& arg1); >>>> NOT CONVERTED
		// template<typename T> T* create(QWidget* arg1,QObject* arg2,const QString& arg3,const QVariantList& arg4); >>>> NOT CONVERTED
		// template<typename T> T* create(QWidget* arg1,QObject* arg2,const QString& arg3); >>>> NOT CONVERTED
		// template<typename T> T* create(QWidget* arg1,QObject* arg2); >>>> NOT CONVERTED
		// template<T> void registerPlugin(const QString& arg1,CreateInstanceFunction instanceFunction.createInstanceFunction(reinterpret_cast<T*>(0)) arg2); >>>> NOT CONVERTED
		// template<T> void registerPlugin(const QString& arg1); >>>> NOT CONVERTED
		// template<T> void registerPlugin(); >>>> NOT CONVERTED
		// QVariantList stringListToVariantList(const QStringList& arg1); >>>> NOT CONVERTED
		// template<impl, class ParentType>  QObject* createInstance(QWidget* arg1,QObject* arg2,const QVariantList& arg3); >>>> NOT CONVERTED
		// template<impl>  QObject* createPartInstance(QWidget* arg1,QObject* arg2,const QVariantList& arg3); >>>> NOT CONVERTED
		/// <remarks>
		///  This constructor creates a factory for a plugin with the given <pre>componentName</pre> and
		///  <pre>catalogName</pre>. Those values are used to initialize a KComponentData object for the plugin.
		///  You can later access it with componentData(). If <pre>componentName</pre> is 0, an invalid KComponentData
		///  object will be created.
		///  \param componentName the component name of the plugin
		///  \param catalogName the translation catalog to use
		///  \param parent a parent object
		///      </remarks>		<short>    This constructor creates a factory for a plugin with the given \p componentName and  \p catalogName.</short>
		/// <remarks>
		///  This constructor creates a factory for a plugin with the given KAboutData object. This object is
		///  used to initialize a KComponentData object for the plugin. You can later access it with
		///  componentData().
		///  KPluginFactory takes ownership of the <pre>aboutData</pre> object, so don't delete it yourself!
		///  \param aboutData the KAboutData for the plugin
		///  \param parent a parent object
		///      </remarks>		<short>    This constructor creates a factory for a plugin with the given KAboutData object.</short>
		/// <remarks>
		///  You can use this method to get the component data of the plugin. It is filled with the
		///  information given to the constructor of KPluginFactory.
		///  The K_PLUGIN_FACTORY macros provide a static version of this method, this can be used from
		///  any place within the plugin.
		///  \returns The KComponentData for the plugin
		///      </remarks>		<short>    You can use this method to get the component data of the plugin.</short>
		public KComponentData ComponentData() {
			return (KComponentData) interceptor.Invoke("componentData", "componentData() const", typeof(KComponentData));
		}
		/// <remarks>
		///  Use this methode to created an object. It will try to created an object which inherits
		///  <pre>T</pre>. If it has multiple choices, you will get a fatal error (kFatal()), so be creaful
		///  to request a unique interface or use keywords.
		///  \param T The interface for which an object should be created. The object will inherit <pre>T</pre>.
		///  \param parent The parent of the object. If <pre>parent</pre> is a widget type, it will also passed
		///                to the parentWidget argument of the CreateInstanceFunction for the object.
		///  \param args Additional arguments which will be passed to the object.
		///  \returns A pointer to the created object is returned, or 0 if an error occured.
		///      </remarks>		<short>    Use this methode to created an object.</short>
		/// <remarks>
		///  Use this methode to created an object. It will try to created an object which inherits
		///  <pre>T</pre> and was registered with <pre>keyword</pre>.
		///  \param T The interface for which an object should be created. The object will inherit <pre>T</pre>.
		///  \param keyword The keyword of the object.
		///  \param parent The parent of the object. If <pre>parent</pre> is a widget type, it will also passed
		///                to the parentWidget argument of the CreateInstanceFunction for the object.
		///  \param args Additional arguments which will be passed to the object.
		///  \returns A pointer to the created object is returned, or 0 if an error occured.
		///      </remarks>		<short>    Use this methode to created an object.</short>
		/// <remarks>
		///  Use this methode to created an object. It will try to created an object which inherits
		///  <pre>T</pre> and was registered with <pre>keyword</pre>.
		///  This overload has an additional <pre>parentWidget</pre> argument, which is used by some plugins (e.g. Parts).
		///  \param T The interface for which an object should be created. The object will inherit <pre>T</pre>.
		///  \param parentWidget An additional parent widget.
		///  \param parent The parent of the object. If <pre>parent</pre> is a widget type, it will also passed
		///                to the parentWidget argument of the CreateInstanceFunction for the object.
		///  \param keyword The keyword of the object.
		///  \param args Additional arguments which will be passed to the object.
		///  \returns A pointer to the created object is returned, or 0 if an error occured.
		///      </remarks>		<short>    Use this methode to created an object.</short>
		/// <remarks>
		///  Registers a plugin with the factory. Call this function from the constructor of the
		///  KPluginFactory subclass to make the create function able to instantiate the plugin when asked
		///  for an interface the plugin implements.
		///  You can register as many plugin classes as you want as long as either the plugin interface or
		///  the <pre>keyword</pre> makes it unique. E.g. it is possible to register a KCModule and a
		///  KParts.Part without having to specify keywords since their interfaces differ.
		///  \param T The name of the plugin class
		///  \param keyword An optional keyword as unique identifier for the plugin. This allows you to
		///  put more than one plugin with the same interface into the same library using the same
		///  factory. X-KDE-PluginKeyword is a convenient way to specify the keyword in a desktop file.
		///  \param instanceFunction A function pointer to a function that creates an instance of the
		///  plugin. The default function that will be used depends on the type of interface. If the
		///  interface inherits from
		///  \li <code>KParts</code>.Part the function will call
		///  <pre>
		///  new T(QWidget parentWidget, QObject parent, QVariantListargs)
		///  </pre>
		///  \li <code>QWidget</code> the function will call
		///  <pre>
		///  new T(QWidget parent, QVariantListargs)
		///  </pre>
		///  <li>else</li> the function will call
		///  <pre>
		///  new T(QObject parent, QVariantListargs)
		///  </pre>
		///      </remarks>		<short>    Registers a plugin with the factory.</short>
		/// <remarks>
		///  \internal
		///  Converts a List<string> to a QVariantList
		///      </remarks>		<short>    \internal  Converts a List<string> to a QVariantList      </short>
		/// <remarks>
		///  \internal
		///  Converts a QVariantList of strings to a List<string>
		///      </remarks>		<short>    \internal  Converts a QVariantList of strings to a List<string>      </short>
		protected List<string> VariantListToStringList(List<QVariant> list) {
			return (List<string>) interceptor.Invoke("variantListToStringList?", "variantListToStringList(const QVariantList&)", typeof(List<string>), typeof(List<QVariant>), list);
		}
		[SmokeMethod("setupTranslations()")]
		protected virtual void SetupTranslations() {
			interceptor.Invoke("setupTranslations", "setupTranslations()", typeof(void));
		}
		/// <remarks>
		///  This method sets the component data of the plugin. You can access the component data object
		///  later with componentData().
		///  Normally you don't have to call this, because the factory constructs a component data object
		///  from the information given to the constructor.
		///  The object is destroyed, when the module containing the plugin is unloaded. Normally this happens
		///  only on application shutdown.
		///  \param componentData the new KComponentData object
		///      </remarks>		<short>    This method sets the component data of the plugin.</short>
		protected void SetComponentData(KComponentData componentData) {
			interceptor.Invoke("setComponentData#", "setComponentData(const KComponentData&)", typeof(void), typeof(KComponentData), componentData);
		}
		/// <remarks>
		///  This function is called when the factory asked to create an Object.
		///  You may reimplement it to provide a very flexible factory. This is especially useful to
		///  provide generic factories for plugins implemeted using a scripting language.
		///  \param iface The staticMetaObject.ClassName() string identifying the plugin interface that
		///  was requested. E.g. for KCModule plugins this string will be "KCModule".
		///  \param parentWidget Only used if the requested plugin is a KPart.
		///  \param parent The parent object for the plugin object.
		///  \param args A plugin specific list of arbitrary arguments.
		///  \param keyword A string that uniquely identifies the plugin. If a KService is used this
		///  keyword is read from the X-KDE-PluginKeyword entry in the .desktop file.
		///      </remarks>		<short>    This function is called when the factory asked to create an Object.</short>
		[SmokeMethod("create(const char*, QWidget*, QObject*, const QVariantList&, const QString&)")]
		protected virtual QObject Create(string iface, QWidget parentWidget, QObject parent, List<QVariant> args, string keyword) {
			return (QObject) interceptor.Invoke("create$##?$", "create(const char*, QWidget*, QObject*, const QVariantList&, const QString&)", typeof(QObject), typeof(string), iface, typeof(QWidget), parentWidget, typeof(QObject), parent, typeof(List<QVariant>), args, typeof(string), keyword);
		}
		~KPluginFactory() {
			interceptor.Invoke("~KPluginFactory", "~KPluginFactory()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KPluginFactory", "~KPluginFactory()", typeof(void));
		}
		protected new IKPluginFactorySignals Emit {
			get { return (IKPluginFactorySignals) Q_EMIT; }
		}
	}

	public interface IKPluginFactorySignals : IQObjectSignals {
		[Q_SIGNAL("void objectCreated(QObject*)")]
		void ObjectCreated(QObject arg1);
	}
}
