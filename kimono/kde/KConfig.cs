//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;


	[SmokeClass("KConfig")]
	public class KConfig : KConfigBase, IDisposable {
 		protected KConfig(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KConfig), this);
		}
		public enum OpenFlag {
			SimpleConfig = 0x00,
			IncludeGlobals = 0x01,
			CascadeConfig = 0x02,
			DontMergeOnSync = 0x04,
			FullConfig = IncludeGlobals|CascadeConfig,
		}
		// KConfig* KConfig(KConfigPrivate& arg1); >>>> NOT CONVERTED
		public KConfig(string file, uint mode, string resourceType) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig$$$", "KConfig(const QString&, KConfig::OpenFlags, const char*)", typeof(void), typeof(string), file, typeof(uint), mode, typeof(string), resourceType);
		}
		public KConfig(string file, uint mode) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig$$", "KConfig(const QString&, KConfig::OpenFlags)", typeof(void), typeof(string), file, typeof(uint), mode);
		}
		public KConfig(string file) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig$", "KConfig(const QString&)", typeof(void), typeof(string), file);
		}
		public KConfig() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig", "KConfig()", typeof(void));
		}
		public KConfig(KComponentData componentData, string file, uint mode, string resourceType) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig#$$$", "KConfig(const KComponentData&, const QString&, KConfig::OpenFlags, const char*)", typeof(void), typeof(KComponentData), componentData, typeof(string), file, typeof(uint), mode, typeof(string), resourceType);
		}
		public KConfig(KComponentData componentData, string file, uint mode) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig#$$", "KConfig(const KComponentData&, const QString&, KConfig::OpenFlags)", typeof(void), typeof(KComponentData), componentData, typeof(string), file, typeof(uint), mode);
		}
		public KConfig(KComponentData componentData, string file) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig#$", "KConfig(const KComponentData&, const QString&)", typeof(void), typeof(KComponentData), componentData, typeof(string), file);
		}
		public KConfig(KComponentData componentData) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfig#", "KConfig(const KComponentData&)", typeof(void), typeof(KComponentData), componentData);
		}
		[SmokeMethod("sync()")]
		public override void Sync() {
			interceptor.Invoke("sync", "sync()", typeof(void));
		}
		public KComponentData ComponentData() {
			return (KComponentData) interceptor.Invoke("componentData", "componentData() const", typeof(KComponentData));
		}
		/// <remarks>
		///  Checks whether the config file contains the update <code>id</code>
		///  as contained in <code>updateFile.</code> If not, it runs kconf_update
		///  to update the config file.
		///  If you install config update files with critical fixes
		///  you may wish to use this method to verify that a critical
		///  update has indeed been performed to catch the case where
		///  a user restores an old config file from backup that has
		///  not been updated yet.
		/// <param> name="id" the update to check
		/// </param><param> name="updateFile" the file containing the update
		///      </param></remarks>		<short>    Checks whether the config file contains the update <code>id</code>  as contained in <code>updateFile.</code></short>
		public void CheckUpdate(string id, string updateFile) {
			interceptor.Invoke("checkUpdate$$", "checkUpdate(const QString&, const QString&)", typeof(void), typeof(string), id, typeof(string), updateFile);
		}
		/// <remarks>
		///  Cleans all entries in the entry map, so the
		///  values will not be written to disk on a later call to
		///  sync().
		///      </remarks>		<short>    Cleans all entries in the entry map, so the  values will not be written to disk on a later call to  sync().</short>
		[SmokeMethod("clean()")]
		public override void Clean() {
			interceptor.Invoke("clean", "clean()", typeof(void));
		}
		/// <remarks>
		///  Copies all entries from this config object to a new config
		///  object that will save itself to <code>file.</code>
		///  Actual saving to <code>file</code> happens when the returned object is
		///  destructed or when sync() is called upon it.
		/// <param> name="file" the new config object will save itself to.
		/// </param><param> name="config" optional config object to reuse
		///      </param></remarks>		<short>    Copies all entries from this config object to a new config  object that will save itself to <code>file.</code></short>
		public KConfig CopyTo(string file, KConfig config) {
			return (KConfig) interceptor.Invoke("copyTo$#", "copyTo(const QString&, KConfig*) const", typeof(KConfig), typeof(string), file, typeof(KConfig), config);
		}
		public KConfig CopyTo(string file) {
			return (KConfig) interceptor.Invoke("copyTo$", "copyTo(const QString&) const", typeof(KConfig), typeof(string), file);
		}
		/// <remarks>
		///  Clears all internal data structures and then reread
		///  configuration information from persistent storage.
		///      </remarks>		<short>    Clears all internal data structures and then reread  configuration information from persistent storage.</short>
		public void ReparseConfiguration() {
			interceptor.Invoke("reparseConfiguration", "reparseConfiguration()", typeof(void));
		}
		/// <remarks>
		///  Returns the state of the config object.
		/// </remarks>		<return> the state of the config object
		///      </return>
		/// 		<short>    Returns the state of the config object.</short>
		/// 		<see> ConfigState</see>
		[SmokeMethod("getConfigState() const")]
		public override KConfigBase.ConfigState GetConfigState() {
			return (KConfigBase.ConfigState) interceptor.Invoke("getConfigState", "getConfigState() const", typeof(KConfigBase.ConfigState));
		}
		public bool IsConfigWritable(bool warnUser) {
			return (bool) interceptor.Invoke("isConfigWritable$", "isConfigWritable(bool)", typeof(bool), typeof(bool), warnUser);
		}
		/// <remarks>
		///  Sets the merge stack to the list of files. The stack is last in first out with
		///  the top of the stack being the most specific config file.
		/// <param> name="files" A list of extra config files containing the full paths of the
		///  local config files to set.
		///      </param></remarks>		<short>    Sets the merge stack to the list of files.</short>
		public void AddConfigSources(List<string> sources) {
			interceptor.Invoke("addConfigSources?", "addConfigSources(const QStringList&)", typeof(void), typeof(List<string>), sources);
		}
		/// <remarks>
		///  Returns the current locale.
		///      </remarks>		<short>    Returns the current locale.</short>
		public string Locale() {
			return (string) interceptor.Invoke("locale", "locale() const", typeof(string));
		}
		/// <remarks>
		///  Sets the locale to <code>aLocale.</code>
		///  The global locale is used as default.
		///  @note If set to the empty string, <b></b>o locale will be matched. This effectively disables
		///  Native Language Support.
		/// </remarks>		<return> @c true if locale was changed and configuration was reparsed.
		///      </return>
		/// 		<short>    Sets the locale to <code>aLocale.</code></short>
		public bool SetLocale(string aLocale) {
			return (bool) interceptor.Invoke("setLocale$", "setLocale(const QString&)", typeof(bool), typeof(string), aLocale);
		}
		public void SetReadDefaults(bool b) {
			interceptor.Invoke("setReadDefaults$", "setReadDefaults(bool)", typeof(void), typeof(bool), b);
		}
		public bool ReadDefaults() {
			return (bool) interceptor.Invoke("readDefaults", "readDefaults() const", typeof(bool));
		}
		[SmokeMethod("isImmutable() const")]
		public override bool IsImmutable() {
			return (bool) interceptor.Invoke("isImmutable", "isImmutable() const", typeof(bool));
		}
		/// <remarks>
		///  Returns a list of groups that are known.
		/// </remarks>		<return> a list of of groups
		///      </return>
		/// 		<short>    Returns a list of groups that are known.</short>
		[SmokeMethod("groupList() const")]
		public override List<string> GroupList() {
			return (List<string>) interceptor.Invoke("groupList", "groupList() const", typeof(List<string>));
		}
		/// <remarks>
		///  Returns the filename passed to the constructor.
		///      </remarks>		<short>    Returns the filename passed to the constructor.</short>
		public string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		/// <remarks>
		///  Returns a map (tree) of entries in a particular group.  Only the actual entry as a string
		///  is returned, none of the other internal data is included.
		/// <param> name="aGroup" The group to get keys from
		///  - If <code>aGroup</code> is the empty string "", the entries from the <b>default</b> group are returned.
		///  - If <code>aGroup</code> is null, the entries from the current group are returned.
		/// </param></remarks>		<return> A map of entries in the group specified, indexed by key.
		///          The returned map may be empty if the group is empty, or not found.
		/// </return>
		/// 		<short>    Returns a map (tree) of entries in a particular group.</short>
		/// 		<see> QMap</see>
		public Dictionary<string, string> EntryMap(string aGroup) {
			return (Dictionary<string, string>) interceptor.Invoke("entryMap$", "entryMap(const QString&) const", typeof(Dictionary<string, string>), typeof(string), aGroup);
		}
		public Dictionary<string, string> EntryMap() {
			return (Dictionary<string, string>) interceptor.Invoke("entryMap", "entryMap() const", typeof(Dictionary<string, string>));
		}
		[SmokeMethod("hasGroupImpl(const QByteArray&) const")]
		protected override bool HasGroupImpl(QByteArray group) {
			return (bool) interceptor.Invoke("hasGroupImpl#", "hasGroupImpl(const QByteArray&) const", typeof(bool), typeof(QByteArray), group);
		}
		[SmokeMethod("groupImpl(const QByteArray&)")]
		protected override KConfigGroup GroupImpl(QByteArray b) {
			return (KConfigGroup) interceptor.Invoke("groupImpl#", "groupImpl(const QByteArray&)", typeof(KConfigGroup), typeof(QByteArray), b);
		}
		[SmokeMethod("deleteGroupImpl(const QByteArray&, KConfigBase::WriteConfigFlags)")]
		protected override void DeleteGroupImpl(QByteArray group, uint flags) {
			interceptor.Invoke("deleteGroupImpl#$", "deleteGroupImpl(const QByteArray&, KConfigBase::WriteConfigFlags)", typeof(void), typeof(QByteArray), group, typeof(uint), flags);
		}
		[SmokeMethod("deleteGroupImpl(const QByteArray&)")]
		protected virtual void DeleteGroupImpl(QByteArray group) {
			interceptor.Invoke("deleteGroupImpl#", "deleteGroupImpl(const QByteArray&)", typeof(void), typeof(QByteArray), group);
		}
		[SmokeMethod("groupIsImmutableImpl(const QByteArray&) const")]
		protected override bool GroupIsImmutableImpl(QByteArray aGroup) {
			return (bool) interceptor.Invoke("groupIsImmutableImpl#", "groupIsImmutableImpl(const QByteArray&) const", typeof(bool), typeof(QByteArray), aGroup);
		}
		~KConfig() {
			interceptor.Invoke("~KConfig", "~KConfig()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KConfig", "~KConfig()", typeof(void));
		}
	}
}
