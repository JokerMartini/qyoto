//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Runtime.InteropServices;
	using System.Collections.Generic;

	/// <remarks>
	///  CalendarSystem abstract class, default derived kde gregorian class and
	///  factory class. Provides support for different calendar types for kde
	///  calendar widget and related stuff.
	///  Derived classes must be created through KCalendarFactory class
	/// </remarks>		<author> Carlos Moro <cfmoro@correo.uniovi.es>
	///  </author>
	/// 		<short>    CalendarSystem abstract class, default derived kde gregorian class and  factory class.</short>

	[SmokeClass("KCalendarSystem")]
	public abstract class KCalendarSystem : Object {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KCalendarSystem(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KCalendarSystem), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KCalendarSystem() {
			staticInterceptor = new SmokeInvocation(typeof(KCalendarSystem), null);
		}
		public enum DispalyForm {
			LongForm = 0,
			ShortForm = 1,
		}
		/// <remarks>
		///  Constructor of abstract calendar class. This will be called by the derived classes.
		/// <param> name="locale" It will use this locale for translations, 0 means global.
		///    </param></remarks>		<short>    Constructor of abstract calendar class.</short>
		public KCalendarSystem(KLocale locale) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCalendarSystem#", "KCalendarSystem(const KLocale*)", typeof(void), typeof(KLocale), locale);
		}
		public KCalendarSystem() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KCalendarSystem", "KCalendarSystem()", typeof(void));
		}
		/// <remarks>
		///  Gets specific calendar type year for a given gregorian date
		/// <param> name="date" gregorian date
		/// </param></remarks>		<return> year
		///    </return>
		/// 		<short>    Gets specific calendar type year for a given gregorian date </short>
		[SmokeMethod("year(const QDate&) const")]
		public abstract int Year(QDate date);
		/// <remarks>
		///  Converts a date into a year literal
		/// <param> name="pDate" The date to convert
		/// </param><param> name="bShort" If the short version of should be used
		/// </param></remarks>		<return> The year literal of the date
		///    </return>
		/// 		<short>    Converts a date into a year literal </short>
		[SmokeMethod("yearString(const QDate&, bool) const")]
		public virtual string YearString(QDate pDate, bool bShort) {
			return (string) interceptor.Invoke("yearString#$", "yearString(const QDate&, bool) const", typeof(string), typeof(QDate), pDate, typeof(bool), bShort);
		}
		/// <remarks>
		///  Converts a year literal of a part of a string into a integer starting at the beginning of the string
		/// <param> name="sNum" The string to parse
		/// </param><param> name="iLength" The number of chars used, and 0 if no valid symbols was found in the string
		/// </param></remarks>		<return> An integer corresponding to the year
		///    </return>
		/// 		<short>    Converts a year literal of a part of a string into a integer starting at the beginning of the string </short>
		[SmokeMethod("yearStringToInteger(const QString&, int&) const")]
		public virtual int YearStringToInteger(string sNum, ref int iLength) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(sNum);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(sNum);
#endif
			stack[2].s_int = iLength;
			interceptor.Invoke("yearStringToInteger$$", "yearStringToInteger(const QString&, int&) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			iLength = stack[2].s_int;
			return stack[0].s_int;
		}
		/// <remarks>
		///  Gets specific calendar type month for a given gregorian date
		/// <param> name="date" gregorian date
		/// </param></remarks>		<return> month number
		///    </return>
		/// 		<short>    Gets specific calendar type month for a given gregorian date </short>
		[SmokeMethod("month(const QDate&) const")]
		public abstract int Month(QDate date);
		/// <remarks>
		///  Converts a date into a month literal
		/// <param> name="pDate" The date to convert
		/// </param><param> name="bShort" If the short version of should be used
		/// </param></remarks>		<return> The month literal of the date
		///    </return>
		/// 		<short>    Converts a date into a month literal </short>
		[SmokeMethod("monthString(const QDate&, bool) const")]
		public virtual string MonthString(QDate pDate, bool bShort) {
			return (string) interceptor.Invoke("monthString#$", "monthString(const QDate&, bool) const", typeof(string), typeof(QDate), pDate, typeof(bool), bShort);
		}
		/// <remarks>
		///  Converts a month literal of a part of a string into a integer starting at the beginning of the string
		/// <param> name="sNum" The string to parse
		/// </param><param> name="iLength" The number of chars used, and 0 if no valid symbols was found in the string
		/// </param></remarks>		<return> An integer corresponding to the month
		///    </return>
		/// 		<short>    Converts a month literal of a part of a string into a integer starting at the beginning of the string </short>
		[SmokeMethod("monthStringToInteger(const QString&, int&) const")]
		public virtual int MonthStringToInteger(string sNum, ref int iLength) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(sNum);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(sNum);
#endif
			stack[2].s_int = iLength;
			interceptor.Invoke("monthStringToInteger$$", "monthStringToInteger(const QString&, int&) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			iLength = stack[2].s_int;
			return stack[0].s_int;
		}
		/// <remarks>
		///  Gets specific calendar type day number of month for a given date
		/// <param> name="date" gregorian date equivalent to the specific one
		/// </param></remarks>		<return> day of the month
		///    </return>
		/// 		<short>    Gets specific calendar type day number of month for a given date </short>
		[SmokeMethod("day(const QDate&) const")]
		public abstract int Day(QDate date);
		/// <remarks>
		///  Converts a date into a day literal
		/// <param> name="pDate" The date to convert
		/// </param><param> name="bShort" If the short version of should be used
		/// </param></remarks>		<return> The day literal of the date
		///    </return>
		/// 		<short>    Converts a date into a day literal </short>
		[SmokeMethod("dayString(const QDate&, bool) const")]
		public virtual string DayString(QDate pDate, bool bShort) {
			return (string) interceptor.Invoke("dayString#$", "dayString(const QDate&, bool) const", typeof(string), typeof(QDate), pDate, typeof(bool), bShort);
		}
		/// <remarks>
		///  Converts a day literal of a part of a string into a integer starting at the beginning of the string
		/// <param> name="sNum" The string to parse
		/// </param><param> name="iLength" The number of chars used, and 0 if no valid symbols was found in the string
		/// </param></remarks>		<return> An integer corresponding to the day
		///    </return>
		/// 		<short>    Converts a day literal of a part of a string into a integer starting at the beginning of the string </short>
		[SmokeMethod("dayStringToInteger(const QString&, int&) const")]
		public virtual int DayStringToInteger(string sNum, ref int iLength) {
			StackItem[] stack = new StackItem[3];
#if DEBUG
			stack[1].s_class = (IntPtr) DebugGCHandle.Alloc(sNum);
#else
			stack[1].s_class = (IntPtr) GCHandle.Alloc(sNum);
#endif
			stack[2].s_int = iLength;
			interceptor.Invoke("dayStringToInteger$$", "dayStringToInteger(const QString&, int&) const", stack);
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[1].s_class);
#else
			((GCHandle) stack[1].s_class).Free();
#endif
			iLength = stack[2].s_int;
			return stack[0].s_int;
		}
		/// <remarks>
		///  Gets specific calendar type number of day of week number for a given
		///  date
		/// <param> name="date" gregorian date
		/// </param></remarks>		<return> day of week
		///    </return>
		/// 		<short>    Gets specific calendar type number of day of week number for a given  date </short>
		[SmokeMethod("dayOfWeek(const QDate&) const")]
		public abstract int DayOfWeek(QDate date);
		/// <remarks>
		///  Gets specific calendar type day number of year for a given date
		/// <param> name="date" gregorian date equivalent to the specific one
		/// </param></remarks>		<return> day number
		///    </return>
		/// 		<short>    Gets specific calendar type day number of year for a given date </short>
		[SmokeMethod("dayOfYear(const QDate&) const")]
		public abstract int DayOfYear(QDate date);
		/// <remarks>
		///  Changes the date's year, month and day. The range of the year, month
		///  and day depends on which calendar is being used.
		/// <param> name="date" Date to change
		/// </param><param> name="y" Year
		/// </param><param> name="m" Month number
		/// </param><param> name="d" Day of month
		/// </param></remarks>		<return> true if the date is valid; otherwise returns false.
		///    </return>
		/// 		<short>    Changes the date's year, month and day.</short>
		[SmokeMethod("setYMD(QDate&, int, int, int) const")]
		public abstract bool SetYMD(QDate date, int y, int m, int d);
		/// <remarks>
		///  Returns a QDate object containing a date nyears later.
		/// <param> name="date" The old date
		/// </param><param> name="nyears" The number of years to add
		/// </param></remarks>		<return> The new date
		///    </return>
		/// 		<short>    Returns a QDate object containing a date nyears later.</short>
		[SmokeMethod("addYears(const QDate&, int) const")]
		public abstract QDate AddYears(QDate date, int nyears);
		/// <remarks>
		///  Returns a QDate object containing a date nmonths later.
		/// <param> name="date" The old date
		/// </param><param> name="nmonths" The number of months to add
		/// </param></remarks>		<return> The new date
		///    </return>
		/// 		<short>    Returns a QDate object containing a date nmonths later.</short>
		[SmokeMethod("addMonths(const QDate&, int) const")]
		public abstract QDate AddMonths(QDate date, int nmonths);
		/// <remarks>
		///  Returns a QDate object containing a date ndays later.
		/// <param> name="date" The old date
		/// </param><param> name="ndays" The number of days to add
		/// </param></remarks>		<return> The new date
		///    </return>
		/// 		<short>    Returns a QDate object containing a date ndays later.</short>
		[SmokeMethod("addDays(const QDate&, int) const")]
		public abstract QDate AddDays(QDate date, int ndays);
		/// <remarks>
		///  Gets specific calendar type number of month for a given year
		/// <param> name="date" The date whose year to use
		/// </param></remarks>		<return> The number of months in that year
		///    </return>
		/// 		<short>    Gets specific calendar type number of month for a given year </short>
		[SmokeMethod("monthsInYear(const QDate&) const")]
		public abstract int MonthsInYear(QDate date);
		/// <remarks>
		///  Gets the number of days in date whose years specified.
		/// <param> name="date" Gregorian date equivalent to the specific one
		/// </param></remarks>		<return> The number of days in year
		///    </return>
		/// 		<short>    Gets the number of days in date whose years specified.</short>
		[SmokeMethod("daysInYear(const QDate&) const")]
		public abstract int DaysInYear(QDate date);
		/// <remarks>
		///  Gets specific calendar type number of days in month for a given date
		/// <param> name="date" gregorian date
		/// </param></remarks>		<return> number of days for month in date
		///    </return>
		/// 		<short>    Gets specific calendar type number of days in month for a given date </short>
		[SmokeMethod("daysInMonth(const QDate&) const")]
		public abstract int DaysInMonth(QDate date);
		/// <remarks>
		///  Gets the number of weeks in a specified year
		/// <param> name="year" the year
		/// </param></remarks>		<return> number of weeks in year
		///    </return>
		/// 		<short>    Gets the number of weeks in a specified year </short>
		[SmokeMethod("weeksInYear(int) const")]
		public abstract int WeeksInYear(int year);
		/// <remarks>
		///  Gets specific calendar type week number for a given date
		/// <param> name="date" gregorian date
		/// </param><param> name="yearNum" The year the date belongs to
		/// </param></remarks>		<return> week number
		///    </return>
		/// 		<short>    Gets specific calendar type week number for a given date </short>
		[SmokeMethod("weekNumber(const QDate&, int*) const")]
		public abstract int WeekNumber(QDate date, ref int yearNum);
		/// <remarks>
		///  Gets specific calendar type month name for a given month number
		///  If an invalid month is specified, string() is returned.
		/// <param> name="month" The month number
		/// </param><param> name="year" The year the month belongs to
		/// </param><param> name="shortName" Specifies if the short month name should be used
		/// </param></remarks>		<return> The name of the month
		///    </return>
		/// 		<short>    Gets specific calendar type month name for a given month number  If an invalid month is specified, string() is returned.</short>
		[SmokeMethod("monthName(int, int, bool) const")]
		public abstract string MonthName(int month, int year, bool shortName);
		/// <remarks>
		///  Gets specific calendar type month name for a given gregorian date
		/// <param> name="date" Gregorian date
		/// </param><param> name="shortName" Specifies if the short month name should be used
		/// </param></remarks>		<return> The name of the month
		///    </return>
		/// 		<short>    Gets specific calendar type month name for a given gregorian date </short>
		[SmokeMethod("monthName(const QDate&, bool) const")]
		public abstract string MonthName(QDate date, bool shortName);
		/// <remarks>
		///  Returns a string containing the possessive form of the month name.
		///  ("of January", "of February", etc.)
		///  It's needed in long format dates in some languages.
		///  If an invalid month is specified, string() is returned.
		///  Note: this method is intended to be used by the localization system to
		///        format dates. Using this method directly in your application may result
		///        in the inability to localize it properly.
		/// <param> name="month" The month number
		/// </param><param> name="year" The year the month belongs to
		/// </param><param> name="shortName" Specifies if the short month name should be used
		/// </param></remarks>		<return> The possessive form of the name of the month
		///    </return>
		/// 		<short>    Returns a string containing the possessive form of the month name.</short>
		/// 		<see> KLocale.FormatDate</see>
		[SmokeMethod("monthNamePossessive(int, int, bool) const")]
		public abstract string MonthNamePossessive(int month, int year, bool shortName);
		/// <remarks>
		///  Returns a string containing the possessive form of the month name.
		///  ("of January", "of February", etc.)
		///  It's needed in long format dates in some languages.
		///  Note: this method is intended to be used by the localization system to
		///        format dates. Using this method directly in your application may result
		///        in the inability to localize it properly.
		/// <param> name="date" Gregorian date
		/// </param><param> name="shortName" Specifies if the short month name should be used
		/// </param></remarks>		<return> The possessive form of the name of the month
		///    </return>
		/// 		<short>    Returns a string containing the possessive form of the month name.</short>
		/// 		<see> KLocale.FormatDate</see>
		[SmokeMethod("monthNamePossessive(const QDate&, bool) const")]
		public abstract string MonthNamePossessive(QDate date, bool shortName);
		/// <remarks>
		///  Gets specific calendar type week day name
		///  If an invalid week day is specified, string() is returned.
		/// <param> name="weekDay" number of day in week (1 . Monday)
		/// </param><param> name="shortName" short or complete day name
		/// </param></remarks>		<return> day name
		///    </return>
		/// 		<short>    Gets specific calendar type week day name  If an invalid week day is specified, string() is returned.</short>
		[SmokeMethod("weekDayName(int, bool) const")]
		public abstract string WeekDayName(int weekDay, bool shortName);
		/// <remarks>
		///  Gets specific calendar type week day name
		/// <param> name="date" the date
		/// </param><param> name="shortName" short or complete day name
		/// </param></remarks>		<return> day name
		///    </return>
		/// 		<short>    Gets specific calendar type week day name </short>
		[SmokeMethod("weekDayName(const QDate&, bool) const")]
		public abstract string WeekDayName(QDate date, bool shortName);
		/// <remarks>
		///  Gets the first year value supported by specific calendar type
		///  algorithms.
		/// </remarks>		<return> first year supported
		///    </return>
		/// 		<short>    Gets the first year value supported by specific calendar type  algorithms.</short>
		[SmokeMethod("minValidYear() const")]
		public abstract int MinValidYear();
		/// <remarks>
		///  Gets the maximum year value supported by specific calendar type
		///  algorithms (QDate, 8000)
		/// </remarks>		<return> maximum year supported
		///    </return>
		/// 		<short>    Gets the maximum year value supported by specific calendar type  algorithms (QDate, 8000) </short>
		[SmokeMethod("maxValidYear() const")]
		public abstract int MaxValidYear();
		/// <remarks>
		///  Gets the day of the week traditionaly associated with pray
		/// </remarks>		<return> day number
		///    </return>
		/// 		<short>    Gets the day of the week traditionaly associated with pray </short>
		[SmokeMethod("weekDayOfPray() const")]
		public abstract int WeekDayOfPray();
		/// <remarks>
		///  Gets the string representing the calendar
		///    </remarks>		<short>    Gets the string representing the calendar    </short>
		[SmokeMethod("calendarName() const")]
		public abstract string CalendarName();
		/// <remarks>
		///  Gets if the calendar is lunar based
		/// </remarks>		<return> if the calendar is lunar based
		///    </return>
		/// 		<short>    Gets if the calendar is lunar based </short>
		[SmokeMethod("isLunar() const")]
		public abstract bool IsLunar();
		/// <remarks>
		///  Gets if the calendar is lunisolar based
		/// </remarks>		<return> if the calendar is lunisolar based
		///    </return>
		/// 		<short>    Gets if the calendar is lunisolar based </short>
		[SmokeMethod("isLunisolar() const")]
		public abstract bool IsLunisolar();
		/// <remarks>
		///  Gets if the calendar is solar based
		/// </remarks>		<return> if the calendar is solar based
		///    </return>
		/// 		<short>    Gets if the calendar is solar based </short>
		[SmokeMethod("isSolar() const")]
		public abstract bool IsSolar();
		protected KLocale Locale() {
			return (KLocale) interceptor.Invoke("locale", "locale() const", typeof(KLocale));
		}
		/// <remarks>
		///  Gets specific calendar type number of days in previous month for a
		///  given date
		/// <param> name="calType" string identification of the specific calendar type
		///  to be constructed
		/// </param><param> name="locale" Locale used for translations. Use the global locale when
		///  0 is specified.
		/// </param></remarks>		<return> a KCalendarSystem object
		///    </return>
		/// 		<short>    Gets specific calendar type number of days in previous month for a  given date </short>
		public static KCalendarSystem Create(string calType, KLocale locale) {
			return (KCalendarSystem) staticInterceptor.Invoke("create$#", "create(const QString&, const KLocale*)", typeof(KCalendarSystem), typeof(string), calType, typeof(KLocale), locale);
		}
		public static KCalendarSystem Create(string calType) {
			return (KCalendarSystem) staticInterceptor.Invoke("create$", "create(const QString&)", typeof(KCalendarSystem), typeof(string), calType);
		}
		public static KCalendarSystem Create() {
			return (KCalendarSystem) staticInterceptor.Invoke("create", "create()", typeof(KCalendarSystem));
		}
		/// <remarks>
		///  Gets list of names of supported calendar systems
		/// </remarks>		<return> A List<string> object
		///    </return>
		/// 		<short>    Gets list of names of supported calendar systems </short>
		public static List<string> CalendarSystems() {
			return (List<string>) staticInterceptor.Invoke("calendarSystems", "calendarSystems()", typeof(List<string>));
		}
	}
}
