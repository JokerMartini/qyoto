//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  A class for one specific group in a KConfig object.
	///  </remarks>		<short>    A class for one specific group in a KConfig object.</short>

	[SmokeClass("KConfigGroup")]
	public class KConfigGroup : KConfigFlags, IDisposable {
 		protected KConfigGroup(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KConfigGroup), this);
		}
		// KConfigGroup* KConfigGroup(KSharedConfigPtr arg1,const QByteArray& arg2); >>>> NOT CONVERTED
		// KConfigGroup* KConfigGroup(KSharedConfigPtr arg1,const QString& arg2); >>>> NOT CONVERTED
		// KConfigGroup* KConfigGroup(KSharedConfigPtr arg1,const char* arg2); >>>> NOT CONVERTED
		// void deleteGroup(WriteConfigFlags arg1); >>>> NOT CONVERTED
		// void putData(const KEntryKey& arg1,const KEntry& arg2,bool arg3); >>>> NOT CONVERTED
		// void putData(const KEntryKey& arg1,const KEntry& arg2); >>>> NOT CONVERTED
		// KEntry lookupData(const KEntryKey& arg1); >>>> NOT CONVERTED
		// template <typename T> T readEntry(const char* arg1,const T& arg2); >>>> NOT CONVERTED
		// template <typename T> T readEntry(const QString& arg1,const T& arg2); >>>> NOT CONVERTED
		// template <typename T> QList<T> readEntry(const char* arg1,const QList<T>& arg2); >>>> NOT CONVERTED
		// QVariantList readEntry(const char* arg1,const QVariantList& arg2); >>>> NOT CONVERTED
		// void writeEntry(const char* arg1,const QString& arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// void writeEntry(const char* arg1,const QVariant& arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// template <typename T> void writeEntry(const char* arg1,const T& arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// template <typename T> void writeEntry(const char* arg1,const T& arg2); >>>> NOT CONVERTED
		// template <typename T> void writeEntry(const QString& arg1,const T& arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// template <typename T> void writeEntry(const QString& arg1,const T& arg2); >>>> NOT CONVERTED
		// void writeEntry(const QString& arg1,const QStringList& arg2,char arg3,WriteConfigFlags arg4); >>>> NOT CONVERTED
		// void writeEntry(const char* arg1,const QStringList& arg2,char arg3,WriteConfigFlags arg4); >>>> NOT CONVERTED
		// template <typename T> void writeEntry(const char* arg1,const QList<T>& arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// template <typename T> void writeEntry(const char* arg1,const QList<T>& arg2); >>>> NOT CONVERTED
		// void writeEntry(const char* arg1,const QVariantList& arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// void writeEntry(const char* arg1,const char* arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// void writeEntry(const char* arg1,const QByteArray& arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// void writePathEntry(const QString& arg1,const QString& arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// void writePathEntry(const char* arg1,const QString& arg2,WriteConfigFlags arg3); >>>> NOT CONVERTED
		// void writePathEntry(const QString& arg1,const QStringList& arg2,char arg3,WriteConfigFlags arg4); >>>> NOT CONVERTED
		// void writePathEntry(const char* arg1,const QStringList& arg2,char arg3,WriteConfigFlags arg4); >>>> NOT CONVERTED
		// void deleteEntry(const QString& arg1,WriteConfigFlags arg2); >>>> NOT CONVERTED
		// void deleteEntry(const char* arg1,WriteConfigFlags arg2); >>>> NOT CONVERTED
		/// <remarks>
		///  Constructs a null group. A null group is invalid.
		///  \see isValid
		///      </remarks>		<short>    Constructs a null group.</short>
		public KConfigGroup() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfigGroup", "KConfigGroup()", typeof(void));
		}
		/// <remarks>
		///  Construct a config group corresponding to <code>group</code> in <code>master.</code>
		///  <code>group</code> is the group name encoded in UTF-8.
		///      </remarks>		<short>    Construct a config group corresponding to <code>group</code> in <code>master.</code></short>
		public KConfigGroup(KConfigBase master, QByteArray group) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfigGroup##", "KConfigGroup(KConfigBase*, const QByteArray&)", typeof(void), typeof(KConfigBase), master, typeof(QByteArray), group);
		}
		/// <remarks>
		///  This is an overloaded constructor provided for convenience.
		///  It behaves essentially like the above function.
		///  Construct a config group corresponding to <code>group</code> in <code>master</code>
		///      </remarks>		<short>    This is an overloaded constructor provided for convenience.</short>
		public KConfigGroup(KConfigBase master, string group) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfigGroup#$", "KConfigGroup(KConfigBase*, const QString&)", typeof(void), typeof(KConfigBase), master, typeof(string), group);
		}
		/// <remarks>
		///  Returns <pre>true</pre> if the group is valid; otherwise returns <pre>false</pre>. A group is invalid if it
		///  was constructed without arguments.
		///  You should not call any functions on an invalid group.
		///      </remarks>		<short>    Returns \p true if the group is valid; otherwise returns \p false.</short>
		public bool IsValid() {
			return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
		}
		/// <remarks>
		///  Delete all entries in the entire group
		/// <param> name="pFlags" flags passed to KConfigBase.DeleteGroup
		///      </param></remarks>		<short>    Delete all entries in the entire group </short>
		/// <remarks>
		///  Returns a map (tree) of entries for all entries in this group.
		///  Only the actual entry string is returned, none of the
		///  other internal data should be included.
		/// </remarks>		<return> A map of entries in this group, indexed by key.
		///      </return>
		/// 		<short>    Returns a map (tree) of entries for all entries in this group.</short>
		public Dictionary<string, string> EntryMap() {
			return (Dictionary<string, string>) interceptor.Invoke("entryMap", "entryMap() const", typeof(Dictionary<string, string>));
		}
		public void SetDirty(bool _bDirty) {
			interceptor.Invoke("setDirty$", "setDirty(bool)", typeof(void), typeof(bool), _bDirty);
		}
		public void Sync() {
			interceptor.Invoke("sync", "sync()", typeof(void));
		}
		/// <remarks>
		///  Changes the group of the object. This is a convenience function and should
		///  not be overused. Prefer another object for another group to avoid mixture of
		///  groups.
		///     </remarks>		<short>    Changes the group of the object.</short>
		public void ChangeGroup(string group) {
			interceptor.Invoke("changeGroup$", "changeGroup(const char*)", typeof(void), typeof(string), group);
		}
		public void ChangeGroup(QByteArray group) {
			interceptor.Invoke("changeGroup#", "changeGroup(const QByteArray&)", typeof(void), typeof(QByteArray), group);
		}
		public bool HasKey(string key) {
			return (bool) interceptor.Invoke("hasKey$", "hasKey(const char*) const", typeof(bool), typeof(string), key);
		}
		public KConfigGroup(KConfigGroup arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KConfigGroup#", "KConfigGroup(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), arg1);
		}
		public string Group() {
			return (string) interceptor.Invoke("group", "group() const", typeof(string));
		}
		public bool Exists() {
			return (bool) interceptor.Invoke("exists", "exists() const", typeof(bool));
		}
		/// <remarks>
		///  Return the config object behind this group.
		///      </remarks>		<short>    Return the config object behind this group.</short>
		public KConfigBase Config() {
			return (KConfigBase) interceptor.Invoke("config", "config() const", typeof(KConfigBase));
		}
		/// <remarks>
		///  Reads the value of an entry specified by <code>pKey</code> in the current group.
		///  If you want to read a path, please use readPathEntry().
		/// <param> name="pKey" The key to search for.
		/// </param><param> name="aDefault" A default value returned if the key was not found.
		/// </param></remarks>		<return> The value for this key. Can be string() if aDefault is null.
		///      </return>
		/// 		<short>    Reads the value of an entry specified by <code>pKey</code> in the current group.</short>
		public string ReadEntry(string pKey, string aDefault) {
			return (string) interceptor.Invoke("readEntry$$", "readEntry(const char*, const QString&) const", typeof(string), typeof(string), pKey, typeof(string), aDefault);
		}
		public string ReadEntry(string pKey) {
			return (string) interceptor.Invoke("readEntry$", "readEntry(const char*) const", typeof(string), typeof(string), pKey);
		}
		/// <remarks>
		///  Reads the value of an entry specified by <code>pKey</code> in the current group.
		///  The value is treated as if it is of the type of the given default value.
		///  @note Only the following QVariant types are allowed : String,
		///  StringList, List, Font, Point, Rect, Size, Color, Int, UInt, Bool,
		///  Double, LongLong, ULongLong, DateTime and Date.
		/// <param> name="pKey" The key to search for.
		/// </param><param> name="aDefault" A default value returned if the key was not found or
		///  if the read value cannot be converted to the QVariant.Type.
		/// </param></remarks>		<return> The value for the key or the default value if the key was not
		///          found.
		///      </return>
		/// 		<short>    Reads the value of an entry specified by <code>pKey</code> in the current group.</short>
		public QVariant ReadEntry(string pKey, QVariant aDefault) {
			return (QVariant) interceptor.Invoke("readEntry$#", "readEntry(const char*, const QVariant&) const", typeof(QVariant), typeof(string), pKey, typeof(QVariant), aDefault);
		}
		/// <remarks>
		///  Reads the value of an entry specified by <code>pKey</code> in the current group.
		///  This template method makes it possible to write
		///     string foo = readEntry("...", string("default"));
		///  and the same with all other types supported by QVariant.
		///  The return type of the method is simply the same as the type of the default value.
		///  @note readEntry("...", Qt.White) cannot compile because Qt.White is an enum.
		///  You must turn it into readEntry("...", QColor(Qt.White)).
		/// <param> name="pKey" The key to search for.
		/// </param><param> name="aDefault" A default value returned if the key was not found.
		/// </param></remarks>		<return> The value for this key, or <code>aDefault.</code>
		///      </return>
		/// 		<short>    Reads the value of an entry specified by <code>pKey</code> in the current group.</short>
		/// <remarks>
		///  Reads a list from the config object.
		///  @note This function only works for those types that QVariant can convert
		///  from string.
		/// <param> name="pKey" The key to search for.
		/// </param><param> name="aDefault" The default value to use if the key does not exist.
		/// </param></remarks>		<return> The list.
		///      </return>
		/// 		<short>    Reads a list from the config object.</short>
		/// <remarks>
		///  Reads a list from the config object.
		///  @copydoc readEntry(string, const QList<T>&) const
		///  @warning This function doesn't convert the items returned
		///           to any type. It's actually a list of QVariant.String's. If you
		///           want the items converted to a specific type use
		///           readEntry(string, const QList<T>&) const
		///      </remarks>		<short>    Reads a list from the config object.</short>
		/// <remarks>
		///  Reads a list of strings from the config object.
		/// <param> name="pKey" The key to search for.
		/// </param><param> name="aDefault" The default value to use if the key does not exist.
		/// </param><param> name="sep" The list separator.
		/// </param></remarks>		<return> The list. Contains <code>aDefault</code> if <code>pKey</code> does not exist.
		///      </return>
		/// 		<short>    Reads a list of strings from the config object.</short>
		public List<string> ReadEntry(string pKey, List<string> aDefault, char sep) {
			return (List<string>) interceptor.Invoke("readEntry$?$", "readEntry(const char*, const QStringList&, char) const", typeof(List<string>), typeof(string), pKey, typeof(List<string>), aDefault, typeof(char), sep);
		}
		public List<string> ReadEntry(string pKey, List<string> aDefault) {
			return (List<string>) interceptor.Invoke("readEntry$?", "readEntry(const char*, const QStringList&) const", typeof(List<string>), typeof(string), pKey, typeof(List<string>), aDefault);
		}
		/// <remarks>
		///  Reads a path.
		///  Read the value of an entry specified by <code>pKey</code> in the current group
		///  and interpret it as a path. This means, dollar expansion is activated
		///  for this value, so that e.g. $HOME gets expanded.
		/// <param> name="pKey" The key to search for.
		/// </param><param> name="aDefault" A default value returned if the key was not found.
		/// </param></remarks>		<return> The value for this key. Can be string() if aDefault is null.
		///      </return>
		/// 		<short>    Reads a path.</short>
		public string ReadPathEntry(string pKey, string aDefault) {
			return (string) interceptor.Invoke("readPathEntry$$", "readPathEntry(const QString&, const QString&) const", typeof(string), typeof(string), pKey, typeof(string), aDefault);
		}
		public string ReadPathEntry(string pKey) {
			return (string) interceptor.Invoke("readPathEntry$", "readPathEntry(const QString&) const", typeof(string), typeof(string), pKey);
		}
		/// <remarks>
		///  Reads a list of string paths.
		///  Read the value of an entry specified by <code>pKey</code> in the current group
		///  and interpret it as a list of paths. This means, dollar expansion is activated
		///  for this value, so that e.g. $HOME gets expanded.
		/// <param> name="pKey" The key to search for.
		/// </param><param> name="sep" The list separator (default is ",").
		/// </param></remarks>		<return> The list. Empty if the entry does not exist.
		///      </return>
		/// 		<short>    Reads a list of string paths.</short>
		public List<string> ReadPathListEntry(string pKey, char sep) {
			return (List<string>) interceptor.Invoke("readPathListEntry$$", "readPathListEntry(const QString&, char) const", typeof(List<string>), typeof(string), pKey, typeof(char), sep);
		}
		public List<string> ReadPathListEntry(string pKey) {
			return (List<string>) interceptor.Invoke("readPathListEntry$", "readPathListEntry(const QString&) const", typeof(List<string>), typeof(string), pKey);
		}
		/// <remarks>
		///  Reads the value of an entry specified by <code>pKey</code> in the current group.
		///  The untranslated entry is returned, you normally do not need this.
		/// <param> name="pKey" The key to search for.
		/// </param><param> name="aDefault" A default value returned if the key was not found.
		/// </param></remarks>		<return> The value for this key.
		///      </return>
		/// 		<short>    Reads the value of an entry specified by <code>pKey</code> in the current group.</short>
		public string ReadEntryUntranslated(string pKey, string aDefault) {
			return (string) interceptor.Invoke("readEntryUntranslated$$", "readEntryUntranslated(const QString&, const QString&) const", typeof(string), typeof(string), pKey, typeof(string), aDefault);
		}
		public string ReadEntryUntranslated(string pKey) {
			return (string) interceptor.Invoke("readEntryUntranslated$", "readEntryUntranslated(const QString&) const", typeof(string), typeof(string), pKey);
		}
		/// <remarks>
		///  Writes a key/value pair.
		///  This is stored in the most specific config file when destroying the
		///  config object or when calling sync().
		///  If you want to write a path, please use writePathEntry().
		/// <param> name="pKey" The key to write.
		/// </param><param> name="value" The value to write.
		/// </param><param> name="pFlags" The flags to use when writing this entry.
		///      </param></remarks>		<short>    Writes a key/value pair.</short>
		public void WriteEntry(string pKey, string value) {
			interceptor.Invoke("writeEntry$$", "writeEntry(const char*, const QString&)", typeof(void), typeof(string), pKey, typeof(string), value);
		}
		/// <remarks>
		///  writeEntry() Overridden to accept a property.
		/// <param> name="pKey" The key to write
		/// </param><param> name="value" The property to write
		/// </param><param> name="pFlags" The flags to use when writing this entry.
		/// </param></remarks>		<short>    writeEntry() Overridden to accept a property.</short>
		/// 		<see> writeEntry</see>
		public void WriteEntry(string pKey, QVariant value) {
			interceptor.Invoke("writeEntry$#", "writeEntry(const char*, const QVariant&)", typeof(void), typeof(string), pKey, typeof(QVariant), value);
		}
		/// <remarks>
		///  @copydoc writeEntry( string, string, WriteConfigFlags )
		///      </remarks>		<short>    @copydoc writeEntry( const char , string, WriteConfigFlags )      </short>
		/// <remarks>
		///  writeEntry() overridden to accept a list of strings.
		/// <param> name="pKey" The key to write
		/// </param><param> name="value" The list to write
		/// </param><param> name="sep" The list separator (default is ",").
		/// </param><param> name="pFlags" The flags to use when writing this entry.
		/// </param></remarks>		<short>    writeEntry() overridden to accept a list of strings.</short>
		/// 		<see> writeEntry</see>
		public void WriteEntry(string pKey, List<string> value, char sep) {
			interceptor.Invoke("writeEntry$?$", "writeEntry(const QString&, const QStringList&, char)", typeof(void), typeof(string), pKey, typeof(List<string>), value, typeof(char), sep);
		}
		public void WriteEntry(string pKey, List<string> value) {
			interceptor.Invoke("writeEntry$?", "writeEntry(const QString&, const QStringList&)", typeof(void), typeof(string), pKey, typeof(List<string>), value);
		}
		/// <remarks>
		///  writeEntry() overridden to accept a list.
		/// <param> name="pKey" The key to write
		/// </param><param> name="value" The list to write.
		/// </param><param> name="pFlags" The flags to use when writing this entry.
		/// </param></remarks>		<short>    writeEntry() overridden to accept a list.</short>
		/// 		<see> writeEntry</see>
		/// <remarks>
		///  writeEntry() overridden to accept a list of variants.
		///  @copydoc writeEntry(string, const QList<T>&, WriteConfigFlags)
		///      </remarks>		<short>    writeEntry() overridden to accept a list of variants.</short>
		public void WriteEntry(string pKey, List<QVariant> value) {
			interceptor.Invoke("writeEntry$?", "writeEntry(const char*, const QVariantList&)", typeof(void), typeof(string), pKey, typeof(List<QVariant>), value);
		}
		/// <remarks>
		///  Write a (key/value) pair where the value is a QByteArray.
		///  This is stored to the most specific config file when destroying the
		///  config object or when calling sync().
		/// <param> name="pKey" The key to write.
		/// </param><param> name="value" The value to write; assumed to be in latin1 encoding.
		///                     If it contains the null character between 0 and size()-1,
		///                     the string will be truncated at the null character.
		/// </param><param> name="pFlags" The flags to use when writing this entry.
		///      </param></remarks>		<short>    Write a (key/value) pair where the value is a QByteArray.</short>
		public void WriteEntry(string pKey, QByteArray value) {
			interceptor.Invoke("writeEntry$#", "writeEntry(const char*, const QByteArray&)", typeof(void), typeof(string), pKey, typeof(QByteArray), value);
		}
		/// <remarks>
		///  Writes a file path.
		///  It is checked whether the path is located under $HOME. If so the
		///  path is written out with the user's home-directory replaced with
		///  $HOME. The path should be read back with readPathEntry()
		/// <param> name="pKey" The key to write.
		/// </param><param> name="path" The path to write.
		/// </param><param> name="pFlags" The flags to use when writing this entry.
		///      </param></remarks>		<short>    Writes a file path.</short>
		public void WritePathEntry(string pKey, string path) {
			interceptor.Invoke("writePathEntry$$", "writePathEntry(const QString&, const QString&)", typeof(void), typeof(string), pKey, typeof(string), path);
		}
		/// <remarks>
		///  writePathEntry() overridden to accept a list of paths (strings).
		///  It is checked whether the paths are located under $HOME. If so each of
		///  the paths are written out with the user's home-directory replaced with
		///  $HOME. The paths should be read back with readPathListEntry()
		/// <param> name="pKey" The key to write
		/// </param><param> name="value" The list to write
		/// </param><param> name="sep" The list separator (default is ",").
		/// </param><param> name="pFlags" The flags to use when writing this entry.
		/// </param></remarks>		<short>    writePathEntry() overridden to accept a list of paths (strings).</short>
		/// 		<see> writePathEntry</see>
		/// 		<see> readPathListEntry</see>
		public void WritePathEntry(string pKey, List<string> value, char sep) {
			interceptor.Invoke("writePathEntry$?$", "writePathEntry(const QString&, const QStringList&, char)", typeof(void), typeof(string), pKey, typeof(List<string>), value, typeof(char), sep);
		}
		public void WritePathEntry(string pKey, List<string> value) {
			interceptor.Invoke("writePathEntry$?", "writePathEntry(const QString&, const QStringList&)", typeof(void), typeof(string), pKey, typeof(List<string>), value);
		}
		/// <remarks>
		///  Deletes the entry specified by <code>pKey</code> in the current group.
		/// <param> name="pKey" The key to delete.
		/// </param><param> name="pFlags" The flags to use when deleting this entry.
		///      </param></remarks>		<short>    Deletes the entry specified by <code>pKey</code> in the current group.</short>
		public void DeleteEntry(string pKey) {
			interceptor.Invoke("deleteEntry$", "deleteEntry(const QString&)", typeof(void), typeof(string), pKey);
		}
		/// <remarks>
		///  Checks whether it is possible to change the given group.
		/// </remarks>		<return> whether changes may be made to this group in this configuration
		///  file.
		///      </return>
		/// 		<short>    Checks whether it is possible to change the given group.</short>
		public bool IsImmutable() {
			return (bool) interceptor.Invoke("isImmutable", "isImmutable() const", typeof(bool));
		}
		/// <remarks>
		///  Checks whether it is possible to change the given entry.
		/// <param> name="key" the key to check
		/// </param></remarks>		<return> whether the entry <code>key</code> may be changed in the current group
		///  in this configuration file.
		///      </return>
		/// 		<short>    Checks whether it is possible to change the given entry.</short>
		public bool EntryIsImmutable(string key) {
			return (bool) interceptor.Invoke("entryIsImmutable$", "entryIsImmutable(const QString&) const", typeof(bool), typeof(string), key);
		}
		/// <remarks>
		///  When set, all readEntry and readXXXEntry calls return the system
		///  wide (default) values instead of the user's preference.
		///  This is off by default.
		///      </remarks>		<short>    When set, all readEntry and readXXXEntry calls return the system  wide (default) values instead of the user's preference.</short>
		public void SetReadDefaults(bool b) {
			interceptor.Invoke("setReadDefaults$", "setReadDefaults(bool)", typeof(void), typeof(bool), b);
		}
		/// <remarks>
		///  Reverts the entry with key <code>key</code> in the current group in the
		///  application specific config file to either the system wide (default)
		///  value or the value specified in the global KDE config file.
		///  To revert entries in the global KDE config file, the global KDE config
		///  file should be opened explicitly in a separate config object.
		/// <param> name="key" The key of the entry to revert.
		///      </param></remarks>		<short>    Reverts the entry with key <code>key</code> in the current group in the  application specific config file to either the system wide (default)  value or the value specified in the global KDE config file.</short>
		public void RevertToDefault(string key) {
			interceptor.Invoke("revertToDefault$", "revertToDefault(const QString&)", typeof(void), typeof(string), key);
		}
		/// <remarks>
		///  Returns whether a default is specified for an entry in either the
		///  system wide configuration file or the global KDE config file.
		///  If an application computes a default value at runtime for
		///  a certain entry, e.g. like:
		///  <pre>
		///  QColor computedDefault = qApp.Palette().color(QPalette.Active, QPalette.Text)
		///  QColor color = config.ReadEntry(key, computedDefault).value<QColor>();
		///  \encode
		///  Then it may wish to make the following check before
		///  writing back changes:
		///  <pre>
		///  if ( (value == computedDefault) && !config.HasDefault(key) )
		///     config.RevertToDefault(key)
		///  else
		///     config.WriteEntry(key, value)
		///  </pre>
		///  This ensures that as long as the entry is not modified to differ from
		///  the computed default, the application will keep using the computed default
		///  and will follow changes the computed default makes over time.
		/// <param> name="key" The key of the entry to check.
		///      </param></remarks>		<short>    Returns whether a default is specified for an entry in either the  system wide configuration file or the global KDE config file.</short>
		public bool HasDefault(string key) {
			return (bool) interceptor.Invoke("hasDefault$", "hasDefault(const QString&) const", typeof(bool), typeof(string), key);
		}
		protected QByteArray ReadEntryUtf8(string pKey) {
			return (QByteArray) interceptor.Invoke("readEntryUtf8$", "readEntryUtf8(const char*) const", typeof(QByteArray), typeof(string), pKey);
		}
		protected void Init(KConfigBase master) {
			interceptor.Invoke("init#", "init(KConfigBase*)", typeof(void), typeof(KConfigBase), master);
		}
		~KConfigGroup() {
			interceptor.Invoke("~KConfigGroup", "~KConfigGroup()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KConfigGroup", "~KConfigGroup()", typeof(void));
		}
	}
}
