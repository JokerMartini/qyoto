//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  Information about a plugin.
	///  This holds all the information about a plugin there is. It's used for the
	///  user to decide whether he wants to use this plugin or not.
	/// </remarks>		<author> Matthias Kretz <kretz@kde.org>
	///  </author>
	/// 		<short>    Information about a plugin.</short>

	[SmokeClass("KPluginInfo")]
	public class KPluginInfo : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KPluginInfo(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KPluginInfo), this);
		}
		// KPluginInfo* KPluginInfo(const KService::Ptr arg1); >>>> NOT CONVERTED
		// KService::Ptr service(); >>>> NOT CONVERTED
		// QList<KService::Ptr> kcmServices(); >>>> NOT CONVERTED
		// KPluginInfo::List fromServices(const KService::List& arg1,const KConfigGroup& arg2); >>>> NOT CONVERTED
		// KPluginInfo::List fromServices(const KService::List& arg1); >>>> NOT CONVERTED
		// KPluginInfo::List fromFiles(const QStringList& arg1,const KConfigGroup& arg2); >>>> NOT CONVERTED
		// KPluginInfo::List fromFiles(const QStringList& arg1); >>>> NOT CONVERTED
		// KPluginInfo::List fromKPartsInstanceName(const QString& arg1,const KConfigGroup& arg2); >>>> NOT CONVERTED
		// KPluginInfo::List fromKPartsInstanceName(const QString& arg1); >>>> NOT CONVERTED
		/// <remarks>
		///  Read plugin info from <code>filename.</code>
		///  The file should be of the following form:
		///  <pre>
		///            [Desktop Entry]
		///            Encoding=UTF-8
		///            Icon=mypluginicon
		///            Type=Service
		///            ServiceTypes=KPluginInfo
		///            Name=User Visible Name
		///            Comment=Description of what the plugin does
		///            X-KDE-PluginInfo-Author=Author's Name
		///            X-KDE-PluginInfo-Email=author@foo.bar
		///            X-KDE-PluginInfo-Name=internalname
		///            X-KDE-PluginInfo-Version=1.1
		///            X-KDE-PluginInfo-Website=http://www.plugin.org/
		///            X-KDE-PluginInfo-Category=playlist
		///            X-KDE-PluginInfo-Depends=plugin1,plugin3
		///            X-KDE-PluginInfo-License=GPL
		///            X-KDE-PluginInfo-EnabledByDefault=true
		///            </pre>
		///  The Name and Comment fields must always be present.
		///  The "X-KDE-PluginInfo" keys you may add further entries which
		///  will be available using property(). The Website,Category,Require
		///  keys are optional.
		///  For EnabledByDefault look at isPluginEnabledByDefault.
		/// <param> name="filename" The filename of the .desktop file.
		/// </param><param> name="resource" If filename is relative, you need to specify a resource type
		///  (e.g. "service", "apps"... KStandardDirs). Otherwise,
		///  resource isn't used.
		///          </param></remarks>		<short>    Read plugin info from <code>filename.</code></short>
		public KPluginInfo(string filename, string resource) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPluginInfo$$", "KPluginInfo(const QString&, const char*)", typeof(void), typeof(string), filename, typeof(string), resource);
		}
		public KPluginInfo(string filename) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KPluginInfo$", "KPluginInfo(const QString&)", typeof(void), typeof(string), filename);
		}
		/// <remarks>
		///  Read plugin info from a KService object.
		///  The .desktop file should look like this:
		///  <pre>
		///            [Desktop Entry]
		///            Encoding=UTF-8
		///            Icon=mypluginicon
		///            Type=Service
		///            ServiceTypes=KPluginInfo
		///            X-KDE-PluginInfo-Author=Author's Name
		///            X-KDE-PluginInfo-Email=author@foo.bar
		///            X-KDE-PluginInfo-Name=internalname
		///            X-KDE-PluginInfo-Version=1.1
		///            X-KDE-PluginInfo-Website=http://www.plugin.org/
		///            X-KDE-PluginInfo-Category=playlist
		///            X-KDE-PluginInfo-Depends=plugin1,plugin3
		///            X-KDE-PluginInfo-License=GPL
		///            X-KDE-PluginInfo-EnabledByDefault=true
		///            Name=User Visible Name
		///            Comment=Description of what the plugin does
		///            </pre>
		///  In the first three entries the Icon entry is optional.
		///          </remarks>		<short>    Read plugin info from a KService object.</short>
		/// <remarks>
		/// </remarks>		<return> Whether the plugin should be hidden.
		///          </return>
		/// 		<short>   </short>
		public bool IsHidden() {
			return (bool) interceptor.Invoke("isHidden", "isHidden() const", typeof(bool));
		}
		/// <remarks>
		///  Set whether the plugin is currently loaded.
		///  You might need to reimplement this method for special needs.
		/// </remarks>		<short>    Set whether the plugin is currently loaded.</short>
		/// 		<see> isPluginEnabled</see>
		/// 		<see> save</see>
		[SmokeMethod("setPluginEnabled(bool)")]
		public virtual void SetPluginEnabled(bool enabled) {
			interceptor.Invoke("setPluginEnabled$", "setPluginEnabled(bool)", typeof(void), typeof(bool), enabled);
		}
		/// <remarks>
		///  You might need to reimplement this method for special needs.
		/// </remarks>		<return> Whether the plugin is currently loaded.
		/// </return>
		/// 		<short>   </short>
		/// 		<see> setPluginEnabled</see>
		/// 		<see> load</see>
		[SmokeMethod("isPluginEnabled() const")]
		public virtual bool IsPluginEnabled() {
			return (bool) interceptor.Invoke("isPluginEnabled", "isPluginEnabled() const", typeof(bool));
		}
		/// <remarks>
		/// </remarks>		<return> The default value whether the plugin is enabled or not.
		///  Defaults to the value set in the desktop file, or if that isn't set
		///  to false.
		///          </return>
		/// 		<short>   </short>
		public bool IsPluginEnabledByDefault() {
			return (bool) interceptor.Invoke("isPluginEnabledByDefault", "isPluginEnabledByDefault() const", typeof(bool));
		}
		/// <remarks>
		/// </remarks>		<return> The value associated the the <code>key.</code> You can use it if you
		///          want to read custom values. To do this you need to define
		///          your own servicetype and add it to the ServiceTypes keys.
		/// </return>
		/// 		<short>   </short>
		/// 		<see> operator[]</see>
		public QVariant Property(string key) {
			return (QVariant) interceptor.Invoke("property$", "property(const QString&) const", typeof(QVariant), typeof(string), key);
		}
		/// <remarks>
		/// </remarks>		<return> The user visible name of the plugin.
		///          </return>
		/// 		<short>   </short>
		public string Name() {
			return (string) interceptor.Invoke("name", "name() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> A comment describing the plugin.
		///          </return>
		/// 		<short>   </short>
		public string Comment() {
			return (string) interceptor.Invoke("comment", "comment() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The iconname for this plugin
		///          </return>
		/// 		<short>   </short>
		public string Icon() {
			return (string) interceptor.Invoke("icon", "icon() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The file containing the information about the plugin.
		///          </return>
		/// 		<short>   </short>
		public string Specfile() {
			return (string) interceptor.Invoke("specfile", "specfile() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The author of this plugin.
		///          </return>
		/// 		<short>   </short>
		public string Author() {
			return (string) interceptor.Invoke("author", "author() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The email address of the author.
		///          </return>
		/// 		<short>   </short>
		public string Email() {
			return (string) interceptor.Invoke("email", "email() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The category of this plugin (e.g. playlist/skin).
		///          </return>
		/// 		<short>   </short>
		public string Category() {
			return (string) interceptor.Invoke("category", "category() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The internal name of the plugin (for KParts Plugins this is
		///  the same name as set in the .rc file).
		///          </return>
		/// 		<short>   </short>
		public string PluginName() {
			return (string) interceptor.Invoke("pluginName", "pluginName() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The version of the plugin.
		///          </return>
		/// 		<short>   </short>
		public string Version() {
			return (string) interceptor.Invoke("version", "version() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The website of the plugin/author.
		///          </return>
		/// 		<short>   </short>
		public string Website() {
			return (string) interceptor.Invoke("website", "website() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> The license of this plugin.
		///          </return>
		/// 		<short>   </short>
		public string License() {
			return (string) interceptor.Invoke("license", "license() const", typeof(string));
		}
		/// <remarks>
		/// </remarks>		<return> A list of plugins required for this plugin to be enabled. Use
		///          the pluginName in this list.
		///          </return>
		/// 		<short>   </short>
		public List<string> Dependencies() {
			return (List<string>) interceptor.Invoke("dependencies", "dependencies() const", typeof(List<string>));
		}
		/// <remarks>
		/// </remarks>		<return> The KService object for this plugin. You might need it if you
		///          want to read custom values. To do this you need to define
		///          your own servicetype and add it to the ServiceTypes keys.
		///          Then you can use the KService.Property() method to read your
		///          keys.
		/// </return>
		/// 		<short>   </short>
		/// 		<see> property</see>
		/// <remarks>
		/// </remarks>		<return> A list of Service pointers if the plugin installs one or more
		///          KCModule
		///          </return>
		/// 		<short>   </short>
		/// <remarks>
		///  Set the KConfigGroup to use for load()ing and save()ing the
		///  configuration. This will be overridden by the KConfigGroup passed to
		///  save() or load() (if one is passed).
		///          </remarks>		<short>    Set the KConfigGroup to use for load()ing and save()ing the  configuration.</short>
		public void SetConfig(KConfigGroup config) {
			interceptor.Invoke("setConfig#", "setConfig(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
		}
		/// <remarks>
		/// </remarks>		<return> If the KPluginInfo object has a KConfig object set return
		///  it, else return 0.
		///          </return>
		/// 		<short>   </short>
		public KConfigGroup Config() {
			return (KConfigGroup) interceptor.Invoke("config", "config() const", typeof(KConfigGroup));
		}
		/// <remarks>
		///  Save state of the plugin - enabled or not. This function is provided
		///  for reimplementation if you need to save somewhere else.
		/// <param> name="config" The KConfigGroup holding the information whether
		///                   plugin is enabled.
		///          </param></remarks>		<short>    Save state of the plugin - enabled or not.</short>
		[SmokeMethod("save(KConfigGroup)")]
		public virtual void Save(KConfigGroup config) {
			interceptor.Invoke("save#", "save(KConfigGroup)", typeof(void), typeof(KConfigGroup), config);
		}
		[SmokeMethod("save()")]
		public virtual void Save() {
			interceptor.Invoke("save", "save()", typeof(void));
		}
		/// <remarks>
		///  Load the state of the plugin - enabled or not. This function is provided
		///  for reimplementation if you need to save somewhere else.
		/// <param> name="config" The KConfigGroup holding the information whether
		///                   plugin is enabled.
		///          </param></remarks>		<short>    Load the state of the plugin - enabled or not.</short>
		[SmokeMethod("load(const KConfigGroup&)")]
		public virtual void Load(KConfigGroup config) {
			interceptor.Invoke("load#", "load(const KConfigGroup&)", typeof(void), typeof(KConfigGroup), config);
		}
		[SmokeMethod("load()")]
		public virtual void Load() {
			interceptor.Invoke("load", "load()", typeof(void));
		}
		/// <remarks>
		///  Restore defaults (enabled or not).
		///          </remarks>		<short>    Restore defaults (enabled or not).</short>
		[SmokeMethod("defaults()")]
		public virtual void Defaults() {
			interceptor.Invoke("defaults", "defaults()", typeof(void));
		}
		~KPluginInfo() {
			interceptor.Invoke("~KPluginInfo", "~KPluginInfo()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KPluginInfo", "~KPluginInfo()", typeof(void));
		}
		/// <remarks>
		/// <param> name="services" The list of services to construct the list of KPluginInfo objects from
		/// </param><param> name="config" The config group where to save/load whether the plugin is enabled/disabled
		///          </param></remarks>		<return> A list of KPluginInfo objects constructed from a list of
		///  KService objects. If you get a trader offer of the plugins you want
		///  to use you can just pass them to this function.
		/// </return>
		/// 		<short>   </short>
		/// <remarks>
		/// <param> name="files" The list of files to construct the list of KPluginInfo objects from
		/// </param><param> name="config" The config group where to save/load whether the plugin is enabled/disabled
		///          </param></remarks>		<return> A list of KPluginInfo objects constructed from a list of
		///  filenames. If you make a lookup using, for example,
		///  KStandardDirs.FindAllResources() you pass the list of files to this
		///  function.
		/// </return>
		/// 		<short>   </short>
		/// <remarks>
		/// <param> name="componentName" Use the component name to look up all KParts plugins for it.
		/// </param><param> name="config" The config group where to save/load whether the plugin is enabled/disabled
		///          </param></remarks>		<return> A list of KPluginInfo objects for the KParts plugins of a
		///  component. You only need the name of the component not a pointer to the
		///  KComponentData object.
		/// </return>
		/// 		<short>   </short>
	}
}
