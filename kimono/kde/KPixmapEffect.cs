//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  Provides various pixmap-based graphical effects.
	///  </remarks>		<short>    Provides various pixmap-based graphical effects.</short>

	[SmokeClass("KPixmapEffect")]
	public class KPixmapEffect : Object {
		protected SmokeInvocation interceptor = null;
		private static SmokeInvocation staticInterceptor = null;
		static KPixmapEffect() {
			staticInterceptor = new SmokeInvocation(typeof(KPixmapEffect), null);
		}
		/// <remarks> 
		///  Gradient types. This enum is used when either drawing
		///  a gradient explicitly or when blending a pixmap into 
		///  a background.
		/// </remarks>		<short>     Gradient types.</short>
		/// 		<see> gradient</see>
		/// 		<see> unbalancedGradient</see>
		/// 		<see> blend</see>
		public enum GradientType {
			VerticalGradient = 0,
			HorizontalGradient = 1,
			DiagonalGradient = 2,
			CrossDiagonalGradient = 3,
			PyramidGradient = 4,
			RectangleGradient = 5,
			PipeCrossGradient = 6,
			EllipticGradient = 7,
		}
		/// <remarks>
		///  RGB color space channels.
		/// </remarks>		<short>    RGB color space channels.</short>
		/// 		<see> channelIntensity</see>
		public enum RGBComponent {
			Red = 0,
			Green = 1,
			Blue = 2,
		}
		/// <remarks>
		///  Direction lighting is from, for certain effects. These
		///  are the eight cardinal directions.
		/// </remarks>		<short>    Direction lighting is from, for certain effects.</short>
		/// 		<see> hash</see>
		/// 		<see> @todo</see>
		/// 		<see> Define</see>
		/// 		<see> which</see>
		/// 		<see> direction</see>
		/// 		<see> is</see>
		/// 		<see> North</see>
		/// 		<see> is</see>
		/// 		<see> that</see>
		/// 		<see> towards</see>
		/// 		<see> 0</see>
		/// 		<see> on</see>
		/// 		<see> the</see>
		/// 		<see> Y</see>
		/// 		<see> axis</see>
		/// 		<see> in</see>
		/// 		<see> a</see>
		/// 		<see> pixmap?</see>
		public enum Lighting {
			NorthLite = 0,
			NWLite = 1,
			WestLite = 2,
			SWLite = 3,
			SouthLite = 4,
			SELite = 5,
			EastLite = 6,
			NELite = 7,
		}
		/// <remarks>
		///  Creates a gradient from color a to color b of the specified type.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="ca" Color a.
		/// </param><param> name="cb" Color b.
		/// </param><param> name="type" The type of gradient.
		/// </param><param> name="ncols" The number of colors to use when not running on a
		///  truecolor display. The gradient will be dithered to this number of
		///  colors. Pass 0 to prevent dithering.
		/// </param></remarks>		<return> Returns the generated pixmap, for convenience.
		///      </return>
		/// 		<short>    Creates a gradient from color a to color b of the specified type.</short>
		public static QPixmap Gradient(QPixmap pixmap, QColor ca, QColor cb, KPixmapEffect.GradientType type, int ncols) {
			return (QPixmap) staticInterceptor.Invoke("gradient###$$", "gradient(QPixmap&, const QColor&, const QColor&, KPixmapEffect::GradientType, int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QColor), ca, typeof(QColor), cb, typeof(KPixmapEffect.GradientType), type, typeof(int), ncols);
		}
		public static QPixmap Gradient(QPixmap pixmap, QColor ca, QColor cb, KPixmapEffect.GradientType type) {
			return (QPixmap) staticInterceptor.Invoke("gradient###$", "gradient(QPixmap&, const QColor&, const QColor&, KPixmapEffect::GradientType)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QColor), ca, typeof(QColor), cb, typeof(KPixmapEffect.GradientType), type);
		}
		/// <remarks>
		///  Creates an unbalanced gradient.
		///  An unbalanced gradient is a gradient where the transition from
		///  color a to color b is not linear, but in this case, exponential.
		/// <param> name="pixmap" The pixmap that should be written.
		/// </param><param> name="ca" Color a.
		/// </param><param> name="cb" Color b.
		/// </param><param> name="type" The type of gradient.
		/// </param><param> name="xfactor" The x decay length. Use a value between -200 and 200.
		/// </param><param> name="yfactor" The y decay length.
		/// </param><param> name="ncols" The number of colors. See #gradient.
		/// </param></remarks>		<return> The generated pixmap, for convencience.
		///      </return>
		/// 		<short>    Creates an unbalanced gradient.</short>
		public static QPixmap UnbalancedGradient(QPixmap pixmap, QColor ca, QColor cb, KPixmapEffect.GradientType type, int xfactor, int yfactor, int ncols) {
			return (QPixmap) staticInterceptor.Invoke("unbalancedGradient###$$$$", "unbalancedGradient(QPixmap&, const QColor&, const QColor&, KPixmapEffect::GradientType, int, int, int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QColor), ca, typeof(QColor), cb, typeof(KPixmapEffect.GradientType), type, typeof(int), xfactor, typeof(int), yfactor, typeof(int), ncols);
		}
		public static QPixmap UnbalancedGradient(QPixmap pixmap, QColor ca, QColor cb, KPixmapEffect.GradientType type, int xfactor, int yfactor) {
			return (QPixmap) staticInterceptor.Invoke("unbalancedGradient###$$$", "unbalancedGradient(QPixmap&, const QColor&, const QColor&, KPixmapEffect::GradientType, int, int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QColor), ca, typeof(QColor), cb, typeof(KPixmapEffect.GradientType), type, typeof(int), xfactor, typeof(int), yfactor);
		}
		public static QPixmap UnbalancedGradient(QPixmap pixmap, QColor ca, QColor cb, KPixmapEffect.GradientType type, int xfactor) {
			return (QPixmap) staticInterceptor.Invoke("unbalancedGradient###$$", "unbalancedGradient(QPixmap&, const QColor&, const QColor&, KPixmapEffect::GradientType, int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QColor), ca, typeof(QColor), cb, typeof(KPixmapEffect.GradientType), type, typeof(int), xfactor);
		}
		public static QPixmap UnbalancedGradient(QPixmap pixmap, QColor ca, QColor cb, KPixmapEffect.GradientType type) {
			return (QPixmap) staticInterceptor.Invoke("unbalancedGradient###$", "unbalancedGradient(QPixmap&, const QColor&, const QColor&, KPixmapEffect::GradientType)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QColor), ca, typeof(QColor), cb, typeof(KPixmapEffect.GradientType), type);
		}
		/// <remarks>
		///  Creates a pixmap of a given size with the given pixmap.
		///  if the
		///  given size is bigger than the size of the pixmap, the pixmap is
		///  tiled.
		/// <param> name="pixmap" This is the source pixmap
		/// </param><param> name="size" The size the new pixmap should have.
		/// </param></remarks>		<return> The generated, tiled pixmap.
		///      </return>
		/// 		<short>    Creates a pixmap of a given size with the given pixmap.</short>
		public static QPixmap CreateTiled(QPixmap pixmap, QSize size) {
			return (QPixmap) staticInterceptor.Invoke("createTiled##", "createTiled(const QPixmap&, const QSize&)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QSize), size);
		}
		/// <remarks>
		///  Either brightens or dims a pixmap by a specified ratio.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="ratio" The ratio to use. Use negative value to dim.
		/// </param></remarks>		<return> Returns The pixmap(), provided for convenience.
		///      </return>
		/// 		<short>    Either brightens or dims a pixmap by a specified ratio.</short>
		public static QPixmap Intensity(QPixmap pixmap, float ratio) {
			return (QPixmap) staticInterceptor.Invoke("intensity#$", "intensity(QPixmap&, float)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(float), ratio);
		}
		/// <remarks>
		///  Modifies the intensity of a pixmap's RGB channel component.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="ratio" value. Use negative value to dim.
		/// </param><param> name="channel" Which channel(s) should be modified
		/// </param></remarks>		<return> Returns the pixmap(), provided for convenience.
		///      </return>
		/// 		<short>    Modifies the intensity of a pixmap's RGB channel component.</short>
		public static QPixmap ChannelIntensity(QPixmap pixmap, float ratio, KPixmapEffect.RGBComponent channel) {
			return (QPixmap) staticInterceptor.Invoke("channelIntensity#$$", "channelIntensity(QPixmap&, float, KPixmapEffect::RGBComponent)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(float), ratio, typeof(KPixmapEffect.RGBComponent), channel);
		}
		/// <remarks>
		///  Blends the provided pixmap into a background of the indicated color.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="initial_intensity" this parameter takes values from -1 to 1:
		/// </param>
		/// <li>
		/// If positive, it tells how much to fade the image in its
		///                               less affected spot.
		/// </li>
		/// 
		/// <li>
		/// If negative, it tells roughly indicates how much of the image
		///                               remains unaffected
		/// </li>
		/// <param> name="bgnd" Indicates the color of the background to blend in.
		/// </param><param> name="eff" Lets you choose what kind of blending you like.
		/// </param><param> name="anti_dir" Blend in the opposite direction (makes no much sense
		///                   with concentric blending effects).
		/// </param><param> name="ncols" The number of colors to dither the pixmap to. Only
		///                   used for 8 bpp pixmaps.
		/// </param></remarks>		<return> Returns the pixmap(), provided for convenience.
		///      </return>
		/// 		<short>    Blends the provided pixmap into a background of the indicated color.</short>
		public static QPixmap Blend(QPixmap pixmap, float initial_intensity, QColor bgnd, KPixmapEffect.GradientType eff, bool anti_dir, int ncols) {
			return (QPixmap) staticInterceptor.Invoke("blend#$#$$$", "blend(QPixmap&, float, const QColor&, KPixmapEffect::GradientType, bool, int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(float), initial_intensity, typeof(QColor), bgnd, typeof(KPixmapEffect.GradientType), eff, typeof(bool), anti_dir, typeof(int), ncols);
		}
		public static QPixmap Blend(QPixmap pixmap, float initial_intensity, QColor bgnd, KPixmapEffect.GradientType eff, bool anti_dir) {
			return (QPixmap) staticInterceptor.Invoke("blend#$#$$", "blend(QPixmap&, float, const QColor&, KPixmapEffect::GradientType, bool)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(float), initial_intensity, typeof(QColor), bgnd, typeof(KPixmapEffect.GradientType), eff, typeof(bool), anti_dir);
		}
		public static QPixmap Blend(QPixmap pixmap, float initial_intensity, QColor bgnd, KPixmapEffect.GradientType eff) {
			return (QPixmap) staticInterceptor.Invoke("blend#$#$", "blend(QPixmap&, float, const QColor&, KPixmapEffect::GradientType)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(float), initial_intensity, typeof(QColor), bgnd, typeof(KPixmapEffect.GradientType), eff);
		}
		/// <remarks>
		///  Builds a hash on any given pixmap.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="lite" The hash faces the indicated lighting (cardinal poles)
		/// </param><param> name="spacing" How many unmodified pixels inbetween hashes.
		/// </param><param> name="ncols" The number of colors to dither the pixmap to.
		///  Only used for 8 bpp pixmaps.
		/// </param></remarks>		<return> Returns The pixmap(), provided for convenience.
		///      </return>
		/// 		<short>    Builds a hash on any given pixmap.</short>
		public static QPixmap Hash(QPixmap pixmap, KPixmapEffect.Lighting lite, uint spacing, int ncols) {
			return (QPixmap) staticInterceptor.Invoke("hash#$$$", "hash(QPixmap&, KPixmapEffect::Lighting, unsigned int, int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(KPixmapEffect.Lighting), lite, typeof(uint), spacing, typeof(int), ncols);
		}
		public static QPixmap Hash(QPixmap pixmap, KPixmapEffect.Lighting lite, uint spacing) {
			return (QPixmap) staticInterceptor.Invoke("hash#$$", "hash(QPixmap&, KPixmapEffect::Lighting, unsigned int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(KPixmapEffect.Lighting), lite, typeof(uint), spacing);
		}
		public static QPixmap Hash(QPixmap pixmap, KPixmapEffect.Lighting lite) {
			return (QPixmap) staticInterceptor.Invoke("hash#$", "hash(QPixmap&, KPixmapEffect::Lighting)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(KPixmapEffect.Lighting), lite);
		}
		public static QPixmap Hash(QPixmap pixmap) {
			return (QPixmap) staticInterceptor.Invoke("hash#", "hash(QPixmap&)", typeof(QPixmap), typeof(QPixmap), pixmap);
		}
		/// <remarks>
		///  Creates a pattern from a pixmap.
		///  The given pixmap is "flattened"
		///  between color a to color b.
		///  Doesn't change the original pixmap.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="size" The size of the returned pixmap. If <code>size</code> is larger than
		///  the original, the resulting pixmap will be tiled.
		/// </param><param> name="ca" Color a.
		/// </param><param> name="cb" Color b.
		/// </param><param> name="ncols" The number of colors to use. The image will be
		///  dithered to this depth. Pass zero to prevent dithering.
		/// </param></remarks>		<return> The resulting pixmap.
		///      </return>
		/// 		<short>    Creates a pattern from a pixmap.</short>
		public static QPixmap Pattern(QPixmap pixmap, QSize size, QColor ca, QColor cb, int ncols) {
			return (QPixmap) staticInterceptor.Invoke("pattern####$", "pattern(const QPixmap&, const QSize&, const QColor&, const QColor&, int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QSize), size, typeof(QColor), ca, typeof(QColor), cb, typeof(int), ncols);
		}
		public static QPixmap Pattern(QPixmap pixmap, QSize size, QColor ca, QColor cb) {
			return (QPixmap) staticInterceptor.Invoke("pattern####", "pattern(const QPixmap&, const QSize&, const QColor&, const QColor&)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QSize), size, typeof(QColor), ca, typeof(QColor), cb);
		}
		/// <remarks>
		///  Fades a pixmap to a certain color.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="val" The strength of the effect. 0 <= val <= 1.
		/// </param><param> name="color" The color to blend to.
		/// </param></remarks>		<return> Returns the pixmap(), provided for convenience.
		///      </return>
		/// 		<short>    Fades a pixmap to a certain color.</short>
		public static QPixmap Fade(QPixmap pixmap, double val, QColor color) {
			return (QPixmap) staticInterceptor.Invoke("fade#$#", "fade(QPixmap&, double, const QColor&)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(double), val, typeof(QColor), color);
		}
		/// <remarks>
		///  Converts a pixmap to grayscale.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="fast" Set to <code>true</code> in order to use a faster but non-photographic
		///  quality algorithm. Appropriate for things such as toolbar icons.
		/// </param></remarks>		<return> Returns the pixmap(), provided for convenience.
		///      </return>
		/// 		<short>    Converts a pixmap to grayscale.</short>
		public static QPixmap ToGray(QPixmap pixmap, bool fast) {
			return (QPixmap) staticInterceptor.Invoke("toGray#$", "toGray(QPixmap&, bool)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(bool), fast);
		}
		public static QPixmap ToGray(QPixmap pixmap) {
			return (QPixmap) staticInterceptor.Invoke("toGray#", "toGray(QPixmap&)", typeof(QPixmap), typeof(QPixmap), pixmap);
		}
		/// <remarks>
		///  Desaturates a pixmap.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="desat" A value between 0 and 1 setting the degree of desaturation
		/// </param></remarks>		<return> Returns The pixmap(), provided for convenience.
		///      </return>
		/// 		<short>    Desaturates a pixmap.</short>
		public static QPixmap Desaturate(QPixmap pixmap, float desat) {
			return (QPixmap) staticInterceptor.Invoke("desaturate#$", "desaturate(QPixmap&, float)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(float), desat);
		}
		public static QPixmap Desaturate(QPixmap pixmap) {
			return (QPixmap) staticInterceptor.Invoke("desaturate#", "desaturate(QPixmap&)", typeof(QPixmap), typeof(QPixmap), pixmap);
		}
		/// <remarks>
		///  Modifies the contrast of a pixmap.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="c" A contrast value between -255 and 255.
		/// </param></remarks>		<return> Returns the pixmap(), provided for convenience.
		///      </return>
		/// 		<short>    Modifies the contrast of a pixmap.</short>
		public static QPixmap Contrast(QPixmap pixmap, int c) {
			return (QPixmap) staticInterceptor.Invoke("contrast#$", "contrast(QPixmap&, int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(int), c);
		}
		/// <remarks>
		///  Dithers a pixmap using Floyd-Steinberg dithering for low-color
		///  situations.
		/// <param> name="pixmap" The pixmap to process.
		/// </param><param> name="palette" The color palette to use.
		/// </param><param> name="size" The size of the palette.
		/// </param></remarks>		<return> Returns the pixmap(), provided for convenience.
		///      </return>
		/// 		<short>    Dithers a pixmap using Floyd-Steinberg dithering for low-color  situations.</short>
		public static QPixmap Dither(QPixmap pixmap, QColor palette, int size) {
			return (QPixmap) staticInterceptor.Invoke("dither##$", "dither(QPixmap&, const QColor*, int)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QColor), palette, typeof(int), size);
		}
		/// <remarks>
		///  Calculate a 'selected' pixmap, for instance a selected icon
		///  on the desktop.
		/// <param> name="pixmap" the pixmap to select
		/// </param><param> name="col" the selected color, usually from QPalette.Highlight().
		///      </param></remarks>		<short>    Calculate a 'selected' pixmap, for instance a selected icon  on the desktop.</short>
		public static QPixmap SelectedPixmap(QPixmap pixmap, QColor col) {
			return (QPixmap) staticInterceptor.Invoke("selectedPixmap##", "selectedPixmap(const QPixmap&, const QColor&)", typeof(QPixmap), typeof(QPixmap), pixmap, typeof(QColor), col);
		}
	}
}
