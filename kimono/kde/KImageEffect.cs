//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Runtime.InteropServices;

	/// <remarks>
	///  Functions to perform various QImage based graphical effects.
	///  </remarks>		<short>    Functions to perform various QImage based graphical effects.</short>

	[SmokeClass("KImageEffect")]
	public class KImageEffect : Object {
		protected SmokeInvocation interceptor = null;
		private static SmokeInvocation staticInterceptor = null;
		static KImageEffect() {
			staticInterceptor = new SmokeInvocation(typeof(KImageEffect), null);
		}
		/// <remarks>
		///  This enum provides a gradient type specification
		/// </remarks>		<short>    This enum provides a gradient type specification </short>
		/// 		<see> KImageEffect.Blend</see>
		/// 		<see> KImageEffect.Gradient</see>
		/// 		<see> KImageEffect.UnbalancedGradient</see>
		public enum GradientType {
			VerticalGradient = 0,
			HorizontalGradient = 1,
			DiagonalGradient = 2,
			CrossDiagonalGradient = 3,
			PyramidGradient = 4,
			RectangleGradient = 5,
			PipeCrossGradient = 6,
			EllipticGradient = 7,
		}
		/// <remarks>
		///  This enum provides a RGB channel specification
		/// </remarks>		<short>    This enum provides a RGB channel specification </short>
		/// 		<see> KImageEffect.Blend</see>
		/// 		<see> KImageEffect.ChannelIntensity</see>
		/// 		<see> KImageEffect.Modulate</see>
		public enum RGBComponent {
			Red = 0,
			Green = 1,
			Blue = 2,
			Gray = 3,
			All = 4,
		}
		/// <remarks>
		///  This enum provides a lighting direction specification
		/// </remarks>		<short>    This enum provides a lighting direction specification </short>
		/// 		<see> KImageEffect.Hash</see>
		public enum Lighting {
			NorthLite = 0,
			NWLite = 1,
			WestLite = 2,
			SWLite = 3,
			SouthLite = 4,
			SELite = 5,
			EastLite = 6,
			NELite = 7,
		}
		/// <remarks>
		///  This enum provides a modulation type specification
		/// </remarks>		<short>    This enum provides a modulation type specification </short>
		/// 		<see> KImageEffect.Modulate</see>
		public enum ModulationType {
			Intensity = 0,
			Saturation = 1,
			HueShift = 2,
			Contrast = 3,
		}
		/// <remarks>
		///  This enum provides a noise type specification
		/// </remarks>		<short>    This enum provides a noise type specification </short>
		/// 		<see> KImageEffect.AddNoise</see>
		public enum NoiseType {
			UniformNoise = 0,
			GaussianNoise = 1,
			MultiplicativeGaussianNoise = 2,
			ImpulseNoise = 3,
			LaplacianNoise = 4,
			PoissonNoise = 5,
		}
		/// <remarks>
		///  This enum provides a rotation specification.
		/// </remarks>		<short>    This enum provides a rotation specification.</short>
		/// 		<see> KImageEffect.Rotate</see>
		public enum RotateDirection {
			Rotate90 = 0,
			Rotate180 = 1,
			Rotate270 = 2,
		}
		/// <remarks>
		///  This enum lists possible bumpmapping implementations.
		/// </remarks>		<short>    This enum lists possible bumpmapping implementations.</short>
		/// 		<see> KImageEffect.Bumpmap</see>
		public enum BumpmapType {
			Linear = 0,
			Spherical = 1,
			Sinuosidal = 2,
		}
		/// <remarks>
		///  Disposition of a source image on top of a destination image.
		/// </remarks>		<short>    Disposition of a source image on top of a destination image.</short>
		/// 		<see> KImageEffect.ComputeDestinationRect</see>
		/// 		<see> KImageEffect.BlendOnLower</see>
		public enum Disposition {
			NoImage = 0,
			Centered = 1,
			Tiled = 2,
			CenterTiled = 3,
			CenteredMaxpect = 4,
			TiledMaxpect = 5,
			Scaled = 6,
			CenteredAutoFit = 7,
		}
		/// <remarks>
		///  Create a gradient from color a to color b of the specified type.
		/// <param> name="size" The desired size of the gradient.
		/// </param><param> name="ca" Color a
		/// </param><param> name="cb" Color b
		/// </param><param> name="type" The type of gradient.
		/// </param><param> name="ncols" The number of colors to use when not running on a
		///  truecolor display. The gradient will be dithered to this number of
		///  colors. Pass 0 to prevent dithering.
		///      </param></remarks>		<short>    Create a gradient from color a to color b of the specified type.</short>
		public static QImage Gradient(QSize size, QColor ca, QColor cb, KImageEffect.GradientType type, int ncols) {
			return (QImage) staticInterceptor.Invoke("gradient###$$", "gradient(const QSize&, const QColor&, const QColor&, KImageEffect::GradientType, int)", typeof(QImage), typeof(QSize), size, typeof(QColor), ca, typeof(QColor), cb, typeof(KImageEffect.GradientType), type, typeof(int), ncols);
		}
		public static QImage Gradient(QSize size, QColor ca, QColor cb, KImageEffect.GradientType type) {
			return (QImage) staticInterceptor.Invoke("gradient###$", "gradient(const QSize&, const QColor&, const QColor&, KImageEffect::GradientType)", typeof(QImage), typeof(QSize), size, typeof(QColor), ca, typeof(QColor), cb, typeof(KImageEffect.GradientType), type);
		}
		/// <remarks>
		///  Create an unbalanced gradient.
		///  An unbalanced gradient is a gradient where the transition from
		///  color a to color b is not linear, but in this case, exponential.
		/// <param> name="size" The desired size of the gradient.
		/// </param><param> name="ca" Color a
		/// </param><param> name="cb" Color b
		/// </param><param> name="type" The type of gradient.
		/// </param><param> name="xfactor" The x decay length. Use a value between -200 and 200.
		/// </param><param> name="yfactor" The y decay length.
		/// </param><param> name="ncols" The number of colors. See KImageEffect:gradient.
		///      </param></remarks>		<short>    Create an unbalanced gradient.</short>
		public static QImage UnbalancedGradient(QSize size, QColor ca, QColor cb, KImageEffect.GradientType type, int xfactor, int yfactor, int ncols) {
			return (QImage) staticInterceptor.Invoke("unbalancedGradient###$$$$", "unbalancedGradient(const QSize&, const QColor&, const QColor&, KImageEffect::GradientType, int, int, int)", typeof(QImage), typeof(QSize), size, typeof(QColor), ca, typeof(QColor), cb, typeof(KImageEffect.GradientType), type, typeof(int), xfactor, typeof(int), yfactor, typeof(int), ncols);
		}
		public static QImage UnbalancedGradient(QSize size, QColor ca, QColor cb, KImageEffect.GradientType type, int xfactor, int yfactor) {
			return (QImage) staticInterceptor.Invoke("unbalancedGradient###$$$", "unbalancedGradient(const QSize&, const QColor&, const QColor&, KImageEffect::GradientType, int, int)", typeof(QImage), typeof(QSize), size, typeof(QColor), ca, typeof(QColor), cb, typeof(KImageEffect.GradientType), type, typeof(int), xfactor, typeof(int), yfactor);
		}
		public static QImage UnbalancedGradient(QSize size, QColor ca, QColor cb, KImageEffect.GradientType type, int xfactor) {
			return (QImage) staticInterceptor.Invoke("unbalancedGradient###$$", "unbalancedGradient(const QSize&, const QColor&, const QColor&, KImageEffect::GradientType, int)", typeof(QImage), typeof(QSize), size, typeof(QColor), ca, typeof(QColor), cb, typeof(KImageEffect.GradientType), type, typeof(int), xfactor);
		}
		public static QImage UnbalancedGradient(QSize size, QColor ca, QColor cb, KImageEffect.GradientType type) {
			return (QImage) staticInterceptor.Invoke("unbalancedGradient###$", "unbalancedGradient(const QSize&, const QColor&, const QColor&, KImageEffect::GradientType)", typeof(QImage), typeof(QSize), size, typeof(QColor), ca, typeof(QColor), cb, typeof(KImageEffect.GradientType), type);
		}
		/// <remarks>
		///  Blends a color into the destination image, using an opacity
		///  value for blending one into another. Very fast direct pixel
		///  manipulation is used.
		///  This function uses MMX and SSE2 instructions to blend the
		///  image on processors that support it.
		/// <param> name="clr" source color to be blended into the destination image.
		/// </param><param> name="dst" destination image in which the source will be blended into.
		/// </param><param> name="opacity" opacity (between 0.0 and 1.0) which determines how much
		///              the source color will be blended into the destination image.
		/// </param></remarks>		<return> The destination image (dst) containing the result.
		/// </return>
		/// 		<author> Fredrik H&ouml;glund (fredrik@kde.org)
		///      </author>
		/// 		<short>    Blends a color into the destination image, using an opacity  value for blending one into another.</short>
		public static QImage Blend(QColor clr, QImage dst, float opacity) {
			return (QImage) staticInterceptor.Invoke("blend##$", "blend(const QColor&, QImage&, float)", typeof(QImage), typeof(QColor), clr, typeof(QImage), dst, typeof(float), opacity);
		}
		/// <remarks>
		///  Blend the src image into the destination image, using an opacity
		///  value for blending one into another. Very fast direct pixel
		///  manipulation is used.
		///  This function uses MMX and SSE2 instructions to blend the
		///  images on processors that support it.
		/// <param> name="src" source image to be blended into the destination image.
		/// </param><param> name="dst" destination image in which the source will be blended into.
		/// </param><param> name="opacity" opacity (between 0.0 and 1.0) which determines how much
		///              the source image will be blended into the destination image.
		/// </param></remarks>		<return> The destination image (dst) containing the result.
		/// </return>
		/// 		<author> Fredrik H&ouml;glund (fredrik@kde.org)
		///      </author>
		/// 		<short>    Blend the src image into the destination image, using an opacity  value for blending one into another.</short>
		public static QImage Blend(QImage src, QImage dst, float opacity) {
			return (QImage) staticInterceptor.Invoke("blend##$", "blend(QImage&, QImage&, float)", typeof(QImage), typeof(QImage), src, typeof(QImage), dst, typeof(float), opacity);
		}
		/// <remarks>
		///  Blend the provided image into a background of the indicated color.
		/// <param> name="initial_intensity" this parameter takes values from -1 to 1:
		///               a) if positive: how much to fade the image in its
		///                               less affected spot
		///               b) if negative: roughly indicates how much of the image
		///                               remains unaffected
		/// </param><param> name="bgnd" indicates the color of the background to blend in
		/// </param><param> name="eff" lets you choose what kind of blending you like
		/// </param><param> name="anti_dir" blend in the opposite direction (makes no much sense
		///                   with concentric blending effects)
		/// </param><param> name="image" must be 32bpp
		///      </param></remarks>		<short>    Blend the provided image into a background of the indicated color.</short>
		public static QImage Blend(QImage image, float initial_intensity, QColor bgnd, KImageEffect.GradientType eff, bool anti_dir) {
			return (QImage) staticInterceptor.Invoke("blend#$#$$", "blend(QImage&, float, const QColor&, KImageEffect::GradientType, bool)", typeof(QImage), typeof(QImage), image, typeof(float), initial_intensity, typeof(QColor), bgnd, typeof(KImageEffect.GradientType), eff, typeof(bool), anti_dir);
		}
		public static QImage Blend(QImage image, float initial_intensity, QColor bgnd, KImageEffect.GradientType eff) {
			return (QImage) staticInterceptor.Invoke("blend#$#$", "blend(QImage&, float, const QColor&, KImageEffect::GradientType)", typeof(QImage), typeof(QImage), image, typeof(float), initial_intensity, typeof(QColor), bgnd, typeof(KImageEffect.GradientType), eff);
		}
		/// <remarks>
		///  Blend an image into another one, using a gradient type
		///  for blending from one to another.
		/// <param> name="image1" source1 and result of blending
		/// </param><param> name="image2" source2 of blending
		/// </param><param> name="gt" gradient type for blending between source1 and source2
		/// </param><param> name="xf" x decay length for unbalanced gradient tpye
		/// </param><param> name="yf" y decay length for unbalanced gradient tpye
		///      </param></remarks>		<short>    Blend an image into another one, using a gradient type  for blending from one to another.</short>
		public static QImage Blend(QImage image1, QImage image2, KImageEffect.GradientType gt, int xf, int yf) {
			return (QImage) staticInterceptor.Invoke("blend##$$$", "blend(QImage&, QImage&, KImageEffect::GradientType, int, int)", typeof(QImage), typeof(QImage), image1, typeof(QImage), image2, typeof(KImageEffect.GradientType), gt, typeof(int), xf, typeof(int), yf);
		}
		public static QImage Blend(QImage image1, QImage image2, KImageEffect.GradientType gt, int xf) {
			return (QImage) staticInterceptor.Invoke("blend##$$", "blend(QImage&, QImage&, KImageEffect::GradientType, int)", typeof(QImage), typeof(QImage), image1, typeof(QImage), image2, typeof(KImageEffect.GradientType), gt, typeof(int), xf);
		}
		public static QImage Blend(QImage image1, QImage image2, KImageEffect.GradientType gt) {
			return (QImage) staticInterceptor.Invoke("blend##$", "blend(QImage&, QImage&, KImageEffect::GradientType)", typeof(QImage), typeof(QImage), image1, typeof(QImage), image2, typeof(KImageEffect.GradientType), gt);
		}
		/// <remarks>
		///  Blend an image into another one, using a color channel of a
		///  third image for the decision of blending from one to another.
		/// <param> name="image1" Source 1 and result of blending
		/// </param><param> name="image2" Source 2 of blending
		/// </param><param> name="blendImage" If the gray value of of pixel is 0, the result
		///                for this pixel is that of image1; for a gray value
		///                of 1, the pixel of image2 is used; for a value
		///                in between, a corresponding blending is used.
		/// </param><param> name="channel" The RBG channel to use for the blending decision.
		///      </param></remarks>		<short>    Blend an image into another one, using a color channel of a  third image for the decision of blending from one to another.</short>
		public static QImage Blend(QImage image1, QImage image2, QImage blendImage, KImageEffect.RGBComponent channel) {
			return (QImage) staticInterceptor.Invoke("blend###$", "blend(QImage&, QImage&, QImage&, KImageEffect::RGBComponent)", typeof(QImage), typeof(QImage), image1, typeof(QImage), image2, typeof(QImage), blendImage, typeof(KImageEffect.RGBComponent), channel);
		}
		/// <remarks>
		///  Blend an image into another one, using alpha in the expected way.
		/// <param> name="upper" the "upper" image
		/// </param><param> name="lower" the "lower" image
		/// </param><param> name="output" the target image
		/// </param></remarks>		<author> Rik Hemsley (rikkus) <rik@kde.org>
		///      </author>
		/// 		<short>    Blend an image into another one, using alpha in the expected way.</short>
		public static bool Blend(QImage upper, QImage lower, QImage output) {
			return (bool) staticInterceptor.Invoke("blend###", "blend(const QImage&, const QImage&, QImage&)", typeof(bool), typeof(QImage), upper, typeof(QImage), lower, typeof(QImage), output);
		}
		/// <remarks>
		///  Blend an image into another one, using alpha in the expected way and
		///  over coordinates <code>x</code> and <code>y</code> with respect to the lower image.
		///  The output is a QImage which is the <code>upper</code> image already blended
		///  with the <code>lower</code> one, so its size will be (in general) the same than
		///  <code>upper</code> instead of the same size than <code>lower</code> like the method above.
		///  In fact, the size of <code>output</code> is like upper's one only when it can be
		///  painted on lower, if there has to be some clipping, output's size will
		///  be the clipped area and x and y will be set to the correct up-left corner
		///  where the clipped rectangle begins.
		/// <param> name="x" x-coordinate of lower image
		/// </param><param> name="y" y-coordinate of lower image
		/// </param><param> name="upper" the "upper" image
		/// </param><param> name="lower" the "lower" image
		/// </param><param> name="output" the target image
		///      </param></remarks>		<short>    Blend an image into another one, using alpha in the expected way and  over coordinates <code>x</code> and <code>y</code> with respect to the lower image.</short>
		public static bool Blend(ref int x, ref int y, QImage upper, QImage lower, QImage output) {
			StackItem[] stack = new StackItem[6];
			stack[1].s_int = x;
			stack[2].s_int = y;
#if DEBUG
			stack[3].s_class = (IntPtr) DebugGCHandle.Alloc(upper);
#else
			stack[3].s_class = (IntPtr) GCHandle.Alloc(upper);
#endif
#if DEBUG
			stack[4].s_class = (IntPtr) DebugGCHandle.Alloc(lower);
#else
			stack[4].s_class = (IntPtr) GCHandle.Alloc(lower);
#endif
#if DEBUG
			stack[5].s_class = (IntPtr) DebugGCHandle.Alloc(output);
#else
			stack[5].s_class = (IntPtr) GCHandle.Alloc(output);
#endif
			staticInterceptor.Invoke("blend$$###", "blend(int&, int&, const QImage&, const QImage&, QImage&)", stack);
			x = stack[1].s_int;
			y = stack[2].s_int;
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[3].s_class);
#else
			((GCHandle) stack[3].s_class).Free();
#endif
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[4].s_class);
#else
			((GCHandle) stack[4].s_class).Free();
#endif
#if DEBUG
			DebugGCHandle.Free((GCHandle) stack[5].s_class);
#else
			((GCHandle) stack[5].s_class).Free();
#endif
			return stack[0].s_bool;
		}
		/// <remarks>
		///  Blend an image into another one, using alpha in the expected way and
		///  over coordinates <code>x</code> and <code>y</code> with respect to the lower image.
		///  The output is painted in the own <code>lower</code> image. This is an optimization
		///  of the blend method above provided by convenience.
		/// <param> name="x" x-coordinate of lower image
		/// </param><param> name="y" y-coordinate of lower image
		/// </param><param> name="upper" the "upper" image
		/// </param><param> name="lower" the "lower" image, which becomes the output image
		///      </param></remarks>		<short>    Blend an image into another one, using alpha in the expected way and  over coordinates <code>x</code> and <code>y</code> with respect to the lower image.</short>
		public static bool BlendOnLower(int x, int y, QImage upper, QImage lower) {
			return (bool) staticInterceptor.Invoke("blendOnLower$$##", "blendOnLower(int, int, const QImage&, const QImage&)", typeof(bool), typeof(int), x, typeof(int), y, typeof(QImage), upper, typeof(QImage), lower);
		}
		/// <remarks>
		///  Blend part of an image into part of another, using the alpha channel in
		///  the expected way.
		///  Note that the destination rectangle will be correctly clipped.
		/// <param> name="upper" the "upper" image
		/// </param><param> name="upperOffset" Offset for the part of the upper image to be used.
		/// </param><param> name="lower" the "lower" image
		/// </param><param> name="lowerRect" Rectangle for the part of the lower image where the
		///                   blending will occur.
		///      </param></remarks>		<short>    Blend part of an image into part of another, using the alpha channel in  the expected way.</short>
		public static void BlendOnLower(QImage upper, QPoint upperOffset, QImage lower, QRect lowerRect) {
			staticInterceptor.Invoke("blendOnLower####", "blendOnLower(const QImage&, const QPoint&, QImage&, const QRect&)", typeof(void), typeof(QImage), upper, typeof(QPoint), upperOffset, typeof(QImage), lower, typeof(QRect), lowerRect);
		}
		/// <remarks>
		///  Blend part of an image into part of another, using the opacity value
		///  and the alpha channel in the expected way.
		///  Note that the destination rectangle will be correctly clipped.
		/// <param> name="upper" the "upper" image
		/// </param><param> name="upperOffset" Offset for the part of the upper image to be used.
		/// </param><param> name="lower" the "lower" image
		/// </param><param> name="lowerRect" Rectangle for the part of the lower image where the
		///                   blending will occur.
		/// </param><param> name="opacity" Opacity (between 0.0 and 1.0) which determines how much
		///              the source image will be blended into the destination image.
		///      </param></remarks>		<short>    Blend part of an image into part of another, using the opacity value  and the alpha channel in the expected way.</short>
		public static void BlendOnLower(QImage upper, QPoint upperOffset, QImage lower, QRect lowerRect, float opacity) {
			staticInterceptor.Invoke("blendOnLower####$", "blendOnLower(const QImage&, const QPoint&, QImage&, const QRect&, float)", typeof(void), typeof(QImage), upper, typeof(QPoint), upperOffset, typeof(QImage), lower, typeof(QRect), lowerRect, typeof(float), opacity);
		}
		/// <remarks>
		///  Compute the destination rectangle where to draw the upper image on top
		///  of another image using the given disposition. For tiled
		///  disposition, the rectangle should be duplicated on the whole area to
		///  obtained the wanted effect.
		/// <param> name="lowerSize" The size of the destination image.
		/// </param><param> name="disposition" The wanted disposition.
		/// </param><param> name="upper" The upper image. Note that this image may be scaled to
		///                adjust to the requested disposition.
		/// </param></remarks>		<return> the computed rectangle. Its size may exceed @e lowerSize.
		///      </return>
		/// 		<short>    Compute the destination rectangle where to draw the upper image on top  of another image using the given disposition.</short>
		public static QRect ComputeDestinationRect(QSize lowerSize, KImageEffect.Disposition disposition, QImage upper) {
			return (QRect) staticInterceptor.Invoke("computeDestinationRect#$#", "computeDestinationRect(const QSize&, KImageEffect::Disposition, QImage&)", typeof(QRect), typeof(QSize), lowerSize, typeof(KImageEffect.Disposition), disposition, typeof(QImage), upper);
		}
		/// <remarks>
		///  Blend an image on top of another using a given disposition and a given
		///  opacity. The alpha channel of the upper image is used in the expected
		///  way. Beware the upper image may be modified.
		///      </remarks>		<short>    Blend an image on top of another using a given disposition and a given  opacity.</short>
		public static void BlendOnLower(QImage upper, QImage lower, KImageEffect.Disposition disposition, float opacity) {
			staticInterceptor.Invoke("blendOnLower##$$", "blendOnLower(QImage&, QImage&, KImageEffect::Disposition, float)", typeof(void), typeof(QImage), upper, typeof(QImage), lower, typeof(KImageEffect.Disposition), disposition, typeof(float), opacity);
		}
		/// <remarks>
		///  Modifies the intensity of a pixmap's RGB channel component.
		/// <param> name="image" The QImage to process.
		/// </param><param> name="percent" Percent value. Use a negative value to dim.
		/// </param><param> name="channel" Which channel(s) should be modified
		/// </param></remarks>		<return> The <code>image</code>, provided for convenience.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Modifies the intensity of a pixmap's RGB channel component.</short>
		public static QImage ChannelIntensity(QImage image, float percent, KImageEffect.RGBComponent channel) {
			return (QImage) staticInterceptor.Invoke("channelIntensity#$$", "channelIntensity(QImage&, float, KImageEffect::RGBComponent)", typeof(QImage), typeof(QImage), image, typeof(float), percent, typeof(KImageEffect.RGBComponent), channel);
		}
		/// <remarks>
		///  Fade an image to a certain background color.
		///  The number of colors will not be changed.
		/// <param> name="image" The QImage to process.
		/// </param><param> name="val" The strength of the effect. 0 <= val <= 1.
		/// </param><param> name="color" The background color.
		/// </param></remarks>		<return> Returns the image(), provided for convenience.
		///      </return>
		/// 		<short>    Fade an image to a certain background color.</short>
		public static QImage Fade(QImage image, float val, QColor color) {
			return (QImage) staticInterceptor.Invoke("fade#$#", "fade(QImage&, float, const QColor&)", typeof(QImage), typeof(QImage), image, typeof(float), val, typeof(QColor), color);
		}
		/// <remarks>
		///  This recolors a pixmap. The most dark color will become color a,
		///  the most bright one color b, and in between.
		/// <param> name="image" A QImage to process.
		/// </param><param> name="ca" Color a
		/// </param><param> name="cb" Color b
		/// </param><param> name="ncols" The number of colors to dither the image to.
		///  Pass 0 to prevent dithering.
		///      </param></remarks>		<short>    This recolors a pixmap.</short>
		public static QImage Flatten(QImage image, QColor ca, QColor cb, int ncols) {
			return (QImage) staticInterceptor.Invoke("flatten###$", "flatten(QImage&, const QColor&, const QColor&, int)", typeof(QImage), typeof(QImage), image, typeof(QColor), ca, typeof(QColor), cb, typeof(int), ncols);
		}
		public static QImage Flatten(QImage image, QColor ca, QColor cb) {
			return (QImage) staticInterceptor.Invoke("flatten###", "flatten(QImage&, const QColor&, const QColor&)", typeof(QImage), typeof(QImage), image, typeof(QColor), ca, typeof(QColor), cb);
		}
		/// <remarks>
		///  Build a hash on any given QImage
		/// <param> name="image" The QImage to process
		/// </param><param> name="lite" The hash faces the indicated lighting (cardinal poles).
		/// </param><param> name="spacing" How many unmodified pixels in between hashes.
		/// </param></remarks>		<return> Returns the image(), provided for convenience.
		///      </return>
		/// 		<short>    Build a hash on any given QImage </short>
		public static QImage Hash(QImage image, KImageEffect.Lighting lite, uint spacing) {
			return (QImage) staticInterceptor.Invoke("hash#$$", "hash(QImage&, KImageEffect::Lighting, unsigned int)", typeof(QImage), typeof(QImage), image, typeof(KImageEffect.Lighting), lite, typeof(uint), spacing);
		}
		public static QImage Hash(QImage image, KImageEffect.Lighting lite) {
			return (QImage) staticInterceptor.Invoke("hash#$", "hash(QImage&, KImageEffect::Lighting)", typeof(QImage), typeof(QImage), image, typeof(KImageEffect.Lighting), lite);
		}
		public static QImage Hash(QImage image) {
			return (QImage) staticInterceptor.Invoke("hash#", "hash(QImage&)", typeof(QImage), typeof(QImage), image);
		}
		/// <remarks>
		///  Either brighten or dim the image by a specified percent.
		///  For example, .50 will modify the colors by 50%.
		///  This function uses MMX instructions to process the image
		///  on processors that support it.
		/// <param> name="image" The QImage to process.
		/// </param><param> name="percent" The percent value. Use a negative value to dim.
		/// </param></remarks>		<return> Returns The image(), provided for convenience.
		/// </return>
		/// 		<author> Benjamin Roe (ben@benroe.com)
		///      </author>
		/// 		<short>    Either brighten or dim the image by a specified percent.</short>
		public static QImage Intensity(QImage image, float percent) {
			return (QImage) staticInterceptor.Invoke("intensity#$", "intensity(QImage&, float)", typeof(QImage), typeof(QImage), image, typeof(float), percent);
		}
		/// <remarks>
		///  Modulate the image with a color channel of another image.
		/// <param> name="image" The QImage to modulate and result.
		/// </param><param> name="modImage" The QImage to use for modulation.
		/// </param><param> name="reverse" Invert the meaning of image/modImage; result is image!
		/// </param><param> name="type" The modulation Type to use.
		/// </param><param> name="factor" The modulation amplitude; with 0 no effect [-200;200].
		/// </param><param> name="channel" The RBG channel of image2 to use for modulation.
		/// </param></remarks>		<return> Returns the image(), provided for convenience.
		///      </return>
		/// 		<short>    Modulate the image with a color channel of another image.</short>
		public static QImage Modulate(QImage image, QImage modImage, bool reverse, KImageEffect.ModulationType type, int factor, KImageEffect.RGBComponent channel) {
			return (QImage) staticInterceptor.Invoke("modulate##$$$$", "modulate(QImage&, QImage&, bool, KImageEffect::ModulationType, int, KImageEffect::RGBComponent)", typeof(QImage), typeof(QImage), image, typeof(QImage), modImage, typeof(bool), reverse, typeof(KImageEffect.ModulationType), type, typeof(int), factor, typeof(KImageEffect.RGBComponent), channel);
		}
		/// <remarks>
		///  Convert an image to grayscale.
		/// <param> name="image" The QImage to process.
		/// </param><param> name="fast" Set to <code>true</code> in order to use a faster but non-photographic
		///  quality algorithm. Appropriate for things such as toolbar icons.
		/// </param></remarks>		<return> Returns the image(), provided for convenience.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Convert an image to grayscale.</short>
		public static QImage ToGray(QImage image, bool fast) {
			return (QImage) staticInterceptor.Invoke("toGray#$", "toGray(QImage&, bool)", typeof(QImage), typeof(QImage), image, typeof(bool), fast);
		}
		public static QImage ToGray(QImage image) {
			return (QImage) staticInterceptor.Invoke("toGray#", "toGray(QImage&)", typeof(QImage), typeof(QImage), image);
		}
		/// <remarks>
		///  Desaturate an image evenly.
		/// <param> name="image" The QImage to process.
		/// </param><param> name="desat" A value between 0 and 1 setting the degree of desaturation
		/// </param></remarks>		<return> Returns the image(), provided for convenience.
		///      </return>
		/// 		<short>    Desaturate an image evenly.</short>
		public static QImage Desaturate(QImage image, float desat) {
			return (QImage) staticInterceptor.Invoke("desaturate#$", "desaturate(QImage&, float)", typeof(QImage), typeof(QImage), image, typeof(float), desat);
		}
		public static QImage Desaturate(QImage image) {
			return (QImage) staticInterceptor.Invoke("desaturate#", "desaturate(QImage&)", typeof(QImage), typeof(QImage), image);
		}
		/// <remarks>
		///  Fast, but low quality contrast of an image. Also see contrastHSV.
		/// <param> name="image" The QImage to process.
		/// </param><param> name="c" A contrast value between -255 to 255.
		/// </param></remarks>		<return> The image(), provided for convenience.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///  ### KDE 4: remove
		///      </author>
		/// 		<short>    Fast, but low quality contrast of an image.</short>
		public static QImage Contrast(QImage image, int c) {
			return (QImage) staticInterceptor.Invoke("contrast#$", "contrast(QImage&, int)", typeof(QImage), typeof(QImage), image, typeof(int), c);
		}
		/// <remarks>
		///  Dither an image using Floyd-Steinberg dithering for low-color
		///  situations.
		/// <param> name="image" The QImage to process.
		/// </param><param> name="palette" The color palette to use
		/// </param><param> name="size" The size of the palette
		/// </param></remarks>		<return> Returns the image(), provided for convenience.
		///      </return>
		/// 		<short>    Dither an image using Floyd-Steinberg dithering for low-color  situations.</short>
		public static QImage Dither(QImage image, QColor palette, int size) {
			return (QImage) staticInterceptor.Invoke("dither##$", "dither(QImage&, const QColor*, int)", typeof(QImage), typeof(QImage), image, typeof(QColor), palette, typeof(int), size);
		}
		/// <remarks>
		///  Calculate the image for a selected image, for instance a selected icon
		///  on the desktop.
		/// <param> name="img" the QImage to select
		/// </param><param> name="col" the selected color, usually from QPalette.Highlight().
		///      </param></remarks>		<short>    Calculate the image for a selected image, for instance a selected icon  on the desktop.</short>
		public static QImage SelectedImage(QImage img, QColor col) {
			return (QImage) staticInterceptor.Invoke("selectedImage##", "selectedImage(QImage&, const QColor&)", typeof(QImage), typeof(QImage), img, typeof(QColor), col);
		}
		/// <remarks>
		///  High quality, expensive HSV contrast. You can do a faster one by just
		///  taking a intensity threshold (ie: 128) and incrementing RGB color
		///  channels above it and decrementing those below it, but this gives much
		///  better results.
		/// <param> name="img" The QImage to process.
		/// </param><param> name="sharpen" If true sharpness is increase, (spiffed). Otherwise
		///  it is decreased, (dulled).
		/// </param></remarks>		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    High quality, expensive HSV contrast.</short>
		public static void ContrastHSV(QImage img, bool sharpen) {
			staticInterceptor.Invoke("contrastHSV#$", "contrastHSV(QImage&, bool)", typeof(void), typeof(QImage), img, typeof(bool), sharpen);
		}
		public static void ContrastHSV(QImage img) {
			staticInterceptor.Invoke("contrastHSV#", "contrastHSV(QImage&)", typeof(void), typeof(QImage), img);
		}
		/// <remarks>
		///  Normalises the pixel values to span the full range of color values.
		///  This is a contrast enhancement technique.
		/// <param> name="img" the image that is normalised
		/// </param></remarks>		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Normalises the pixel values to span the full range of color values.</short>
		public static void Normalize(QImage img) {
			staticInterceptor.Invoke("normalize#", "normalize(QImage&)", typeof(void), typeof(QImage), img);
		}
		/// <remarks>
		///  Performs histogram equalisation on the reference
		///  image.
		/// <param> name="img" the image that is equalised
		/// </param></remarks>		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Performs histogram equalisation on the reference  image.</short>
		public static void Equalize(QImage img) {
			staticInterceptor.Invoke("equalize#", "equalize(QImage&)", typeof(void), typeof(QImage), img);
		}
		/// <remarks>
		///  Thresholds the reference image. You can also threshold images by using
		///  ThresholdDither in the various QPixmap/QImage convert methods, but this
		///  lets you specify a threshold value.
		/// <param> name="img" The QImage to process.
		/// </param><param> name="value" The threshold value.
		/// </param></remarks>		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Thresholds the reference image.</short>
		public static void Threshold(QImage img, uint value) {
			staticInterceptor.Invoke("threshold#$", "threshold(QImage&, unsigned int)", typeof(void), typeof(QImage), img, typeof(uint), value);
		}
		public static void Threshold(QImage img) {
			staticInterceptor.Invoke("threshold#", "threshold(QImage&)", typeof(void), typeof(QImage), img);
		}
		/// <remarks>
		///  Produces a 'solarization' effect seen when exposing a photographic
		///  film to light during the development process.
		/// <param> name="img" The QImage to process.
		/// </param><param> name="factor" The extent of the solarization (0-99.9)
		/// </param></remarks>		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Produces a 'solarization' effect seen when exposing a photographic  film to light during the development process.</short>
		public static void Solarize(QImage img, double factor) {
			staticInterceptor.Invoke("solarize#$", "solarize(QImage&, double)", typeof(void), typeof(QImage), img, typeof(double), factor);
		}
		public static void Solarize(QImage img) {
			staticInterceptor.Invoke("solarize#", "solarize(QImage&)", typeof(void), typeof(QImage), img);
		}
		/// <remarks>
		///  Embosses the source image. This involves highlighting the edges
		///  and applying various other enhancements in order to get a metal
		///  effect.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="radius" The radius of the gaussian not counting the
		///  center pixel. Use 0 and a suitable radius will be automatically used.
		/// </param><param> name="sigma" The standard deviation of the gaussian. Use 1 if you're not
		///  sure.
		/// </param></remarks>		<return> The embossed image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Embosses the source image.</short>
		public static QImage Emboss(QImage src, double radius, double sigma) {
			return (QImage) staticInterceptor.Invoke("emboss#$$", "emboss(QImage&, double, double)", typeof(QImage), typeof(QImage), src, typeof(double), radius, typeof(double), sigma);
		}
		/// <remarks>
		///  Convenience method.
		///      </remarks>		<short>    Convenience method.</short>
		public static QImage Emboss(QImage src) {
			return (QImage) staticInterceptor.Invoke("emboss#", "emboss(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Minimizes speckle noise in the source image using the 8 hull
		///  algorithm.
		/// <param> name="src" The QImage to process.
		/// </param></remarks>		<return> The despeckled image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Minimizes speckle noise in the source image using the 8 hull  algorithm.</short>
		public static QImage Despeckle(QImage src) {
			return (QImage) staticInterceptor.Invoke("despeckle#", "despeckle(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Produces a neat little "charcoal" effect.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="radius" The radius of the gaussian not counting the
		///  center pixel. Use 0 and a suitable radius will be automatically used.
		/// </param><param> name="sigma" The standard deviation of the gaussian. Use 1 if you're not
		///  sure.
		/// </param></remarks>		<return> The charcoal image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Produces a neat little "charcoal" effect.</short>
		public static QImage Charcoal(QImage src, double radius, double sigma) {
			return (QImage) staticInterceptor.Invoke("charcoal#$$", "charcoal(QImage&, double, double)", typeof(QImage), typeof(QImage), src, typeof(double), radius, typeof(double), sigma);
		}
		/// <remarks>
		///  This is provided for binary compatability only! Use the above method
		///  with a radius and sigma instead!
		///      </remarks>		<short>    This is provided for binary compatability only! Use the above method  with a radius and sigma instead!      </short>
		public static QImage Charcoal(QImage src, double factor) {
			return (QImage) staticInterceptor.Invoke("charcoal#$", "charcoal(QImage&, double)", typeof(QImage), typeof(QImage), src, typeof(double), factor);
		}
		public static QImage Charcoal(QImage src) {
			return (QImage) staticInterceptor.Invoke("charcoal#", "charcoal(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Rotates the image by the specified amount
		/// <param> name="src" The QImage to process.
		/// </param><param> name="r" The rotate direction.
		/// </param></remarks>		<return> The rotated image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Rotates the image by the specified amount </short>
		public static QImage Rotate(QImage src, KImageEffect.RotateDirection r) {
			return (QImage) staticInterceptor.Invoke("rotate#$", "rotate(QImage&, KImageEffect::RotateDirection)", typeof(QImage), typeof(QImage), src, typeof(KImageEffect.RotateDirection), r);
		}
		/// <remarks>
		///  Scales an image using simple pixel sampling. This does not produce
		///  nearly as nice a result as QImage.SmoothScale(), but has the
		///  advantage of being much faster - only a few milliseconds.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="w" The new width.
		/// </param><param> name="h" The new height.
		/// </param></remarks>		<return> The scaled image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Scales an image using simple pixel sampling.</short>
		public static QImage Sample(QImage src, int w, int h) {
			return (QImage) staticInterceptor.Invoke("sample#$$", "sample(QImage&, int, int)", typeof(QImage), typeof(QImage), src, typeof(int), w, typeof(int), h);
		}
		/// <remarks>
		///  Adds noise to an image.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="type" The algorithm used to generate the noise.
		/// </param></remarks>		<return> The image with noise added. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Adds noise to an image.</short>
		public static QImage AddNoise(QImage src, KImageEffect.NoiseType type) {
			return (QImage) staticInterceptor.Invoke("addNoise#$", "addNoise(QImage&, KImageEffect::NoiseType)", typeof(QImage), typeof(QImage), src, typeof(KImageEffect.NoiseType), type);
		}
		public static QImage AddNoise(QImage src) {
			return (QImage) staticInterceptor.Invoke("addNoise#", "addNoise(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Blurs an image by convolving pixel neighborhoods.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="radius" The radius of the gaussian not counting the
		///  center pixel. Use 0 and a suitable radius will be automatically used.
		/// </param><param> name="sigma" The standard deviation of the gaussian. Use 1 if you're not
		///  sure.
		/// </param></remarks>		<return> The blurred image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Blurs an image by convolving pixel neighborhoods.</short>
		public static QImage Blur(QImage src, double radius, double sigma) {
			return (QImage) staticInterceptor.Invoke("blur#$$", "blur(QImage&, double, double)", typeof(QImage), typeof(QImage), src, typeof(double), radius, typeof(double), sigma);
		}
		/// <remarks>
		///  This is provided for binary compatability only! Use the above method
		///  with a radius and sigma instead!
		///      </remarks>		<short>    This is provided for binary compatability only! Use the above method  with a radius and sigma instead!      </short>
		public static QImage Blur(QImage src, double factor) {
			return (QImage) staticInterceptor.Invoke("blur#$", "blur(QImage&, double)", typeof(QImage), typeof(QImage), src, typeof(double), factor);
		}
		public static QImage Blur(QImage src) {
			return (QImage) staticInterceptor.Invoke("blur#", "blur(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Detects edges in an image using pixel neighborhoods and an edge
		///  detection mask.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="radius" The radius of the gaussian not counting the
		///  center pixel. Use 0 and a suitable radius will be automatically used.
		/// </param></remarks>		<return> The image with edges detected. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Detects edges in an image using pixel neighborhoods and an edge  detection mask.</short>
		public static QImage Edge(QImage src, double radius) {
			return (QImage) staticInterceptor.Invoke("edge#$", "edge(QImage&, double)", typeof(QImage), typeof(QImage), src, typeof(double), radius);
		}
		/// <remarks>
		///  Implodes an image by a specified percent.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="factor" The extent of the implosion.
		/// </param><param> name="background" An RGBA value to use for the background. After the
		///  effect some pixels may be "empty". This value is used for those pixels.
		/// </param></remarks>		<return> The imploded image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Implodes an image by a specified percent.</short>
		public static QImage Implode(QImage src, double factor, uint background) {
			return (QImage) staticInterceptor.Invoke("implode#$$", "implode(QImage&, double, unsigned int)", typeof(QImage), typeof(QImage), src, typeof(double), factor, typeof(uint), background);
		}
		public static QImage Implode(QImage src, double factor) {
			return (QImage) staticInterceptor.Invoke("implode#$", "implode(QImage&, double)", typeof(QImage), typeof(QImage), src, typeof(double), factor);
		}
		public static QImage Implode(QImage src) {
			return (QImage) staticInterceptor.Invoke("implode#", "implode(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Produces an oil painting effect.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="radius" The radius of the gaussian not counting the
		///  center pixel. Use 0 and a suitable radius will be automatically used.
		/// </param></remarks>		<return> The new image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Produces an oil painting effect.</short>
		public static QImage OilPaintConvolve(QImage src, double radius) {
			return (QImage) staticInterceptor.Invoke("oilPaintConvolve#$", "oilPaintConvolve(QImage&, double)", typeof(QImage), typeof(QImage), src, typeof(double), radius);
		}
		/// <remarks>
		///  This is provided for binary compatability only! Use the above method
		///  instead!
		///      </remarks>		<short>    This is provided for binary compatability only! Use the above method  instead!      </short>
		public static QImage OilPaint(QImage src, int radius) {
			return (QImage) staticInterceptor.Invoke("oilPaint#$", "oilPaint(QImage&, int)", typeof(QImage), typeof(QImage), src, typeof(int), radius);
		}
		public static QImage OilPaint(QImage src) {
			return (QImage) staticInterceptor.Invoke("oilPaint#", "oilPaint(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Sharpens the pixels in the image using pixel neighborhoods.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="radius" The radius of the gaussian not counting the
		///  center pixel. Use 0 and a suitable radius will be automatically used.
		/// </param><param> name="sigma" The standard deviation of the gaussian. Use 1 if you're not
		///  sure.
		/// </param></remarks>		<return> The sharpened image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Sharpens the pixels in the image using pixel neighborhoods.</short>
		public static QImage Sharpen(QImage src, double radius, double sigma) {
			return (QImage) staticInterceptor.Invoke("sharpen#$$", "sharpen(QImage&, double, double)", typeof(QImage), typeof(QImage), src, typeof(double), radius, typeof(double), sigma);
		}
		/// <remarks>
		///  This is provided for binary compatability only! Use the above method
		///  instead!
		///      </remarks>		<short>    This is provided for binary compatability only! Use the above method  instead!      </short>
		public static QImage Sharpen(QImage src, double factor) {
			return (QImage) staticInterceptor.Invoke("sharpen#$", "sharpen(QImage&, double)", typeof(QImage), typeof(QImage), src, typeof(double), factor);
		}
		public static QImage Sharpen(QImage src) {
			return (QImage) staticInterceptor.Invoke("sharpen#", "sharpen(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Randomly displaces pixels.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="amount" The vicinity for choosing a random pixel to swap.
		/// </param></remarks>		<return> The image with pixels displaced. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Randomly displaces pixels.</short>
		public static QImage Spread(QImage src, uint amount) {
			return (QImage) staticInterceptor.Invoke("spread#$", "spread(QImage&, unsigned int)", typeof(QImage), typeof(QImage), src, typeof(uint), amount);
		}
		public static QImage Spread(QImage src) {
			return (QImage) staticInterceptor.Invoke("spread#", "spread(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Shades the image using a distance light source.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="color_shading" If true do color shading, otherwise do grayscale.
		/// </param><param> name="azimuth" Determines the light source and direction.
		/// </param><param> name="elevation" Determines the light source and direction.
		/// </param></remarks>		<return> The shaded image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Shades the image using a distance light source.</short>
		public static QImage Shade(QImage src, bool color_shading, double azimuth, double elevation) {
			return (QImage) staticInterceptor.Invoke("shade#$$$", "shade(QImage&, bool, double, double)", typeof(QImage), typeof(QImage), src, typeof(bool), color_shading, typeof(double), azimuth, typeof(double), elevation);
		}
		public static QImage Shade(QImage src, bool color_shading, double azimuth) {
			return (QImage) staticInterceptor.Invoke("shade#$$", "shade(QImage&, bool, double)", typeof(QImage), typeof(QImage), src, typeof(bool), color_shading, typeof(double), azimuth);
		}
		public static QImage Shade(QImage src, bool color_shading) {
			return (QImage) staticInterceptor.Invoke("shade#$", "shade(QImage&, bool)", typeof(QImage), typeof(QImage), src, typeof(bool), color_shading);
		}
		public static QImage Shade(QImage src) {
			return (QImage) staticInterceptor.Invoke("shade#", "shade(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Swirls the image by a specified amount
		/// <param> name="src" The QImage to process.
		/// </param><param> name="degrees" The tightness of the swirl.
		/// </param><param> name="background" An RGBA value to use for the background. After the
		///  effect some pixels may be "empty". This value is used for those pixels.
		/// </param></remarks>		<return> The swirled image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Swirls the image by a specified amount </short>
		public static QImage Swirl(QImage src, double degrees, uint background) {
			return (QImage) staticInterceptor.Invoke("swirl#$$", "swirl(QImage&, double, unsigned int)", typeof(QImage), typeof(QImage), src, typeof(double), degrees, typeof(uint), background);
		}
		public static QImage Swirl(QImage src, double degrees) {
			return (QImage) staticInterceptor.Invoke("swirl#$", "swirl(QImage&, double)", typeof(QImage), typeof(QImage), src, typeof(double), degrees);
		}
		public static QImage Swirl(QImage src) {
			return (QImage) staticInterceptor.Invoke("swirl#", "swirl(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  Modifies the pixels along a sine wave.
		/// <param> name="src" The QImage to process.
		/// </param><param> name="amplitude" The amplitude of the sine wave.
		/// </param><param> name="frequency" The frequency of the sine wave.
		/// </param><param> name="background" An RGBA value to use for the background. After the
		///  effect some pixels may be "empty". This value is used for those pixels.
		/// </param></remarks>		<return> The new image. The original is not changed.
		/// </return>
		/// 		<author> Daniel M. Duley (mosfet)
		///      </author>
		/// 		<short>    Modifies the pixels along a sine wave.</short>
		public static QImage Wave(QImage src, double amplitude, double frequency, uint background) {
			return (QImage) staticInterceptor.Invoke("wave#$$$", "wave(QImage&, double, double, unsigned int)", typeof(QImage), typeof(QImage), src, typeof(double), amplitude, typeof(double), frequency, typeof(uint), background);
		}
		public static QImage Wave(QImage src, double amplitude, double frequency) {
			return (QImage) staticInterceptor.Invoke("wave#$$", "wave(QImage&, double, double)", typeof(QImage), typeof(QImage), src, typeof(double), amplitude, typeof(double), frequency);
		}
		public static QImage Wave(QImage src, double amplitude) {
			return (QImage) staticInterceptor.Invoke("wave#$", "wave(QImage&, double)", typeof(QImage), typeof(QImage), src, typeof(double), amplitude);
		}
		public static QImage Wave(QImage src) {
			return (QImage) staticInterceptor.Invoke("wave#", "wave(QImage&)", typeof(QImage), typeof(QImage), src);
		}
		/// <remarks>
		///  A bumpmapping algorithm.
		/// <param> name="img" the image you want bumpmap
		/// </param><param> name="map" the map used
		/// </param><param> name="azimuth" azimuth
		/// </param><param> name="elevation" elevation
		/// </param><param> name="depth" depth (not the depth of the image, but of the map)
		/// </param><param> name="xofs" X offset
		/// </param><param> name="yofs" Y offset
		/// </param><param> name="waterlevel" level that full transparency should represent
		/// </param><param> name="ambient" ambient lighting factor
		/// </param><param> name="compensate" compensate for darkening
		/// </param><param> name="invert" invert bumpmap
		/// </param><param> name="type" type of the bumpmap
		/// </param><param> name="tiled" tile the bumpmap over the image through the Y offset
		/// </param></remarks>		<return> The destination image (dst) containing the result.
		/// </return>
		/// 		<author> Zack Rusin <zack@kde.org>
		///      </author>
		/// 		<short>    A bumpmapping algorithm.</short>
		public static QImage Bumpmap(QImage img, QImage map, double azimuth, double elevation, int depth, int xofs, int yofs, int waterlevel, int ambient, bool compensate, bool invert, KImageEffect.BumpmapType type, bool tiled) {
			return (QImage) staticInterceptor.Invoke("bumpmap##$$$$$$$$$$$", "bumpmap(QImage&, QImage&, double, double, int, int, int, int, int, bool, bool, KImageEffect::BumpmapType, bool)", typeof(QImage), typeof(QImage), img, typeof(QImage), map, typeof(double), azimuth, typeof(double), elevation, typeof(int), depth, typeof(int), xofs, typeof(int), yofs, typeof(int), waterlevel, typeof(int), ambient, typeof(bool), compensate, typeof(bool), invert, typeof(KImageEffect.BumpmapType), type, typeof(bool), tiled);
		}
	}
}
