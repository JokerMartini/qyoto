//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  The class usage is the same as KMD5.
	///  </remarks>		<short> An adapted C++ implementation of the MD4 Message-Digest algorithm. </short>

	[SmokeClass("KMD4")]
	public class KMD4 : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KMD4(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KMD4), this);
		}
		// const KMD4::Digest& rawDigest(); >>>> NOT CONVERTED
		// void rawDigest(KMD4::Digest& arg1); >>>> NOT CONVERTED
		// bool verify(const KMD4::Digest& arg1); >>>> NOT CONVERTED
		public KMD4() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMD4", "KMD4()", typeof(void));
		}
		/// <remarks>
		///  Constructor that updates the digest for the given string.
		/// <param> name="in" C string or binary data
		/// </param><param> name="len" if negative, calculates the length by using
		///              strlen on the first parameter, otherwise
		///              it trusts the given length (does not stop on NUL byte).
		///    </param></remarks>		<short>    Constructor that updates the digest for the given string.</short>
		public KMD4(string arg1, int len) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMD4$$", "KMD4(const char*, int)", typeof(void), typeof(string), arg1, typeof(int), len);
		}
		public KMD4(string arg1) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMD4$", "KMD4(const char*)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  @overload
		///  Same as above except it accepts a QByteArray as its argument.
		///    </remarks>		<short>    @overload </short>
		public KMD4(QByteArray a) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KMD4#", "KMD4(const QByteArray&)", typeof(void), typeof(QByteArray), a);
		}
		/// <remarks>
		///  Updates the message to be digested. Be sure to add all data
		///  before you read the digest. After reading the digest, you
		///  can <b>not</b> add more data!
		/// <param> name="in" message to be added to digest
		/// </param><param> name="len" the length of the given message.
		///    </param></remarks>		<short>    Updates the message to be digested.</short>
		public void Update(string arg1, int len) {
			interceptor.Invoke("update$$", "update(const char*, int)", typeof(void), typeof(string), arg1, typeof(int), len);
		}
		public void Update(string arg1) {
			interceptor.Invoke("update$", "update(const char*)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  @overload
		///    </remarks>		<short>    @overload    </short>
		public void Update(ushort arg1, int len) {
			interceptor.Invoke("update$$", "update(const unsigned char*, int)", typeof(void), typeof(ushort), arg1, typeof(int), len);
		}
		public void Update(ushort arg1) {
			interceptor.Invoke("update$", "update(const unsigned char*)", typeof(void), typeof(ushort), arg1);
		}
		/// <remarks>
		///  @overload
		/// <param> name="in" message to be added to the digest (QByteArray).
		///    </param></remarks>		<short>    @overload </short>
		public void Update(QByteArray arg1) {
			interceptor.Invoke("update#", "update(const QByteArray&)", typeof(void), typeof(QByteArray), arg1);
		}
		/// <remarks>
		///  @overload
		///  reads the data from an I/O device, i.e. from a file (QFile).
		///  NOTE that the file must be open for reading.
		/// <param> name="file" a pointer to FILE as returned by calls like f{d,re}open
		/// </param></remarks>		<return> false if an error occurred during reading.
		///    </return>
		/// 		<short>    @overload </short>
		public bool Update(QIODevice file) {
			return (bool) interceptor.Invoke("update#", "update(QIODevice&)", typeof(bool), typeof(QIODevice), file);
		}
		/// <remarks>
		///  Calling this function will reset the calculated message digest.
		///  Use this method to perform another message digest calculation
		///  without recreating the KMD4 object.
		///    </remarks>		<short>    Calling this function will reset the calculated message digest.</short>
		public void Reset() {
			interceptor.Invoke("reset", "reset()", typeof(void));
		}
		/// <remarks>
		/// </remarks>		<return> the raw representation of the digest
		///    </return>
		/// 		<short>   </short>
		/// <remarks>
		///  Returns the value of the calculated message digest in
		///  a hexadecimal representation.
		///    </remarks>		<short>    Returns the value of the calculated message digest in  a hexadecimal representation.</short>
		public QByteArray HexDigest() {
			return (QByteArray) interceptor.Invoke("hexDigest", "hexDigest()", typeof(QByteArray));
		}
		/// <remarks>
		///  @overload
		///    </remarks>		<short>    @overload    </short>
		public void HexDigest(QByteArray arg1) {
			interceptor.Invoke("hexDigest#", "hexDigest(QByteArray&)", typeof(void), typeof(QByteArray), arg1);
		}
		/// <remarks>
		///  Returns the value of the calculated message digest in
		///  a base64-encoded representation.
		///    </remarks>		<short>    Returns the value of the calculated message digest in  a base64-encoded representation.</short>
		public QByteArray Base64Digest() {
			return (QByteArray) interceptor.Invoke("base64Digest", "base64Digest()", typeof(QByteArray));
		}
		/// <remarks>
		///  returns true if the calculated digest for the given
		///  message matches the given one.
		///    </remarks>		<short>    returns true if the calculated digest for the given  message matches the given one.</short>
		/// <remarks>
		///  @overload
		///    </remarks>		<short>    @overload    </short>
		public bool Verify(QByteArray arg1) {
			return (bool) interceptor.Invoke("verify#", "verify(const QByteArray&)", typeof(bool), typeof(QByteArray), arg1);
		}
		~KMD4() {
			interceptor.Invoke("~KMD4", "~KMD4()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KMD4", "~KMD4()", typeof(void));
		}
	}
}
