//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  If you develop a library that is to be loaded dynamically at runtime, then
	///  you should return a pointer to your factory. The K_EXPORT_COMPONENT_FACTORY
	///  macro is provided for this purpose:
	///  <pre>
	///    K_EXPORT_COMPONENT_FACTORY( libkspread, KSpreadFactory )
	///  </pre>
	///  The first macro argument is the name of your library, the second specifies the name
	///  of your factory.
	///  NOTE: you probably want to use KGenericFactory<PluginClassName>
	///  instead of writing your own factory.
	///  In the constructor of your factory you should create an instance of KComponentData
	///  like this:
	///  <pre>
	///      s_global = new KComponentData( "kspread" );
	///  </pre>
	///  This KComponentData is comparable to KGlobal used by normal applications.
	///  It allows you to find resource files (images, XML, sound etc.) belonging
	///  to the library.
	///  If you want to load a library, use KLibLoader. You can query KLibLoader
	///  directly for a pointer to the libraries factory by using the KLibLoader.Factory()
	///  function.
	///  The KLibFactory is used to create the components that the library has to offer.
	///  The factory of KSpread for example will create instances of KSpreadDoc,
	///  while the Konqueror factory will create KonqView widgets.
	///  All objects created by the factory must be derived from QObject, since QObject
	///  offers type safe casting.
	///  KLibFactory is an abstract class. Reimplement the
	///  createObject() method to give it functionality.
	///  See <see cref="IKLibFactorySignals"></see> for signals emitted by KLibFactory
	/// </remarks>		<author> Torben Weis <weis@kde.org>
	///  </author>
	/// 		<short>    If you develop a library that is to be loaded dynamically at runtime, then  you should return a pointer to your factory.</short>

	[SmokeClass("KLibFactory")]
	public abstract class KLibFactory : QObject {
 		protected KLibFactory(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KLibFactory), this);
		}
		// template<typename T> T* create(QObject* arg1,const QStringList& arg2); >>>> NOT CONVERTED
		// template<typename T> T* create(QObject* arg1); >>>> NOT CONVERTED
		// template<typename T> T* create(); >>>> NOT CONVERTED
		/// <remarks>
		///  Create a new factory.
		/// <param> name="parent" the parent of the QObject, 0 for no parent
		///      </param></remarks>		<short>    Create a new factory.</short>
		public KLibFactory(QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KLibFactory#", "KLibFactory(QObject*)", typeof(void), typeof(QObject), parent);
		}
		public KLibFactory() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KLibFactory", "KLibFactory()", typeof(void));
		}
		/// <remarks>
		///  Creates a new object. The returned object has to be derived from
		///  the requested classname.
		///  It is valid behavior to create different kinds of objects
		///  depending on the requested <code>classname.</code> For example a koffice
		///  library may usually return a pointer to KoDocument.  But
		///  if asked for a "QWidget", it could create a wrapper widget,
		///  that encapsulates the Koffice specific features.
		///  create() automatically emits a signal objectCreated to tell
		///  the library about its newly created object.  This is very
		///  important for reference counting, and allows unloading the
		///  library automatically once all its objects have been destroyed.
		/// <param> name="parent" the parent of the QObject, 0 for no parent
		/// </param><param> name="classname" the name of the class
		/// </param><param> name="args" a list of arguments
		///      </param></remarks>		<short>    Creates a new object.</short>
		public QObject Create(QObject parent, string classname, List<string> args) {
			return (QObject) interceptor.Invoke("create#$?", "create(QObject*, const char*, const QStringList&)", typeof(QObject), typeof(QObject), parent, typeof(string), classname, typeof(List<string>), args);
		}
		public QObject Create(QObject parent, string classname) {
			return (QObject) interceptor.Invoke("create#$", "create(QObject*, const char*)", typeof(QObject), typeof(QObject), parent, typeof(string), classname);
		}
		public QObject Create(QObject parent) {
			return (QObject) interceptor.Invoke("create#", "create(QObject*)", typeof(QObject), typeof(QObject), parent);
		}
		public QObject Create() {
			return (QObject) interceptor.Invoke("create", "create()", typeof(QObject));
		}
		/// <remarks>
		///  This template function allows to ask the given factory to create an
		///  instance of the given template type.
		///  Example of usage:
		///  <pre>
		///      MyPlugin plugin = factory.Create&lt;MyPlugin&gt;( factory, parent );
		///  </pre>
		/// <param> name="pParent" The parent object (see QObject constructor)
		/// </param><param> name="args" A list of string arguments, passed to the factory and possibly
		///              to the component (see KLibFactory)
		/// </param></remarks>		<return> A pointer to the newly created object or a null pointer if the
		///          factory was unable to create an object of the given type.
		///      </return>
		/// 		<short>    This template function allows to ask the given factory to create an  instance of the given template type.</short>
		/// <remarks>
		///  Creates a new object. The returned object has to be derived from
		///  the requested classname.
		///  It is valid behavior to create different kinds of objects
		///  depending on the requested <code>className.</code> For example a koffice
		///  library may usually return a pointer to KoDocument.  But
		///  if asked for a "QWidget", it could create a wrapper widget,
		///  that encapsulates the Koffice specific features.
		///  This function is called by #create()
		/// <param> name="parent" the parent of the QObject, 0 for no parent
		/// </param><param> name="className" the name of the class
		/// </param><param> name="args" a list of arguments
		///      </param></remarks>		<short>    Creates a new object.</short>
		[SmokeMethod("createObject(QObject*, const char*, const QStringList&)")]
		protected abstract QObject CreateObject(QObject parent, string className, List<string> args);
		protected new IKLibFactorySignals Emit {
			get { return (IKLibFactorySignals) Q_EMIT; }
		}
	}

	public interface IKLibFactorySignals : IQObjectSignals {
		/// <remarks>
		///  Emitted in #create
		/// <param> name="obj" the new object
		///      </param></remarks>		<short>    Emitted in #create </short>
		[Q_SIGNAL("void objectCreated(QObject*)")]
		void ObjectCreated(QObject arg1);
	}
}
