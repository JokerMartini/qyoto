//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;

	/// <remarks>
	///  Maintains only a single instance of a running application at a time.
	///  Please note that this supports only one instance per KDE session. If
	///  your application can only be opened once per user or once per host, you
	///  need to ensure this independently of KUniqueApplication.
	///  If another instance
	///  is started, it will determine (via DBUS) whether it is the first instance
	///  or a second instance.  If it is a second instance, it will forward on
	///  the information to the first instance and then quit.
	///  The .desktop file for the application should state X-DBUS-StartupType=Unique,
	///  see ktoolinvocation.h
	///  If your application is used to open files, it should also support the --tempfile
	///  option (see KCmdLineArgs.AddTempFileOption()), to delete tempfiles after use.
	///  Add X-KDE-HasTempFileOption=true to the .desktop file to indicate this.
	/// </remarks>		<author> Preston Brown <pbrown@kde.org>
	///  </author>
	/// 		<short>    Maintains only a single instance of a running application at a time.</short>
	/// 		<see> KApplication</see>

	[SmokeClass("KUniqueApplication")]
	public class KUniqueApplication : KApplication, IDisposable {
 		protected KUniqueApplication(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KUniqueApplication), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KUniqueApplication() {
			staticInterceptor = new SmokeInvocation(typeof(KUniqueApplication), null);
		}
		/// <remarks>
		///  Constructor. Takes command line arguments from KCmdLineArgs
		/// <param> name="GUIenabled" Set to false to disable all GUI stuff. This implies
		///  no styles either.
		/// </param><param> name="configUnique" If true, the uniqueness of the application will
		///                  depend on the value of the "MultipleInstances"
		///                  key in the "KDE" group of the application config file.
		///    </param></remarks>		<short>    Constructor.</short>
		public KUniqueApplication(bool GUIenabled, bool configUnique) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUniqueApplication$$", "KUniqueApplication(bool, bool)", typeof(void), typeof(bool), GUIenabled, typeof(bool), configUnique);
		}
		public KUniqueApplication(bool GUIenabled) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUniqueApplication$", "KUniqueApplication(bool)", typeof(void), typeof(bool), GUIenabled);
		}
		public KUniqueApplication() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KUniqueApplication", "KUniqueApplication()", typeof(void));
		}
		/// <remarks>
		///  Creates a new "instance" of the application.
		///  Usually this will involve making some calls into the GUI portion of your
		///  application asking for a new window to be created, possibly with
		///  some data already loaded based on the arguments received.
		///  Command line arguments have been passed to KCmdLineArgs before this
		///  function is called and can be checked in the usual way.
		///  The default implementation ensures the mainwindow of the already
		///  running instance is shown and activated if necessary. You should
		///  prefer using it from your overridden method instead of doing
		///  it directly.
		///  Note that newInstance() is called also in the first started
		///  application process.
		/// </remarks>		<return> An exit value. The calling process will exit with this value.
		///    </return>
		/// 		<short>    Creates a new "instance" of the application.</short>
		[SmokeMethod("newInstance()")]
		public virtual int NewInstance() {
			return (int) interceptor.Invoke("newInstance", "newInstance()", typeof(int));
		}
		/// <remarks>
		///  Returns whether newInstance() is being called while session
		///  restoration is in progress.
		///    </remarks>		<short>    Returns whether newInstance() is being called while session  restoration is in progress.</short>
		public bool RestoringSession() {
			return (bool) interceptor.Invoke("restoringSession", "restoringSession()", typeof(bool));
		}
		~KUniqueApplication() {
			interceptor.Invoke("~KUniqueApplication", "~KUniqueApplication()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~KUniqueApplication", "~KUniqueApplication()", typeof(void));
		}
		/// <remarks>
		///  Adds command line options specific for KUniqueApplication.
		///  Should be called before calling KUniqueApplication constructor
		///  and / or start().
		///    </remarks>		<short>    Adds command line options specific for KUniqueApplication.</short>
		public static void AddCmdLineOptions() {
			staticInterceptor.Invoke("addCmdLineOptions", "addCmdLineOptions()", typeof(void));
		}
		/// <remarks>
		///  Forks and registers with D-Bus.
		///  The command line arguments are being sent via D-Bus to newInstance()
		///  and will be received once the application enters the event loop.
		///  Typically this is used like:
		///  <pre>
		///  int main(string[] args) {
		///     KAboutData about("myappname", 0, ki18n("myAppName"), .....);
		///     KCmdLineArgs.Init(args, &about);
		///     KCmdLineArgs.AddCmdLineOptions( myCmdOptions );
		///     KUniqueApplication.AddCmdLineOptions();
		///     if (!KUniqueApplication.Start()) {
		///        fprintf(stderr, "myAppName is already running!\n");
		///        return 0;
		///     }
		///     KUniqueApplication a;
		///     return a.exec();
		///  }
		///  </pre>
		///  Note that it's not necessary to call start() explicitly. It will be
		///  called automatically before creating KUniqueApplication if it hasn't
		///  been called yet, without any performance impact.
		///  Also note that you MUST call KUniqueApplication.AddCmdLineOptions(),
		///  if you use command line options before start() is called.
		/// </remarks>		<return> true if registration is successful.
		///          false if another process was already running.
		///    </return>
		/// 		<short>    Forks and registers with D-Bus.</short>
		public static bool Start() {
			return (bool) staticInterceptor.Invoke("start", "start()", typeof(bool));
		}
		/// <remarks>
		///    </remarks>		<short>   </short>
		public static void SetHandleAutoStarted() {
			staticInterceptor.Invoke("setHandleAutoStarted", "setHandleAutoStarted()", typeof(void));
		}
		protected new IKUniqueApplicationSignals Emit {
			get { return (IKUniqueApplicationSignals) Q_EMIT; }
		}
	}

	public interface IKUniqueApplicationSignals : IKApplicationSignals {
	}
}
