//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;


	[SmokeClass("KBookmark")]
	public class KBookmark : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KBookmark(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KBookmark), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KBookmark() {
			staticInterceptor = new SmokeInvocation(typeof(KBookmark), null);
		}
		public enum MetaDataOverwriteMode {
			OverwriteMetaData = 0,
			DontOverwriteMetaData = 1,
		}
		// KBookmarkGroup parentGroup(); >>>> NOT CONVERTED
		// KBookmarkGroup toGroup(); >>>> NOT CONVERTED
		public KBookmark() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KBookmark", "KBookmark()", typeof(void));
		}
		public KBookmark(QDomElement elem) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KBookmark#", "KBookmark(const QDomElement&)", typeof(void), typeof(QDomElement), elem);
		}
		/// <remarks>
		///  Whether the bookmark is a group or a normal bookmark
		///      </remarks>		<short>    Whether the bookmark is a group or a normal bookmark      </short>
		public bool IsGroup() {
			return (bool) interceptor.Invoke("isGroup", "isGroup() const", typeof(bool));
		}
		/// <remarks>
		///  Whether the bookmark is a separator
		///      </remarks>		<short>    Whether the bookmark is a separator      </short>
		public bool IsSeparator() {
			return (bool) interceptor.Invoke("isSeparator", "isSeparator() const", typeof(bool));
		}
		/// <remarks>
		/// </remarks>		<return> true if this is a null bookmark. This will never
		///  be the case for a real bookmark (in a menu), but it's used
		///  for instance as the end condition for KBookmarkGroup.Next()
		///      </return>
		/// 		<short>   </short>
		public bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		/// <remarks>
		/// </remarks>		<return> true if bookmark is contained by a QDomDocument,
		///  if not it is most likely that it has become separated and
		///  is thus invalid and/or has been deleted from the bookmarks.
		///      </return>
		/// 		<short>   </short>
		public bool HasParent() {
			return (bool) interceptor.Invoke("hasParent", "hasParent() const", typeof(bool));
		}
		/// <remarks>
		///  Text shown for the bookmark
		///  If bigger than 40, the text is shortened by
		///  replacing middle characters with "..." (see KStringHandler.Csqueeze)
		///      </remarks>		<short>    Text shown for the bookmark  If bigger than 40, the text is shortened by  replacing middle characters with ".</short>
		public string Text() {
			return (string) interceptor.Invoke("text", "text() const", typeof(string));
		}
		/// <remarks>
		///  Text shown for the bookmark, not truncated.
		///  You should not use this - this is mainly for keditbookmarks.
		///      </remarks>		<short>    Text shown for the bookmark, not truncated.</short>
		public string FullText() {
			return (string) interceptor.Invoke("fullText", "fullText() const", typeof(string));
		}
		/// <remarks>
		///  Set the text shown for the bookmark.
		/// <param> name="fullText" the new bookmark title
		///      </param></remarks>		<short>    Set the text shown for the bookmark.</short>
		public void SetFullText(string fullText) {
			interceptor.Invoke("setFullText$", "setFullText(const QString&)", typeof(void), typeof(string), fullText);
		}
		/// <remarks>
		///  URL contained by the bookmark
		///      </remarks>		<short>    URL contained by the bookmark      </short>
		public KUrl Url() {
			return (KUrl) interceptor.Invoke("url", "url() const", typeof(KUrl));
		}
		/// <remarks>
		///  Set the URL of the bookmark
		/// <param> name="url" the new bookmark URL
		///      </param></remarks>		<short>    Set the URL of the bookmark </short>
		public void SetUrl(KUrl url) {
			interceptor.Invoke("setUrl#", "setUrl(const KUrl&)", typeof(void), typeof(KUrl), url);
		}
		/// <remarks>
		/// </remarks>		<return> the pixmap file for this bookmark
		///  (i.e. the name of the icon)
		///      </return>
		/// 		<short>   </short>
		public string Icon() {
			return (string) interceptor.Invoke("icon", "icon() const", typeof(string));
		}
		/// <remarks>
		///  Set the icon name of the bookmark
		/// <param> name="icon" the new icon name for this bookmark
		///      </param></remarks>		<short>    Set the icon name of the bookmark </short>
		public void SetIcon(string icon) {
			interceptor.Invoke("setIcon$", "setIcon(const QString&)", typeof(void), typeof(string), icon);
		}
		/// <remarks>
		/// </remarks>		<return> the group containing this bookmark
		///      </return>
		/// 		<short>   </short>
		/// <remarks>
		///  Convert this to a group - do this only if
		///  isGroup() returns true.
		///      </remarks>		<short>    Convert this to a group - do this only if  isGroup() returns true.</short>
		/// <remarks>
		///  Return the "address" of this bookmark in the whole tree.
		///  This is used when telling other processes about a change
		///  in a given bookmark. The encoding of the address is "/4/2", for
		///  instance, to design the 2nd child inside the 4th child of the root bk.
		///      </remarks>		<short>    Return the "address" of this bookmark in the whole tree.</short>
		public string Address() {
			return (string) interceptor.Invoke("address", "address() const", typeof(string));
		}
		/// <remarks>
		///      </remarks>		<short>   </short>
		public QDomElement InternalElement() {
			return (QDomElement) interceptor.Invoke("internalElement", "internalElement() const", typeof(QDomElement));
		}
		/// <remarks>
		///  Updates the bookmarks access metadata
		///  Call when a user accesses the bookmark
		///      </remarks>		<short>    Updates the bookmarks access metadata  Call when a user accesses the bookmark      </short>
		public void UpdateAccessMetadata() {
			interceptor.Invoke("updateAccessMetadata", "updateAccessMetadata()", typeof(void));
		}
		/// <remarks>
		///  Get the value of a specific metadata item.
		/// <param> name="key" Name of the metadata item
		/// </param></remarks>		<return> Value of the metadata item. string() is returned in case
		///  the specified key does not exist.
		///      </return>
		/// 		<short>    Get the value of a specific metadata item.</short>
		public string MetaDataItem(string key) {
			return (string) interceptor.Invoke("metaDataItem$", "metaDataItem(const QString&) const", typeof(string), typeof(string), key);
		}
		/// <remarks>
		///  Change the value of a specific metadata item, or create the given item
		///  if it doesn't exist already.
		/// <param> name="key" Name of the metadata item to change
		/// </param><param> name="value" Value to use for the specified metadata item
		/// </param><param> name="mode" Whether to overwrite the item's value if it exists already or not.
		///      </param></remarks>		<short>    Change the value of a specific metadata item, or create the given item  if it doesn't exist already.</short>
		public void SetMetaDataItem(string key, string value, KBookmark.MetaDataOverwriteMode mode) {
			interceptor.Invoke("setMetaDataItem$$$", "setMetaDataItem(const QString&, const QString&, KBookmark::MetaDataOverwriteMode)", typeof(void), typeof(string), key, typeof(string), value, typeof(KBookmark.MetaDataOverwriteMode), mode);
		}
		public void SetMetaDataItem(string key, string value) {
			interceptor.Invoke("setMetaDataItem$$", "setMetaDataItem(const QString&, const QString&)", typeof(void), typeof(string), key, typeof(string), value);
		}
		/// <remarks>
		///  Adds this bookmark into the given QMimeData.
		///  WARNING: do not call this method multiple times, use KBookmark.List.PopulateMimeData instead.
		/// <param> name="mimeData" the QMimeData instance used to drag or copy this bookmark
		///      </param></remarks>		<short>    Adds this bookmark into the given QMimeData.</short>
		public void PopulateMimeData(QMimeData mimeData) {
			interceptor.Invoke("populateMimeData#", "populateMimeData(QMimeData*) const", typeof(void), typeof(QMimeData), mimeData);
		}
		~KBookmark() {
			interceptor.Invoke("~KBookmark", "~KBookmark()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KBookmark", "~KBookmark()", typeof(void));
		}
		public static KBookmark StandaloneBookmark(string text, KUrl url, string icon) {
			return (KBookmark) staticInterceptor.Invoke("standaloneBookmark$#$", "standaloneBookmark(const QString&, const KUrl&, const QString&)", typeof(KBookmark), typeof(string), text, typeof(KUrl), url, typeof(string), icon);
		}
		public static KBookmark StandaloneBookmark(string text, KUrl url) {
			return (KBookmark) staticInterceptor.Invoke("standaloneBookmark$#", "standaloneBookmark(const QString&, const KUrl&)", typeof(KBookmark), typeof(string), text, typeof(KUrl), url);
		}
		/// <remarks>
		/// </remarks>		<return> address of parent
		///      </return>
		/// 		<short>   </short>
		public static string ParentAddress(string address) {
			return (string) staticInterceptor.Invoke("parentAddress$", "parentAddress(const QString&)", typeof(string), typeof(string), address);
		}
		/// <remarks>
		/// </remarks>		<return> position in parent (e.g. /4/5/2 . 2)
		///      </return>
		/// 		<short>   </short>
		public static uint PositionInParent(string address) {
			return (uint) staticInterceptor.Invoke("positionInParent$", "positionInParent(const QString&)", typeof(uint), typeof(string), address);
		}
		/// <remarks>
		/// </remarks>		<return> address of previous sibling (e.g. /4/5/2 . /4/5/1)
		///  Returns string() for a first child
		///      </return>
		/// 		<short>   </short>
		public static string PreviousAddress(string address) {
			return (string) staticInterceptor.Invoke("previousAddress$", "previousAddress(const QString&)", typeof(string), typeof(string), address);
		}
		/// <remarks>
		/// </remarks>		<return> address of next sibling (e.g. /4/5/2 . /4/5/3)
		///  This doesn't check whether it actually exists
		///      </return>
		/// 		<short>   </short>
		public static string NextAddress(string address) {
			return (string) staticInterceptor.Invoke("nextAddress$", "nextAddress(const QString&)", typeof(string), typeof(string), address);
		}
		/// <remarks>
		/// </remarks>		<return> the common parent of both addresses which
		///  has the greatest depth
		///      </return>
		/// 		<short>   </short>
		public static string CommonParent(string A, string B) {
			return (string) staticInterceptor.Invoke("commonParent$$", "commonParent(const QString&, const QString&)", typeof(string), typeof(string), A, typeof(string), B);
		}
	}
}
