//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;


	[SmokeClass("KSMIMECrypto")]
	public class KSMIMECrypto : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected KSMIMECrypto(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KSMIMECrypto), this);
		}
		public enum algo {
			KSC_C_DES3_CBC = 1,
			KSC_C_RC2_CBC_128 = 2,
			KSC_C_RC2_CBC_64 = 3,
			KSC_C_DES_CBC = 4,
			KSC_C_RC2_CBC_40 = 5,
		}
		public enum rc {
			KSC_R_OK = 0,
			KSC_R_OTHER = 1,
			KSC_R_NO_SSL = 2,
			KSC_R_NOCIPHER = 3,
			KSC_R_NOMEM = 4,
			KSC_R_FORMAT = 5,
			KSC_R_WRONGKEY = 6,
			KSC_R_VERIFY = 7,
		}
		public KSMIMECrypto() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("KSMIMECrypto", "KSMIMECrypto()", typeof(void));
		}
		/// <remarks>
		///  Sign a message
		/// <param> name="clearText" MIME representation of the message (part) to sign
		/// </param><param> name="cipherText" signature to append or signature block
		/// </param><param> name="privKey" private key/certificate to sign with
		/// </param><param> name="certs" additional certificates (may be empty)
		/// </param><param> name="detached" create detached or opaque signature
		/// </param></remarks>		<return> 0 on success
		///      </return>
		/// 		<short>    Sign a message </short>
		public KSMIMECrypto.rc SignMessage(QByteArray clearText, QByteArray cipherText, KSSLPKCS12 privKey, List<KSSLCertificate> certs, bool detached) {
			return (KSMIMECrypto.rc) interceptor.Invoke("signMessage###?$", "signMessage(const QByteArray&, QByteArray&, const KSSLPKCS12&, const QList<KSSLCertificate*>&, bool)", typeof(KSMIMECrypto.rc), typeof(QByteArray), clearText, typeof(QByteArray), cipherText, typeof(KSSLPKCS12), privKey, typeof(List<KSSLCertificate>), certs, typeof(bool), detached);
		}
		/// <remarks>
		///  Check a detached message signature
		///  Will check if messages matches signature and extract certificates
		///  Does not check certificates for validity!
		/// <param> name="clearText" MIME representation of signed message (without SIG)
		/// </param><param> name="signature" signature
		/// </param><param> name="foundCerts" certificates found in this message
		/// </param></remarks>		<return> 0 on success
		///      </return>
		/// 		<short>    Check a detached message signature  Will check if messages matches signature and extract certificates  Does not check certificates for validity! </short>
		public KSMIMECrypto.rc CheckDetachedSignature(QByteArray clearText, QByteArray signature, List<KSSLCertificate> foundCerts) {
			return (KSMIMECrypto.rc) interceptor.Invoke("checkDetachedSignature##?", "checkDetachedSignature(const QByteArray&, const QByteArray&, QList<KSSLCertificate*>&)", typeof(KSMIMECrypto.rc), typeof(QByteArray), clearText, typeof(QByteArray), signature, typeof(List<KSSLCertificate>), foundCerts);
		}
		/// <remarks>
		///  Check an opaque signed message
		///  Will check if signature matches and extract message
		///  Does not check certificates for validity!
		/// <param> name="signedText" signed message block
		/// </param><param> name="clearText" cleartext of signed message
		/// </param><param> name="foundCerts" certificates found in this mesasge
		/// </param></remarks>		<return> 0 on success
		///      </return>
		/// 		<short>    Check an opaque signed message  Will check if signature matches and extract message  Does not check certificates for validity! </short>
		public KSMIMECrypto.rc CheckOpaqueSignature(QByteArray signedText, QByteArray clearText, List<KSSLCertificate> foundCerts) {
			return (KSMIMECrypto.rc) interceptor.Invoke("checkOpaqueSignature##?", "checkOpaqueSignature(const QByteArray&, QByteArray&, QList<KSSLCertificate*>&)", typeof(KSMIMECrypto.rc), typeof(QByteArray), signedText, typeof(QByteArray), clearText, typeof(List<KSSLCertificate>), foundCerts);
		}
		/// <remarks>
		///  Encrypt a message
		///  encrypts a message for the given list of recipients and the
		///  selected algorithm. Note that any algorithm <128 bytes is
		///  insecure and should never be used, even if SMIME-2 requires
		///  only RC2-40
		/// <param> name="clearText" MIME representation of message to encrypt
		/// </param><param> name="cipherText" returned encrypted message
		/// </param><param> name="algorithm" encryption algorithm
		/// </param><param> name="recip" recipient certificates
		/// </param></remarks>		<return> 0 on success
		///      </return>
		/// 		<short>    Encrypt a message  encrypts a message for the given list of recipients and the  selected algorithm.</short>
		public KSMIMECrypto.rc EncryptMessage(QByteArray clearText, QByteArray cipherText, KSMIMECrypto.algo algorithm, List<KSSLCertificate> recip) {
			return (KSMIMECrypto.rc) interceptor.Invoke("encryptMessage##$?", "encryptMessage(const QByteArray&, QByteArray&, KSMIMECrypto::algo, const QList<KSSLCertificate*>&)", typeof(KSMIMECrypto.rc), typeof(QByteArray), clearText, typeof(QByteArray), cipherText, typeof(KSMIMECrypto.algo), algorithm, typeof(List<KSSLCertificate>), recip);
		}
		/// <remarks>
		///  Decrypt a message
		/// <param> name="cipherText" encrypted message block
		/// </param><param> name="clearText" returns decrypted message
		/// </param><param> name="privKey" private key to use
		/// </param></remarks>		<return> 0 on success
		///      </return>
		/// 		<short>    Decrypt a message </short>
		public KSMIMECrypto.rc DecryptMessage(QByteArray cipherText, QByteArray clearText, KSSLPKCS12 privKey) {
			return (KSMIMECrypto.rc) interceptor.Invoke("decryptMessage###", "decryptMessage(const QByteArray&, QByteArray&, const KSSLPKCS12&)", typeof(KSMIMECrypto.rc), typeof(QByteArray), cipherText, typeof(QByteArray), clearText, typeof(KSSLPKCS12), privKey);
		}
		~KSMIMECrypto() {
			interceptor.Invoke("~KSMIMECrypto", "~KSMIMECrypto()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~KSMIMECrypto", "~KSMIMECrypto()", typeof(void));
		}
	}
}
