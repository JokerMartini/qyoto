//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KIO {

	using System;
	using Qyoto;

	/// <remarks>
	///  A simple job (one url and one command).
	///  This is the base class for all jobs that are scheduled.
	///  Other jobs are high-level jobs (CopyJob, DeleteJob, FileCopyJob...)
	///  that manage subjobs but aren't scheduled directly.
	///      </remarks>		<short>    A simple job (one url and one command).</short>

	[SmokeClass("KIO::SimpleJob")]
	public class SimpleJob : KIO.Job, IDisposable {
 		protected SimpleJob(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(SimpleJob), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static SimpleJob() {
			staticInterceptor = new SmokeInvocation(typeof(SimpleJob), null);
		}
		/// <remarks>
		///  Creates a new simple job. You don't need to use this constructor,
		///  unless you create a new job that inherits from SimpleJob.
		/// <param> name="url" the url of the job
		/// </param><param> name="command" the command of the job
		/// </param><param> name="packedArgs" the arguments
		/// 	 </param></remarks>		<short>    Creates a new simple job.</short>
		public SimpleJob(KUrl url, int command, QByteArray packedArgs) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("SimpleJob#$#", "SimpleJob(const KUrl&, int, const QByteArray&)", typeof(void), typeof(KUrl), url, typeof(int), command, typeof(QByteArray), packedArgs);
		}
		[SmokeMethod("start()")]
		public override void Start() {
			interceptor.Invoke("start", "start()", typeof(void));
		}
		/// <remarks>
		///  Suspend this job
		/// </remarks>		<short>    Suspend this job </short>
		/// 		<see> resume</see>
		[SmokeMethod("doSuspend()")]
		public override bool DoSuspend() {
			return (bool) interceptor.Invoke("doSuspend", "doSuspend()", typeof(bool));
		}
		/// <remarks>
		///  Resume this job
		/// </remarks>		<short>    Resume this job </short>
		/// 		<see> suspend</see>
		[SmokeMethod("doResume()")]
		public override bool DoResume() {
			return (bool) interceptor.Invoke("doResume", "doResume()", typeof(bool));
		}
		/// <remarks>
		///  Returns the SimpleJob's URL
		/// </remarks>		<return> the url
		/// 	 </return>
		/// 		<short>    Returns the SimpleJob's URL </short>
		public KUrl Url() {
			return (KUrl) interceptor.Invoke("url", "url() const", typeof(KUrl));
		}
		/// <remarks>
		///  Abort job.
		///  This kills all subjobs and deletes the job.
		///          </remarks>		<short>    Abort job.</short>
		[SmokeMethod("doKill()")]
		public override bool DoKill() {
			return (bool) interceptor.Invoke("doKill", "doKill()", typeof(bool));
		}
		/// <remarks>
		///  Abort job.
		///  Suspends slave to be reused by another job for the same request.
		///          </remarks>		<short>    Abort job.</short>
		[SmokeMethod("putOnHold()")]
		public virtual void PutOnHold() {
			interceptor.Invoke("putOnHold", "putOnHold()", typeof(void));
		}
		/// <remarks>
		///  Called by the scheduler when a slave gets to
		///  work on this job.
		/// </remarks>		<short>   </short>
		[SmokeMethod("start(KIO::Slave*)")]
		public virtual void Start(KIO.Slave slave) {
			interceptor.Invoke("start#", "start(KIO::Slave*)", typeof(void), typeof(KIO.Slave), slave);
		}
		/// <remarks>
		///  Called to detach a slave from a job.
		/// </remarks>		<short>   </short>
		public void SlaveDone() {
			interceptor.Invoke("slaveDone", "slaveDone()", typeof(void));
		}
		/// <remarks>
		///  Slave in use by this job.
		///          </remarks>		<short>   </short>
		public KIO.Slave Slave() {
			return (KIO.Slave) interceptor.Invoke("slave", "slave() const", typeof(KIO.Slave));
		}
		/// <remarks>
		///          </remarks>		<short>   </short>
		public int command() {
			return (int) interceptor.Invoke("command", "command() const", typeof(int));
		}
		/// <remarks>
		///  Forward signal from the slave
		///  Can also be called by the parent job, when it knows the size.
		/// <param> name="data_size" the total size
		///          </param></remarks>		<short>    Forward signal from the slave  Can also be called by the parent job, when it knows the size.</short>
		[Q_SLOT("void slotTotalSize(KIO::filesize_t)")]
		public void SlotTotalSize(long data_size) {
			interceptor.Invoke("slotTotalSize$", "slotTotalSize(KIO::filesize_t)", typeof(void), typeof(long), data_size);
		}
		/// <remarks>
		///  Called on a slave's error.
		///  Made public for the scheduler.
		///          </remarks>		<short>   </short>
		[Q_SLOT("void slotError(int, const QString&)")]
		[SmokeMethod("slotError(int, const QString&)")]
		public virtual void SlotError(int arg1, string arg2) {
			interceptor.Invoke("slotError$$", "slotError(int, const QString&)", typeof(void), typeof(int), arg1, typeof(string), arg2);
		}
		protected void StoreSSLSessionFromJob(KUrl m_redirectionURL) {
			interceptor.Invoke("storeSSLSessionFromJob#", "storeSSLSessionFromJob(const KUrl&)", typeof(void), typeof(KUrl), m_redirectionURL);
		}
		/// <remarks>
		///  Called when the slave marks the job
		///  as finished.
		///          </remarks>		<short>    Called when the slave marks the job  as finished.</short>
		[Q_SLOT("void slotFinished()")]
		[SmokeMethod("slotFinished()")]
		protected virtual void SlotFinished() {
			interceptor.Invoke("slotFinished", "slotFinished()", typeof(void));
		}
		/// <remarks>
		///  Called on a slave's warning.
		///          </remarks>		<short>   </short>
		[Q_SLOT("void slotWarning(const QString&)")]
		[SmokeMethod("slotWarning(const QString&)")]
		protected virtual void SlotWarning(string arg1) {
			interceptor.Invoke("slotWarning$", "slotWarning(const QString&)", typeof(void), typeof(string), arg1);
		}
		/// <remarks>
		///  Called on a slave's info message.
		/// <param> name="s" the info message
		/// </param></remarks>		<short>    Called on a slave's info message.</short>
		/// 		<see> infoMessage</see>
		[Q_SLOT("void slotInfoMessage(const QString&)")]
		[SmokeMethod("slotInfoMessage(const QString&)")]
		protected virtual void SlotInfoMessage(string s) {
			interceptor.Invoke("slotInfoMessage$", "slotInfoMessage(const QString&)", typeof(void), typeof(string), s);
		}
		/// <remarks>
		///  Called on a slave's connected signal.
		/// </remarks>		<short>    Called on a slave's connected signal.</short>
		/// 		<see> connected</see>
		[Q_SLOT("void slotConnected()")]
		protected void SlotConnected() {
			interceptor.Invoke("slotConnected", "slotConnected()", typeof(void));
		}
		/// <remarks>
		///  Forward signal from the slave.
		/// <param> name="data_size" the processed size in bytes
		/// </param></remarks>		<short>    Forward signal from the slave.</short>
		/// 		<see> processedSize</see>
		[Q_SLOT("void slotProcessedSize(KIO::filesize_t)")]
		protected void SlotProcessedSize(long data_size) {
			interceptor.Invoke("slotProcessedSize$", "slotProcessedSize(KIO::filesize_t)", typeof(void), typeof(long), data_size);
		}
		/// <remarks>
		///  Forward signal from the slave.
		/// <param> name="speed" the speed in bytes/s
		/// </param></remarks>		<short>    Forward signal from the slave.</short>
		/// 		<see> speed</see>
		[Q_SLOT("void slotSpeed(unsigned long)")]
		protected void SlotSpeed(ulong speed) {
			interceptor.Invoke("slotSpeed$", "slotSpeed(unsigned long)", typeof(void), typeof(ulong), speed);
		}
		/// <remarks>
		///  MetaData from the slave is received.
		/// <param> name="_metaData" the meta data
		/// </param></remarks>		<short>    MetaData from the slave is received.</short>
		/// 		<see> metaData</see>
		[Q_SLOT("void slotMetaData(const KIO::MetaData&)")]
		[SmokeMethod("slotMetaData(const KIO::MetaData&)")]
		protected virtual void SlotMetaData(KIO.MetaData _metaData) {
			interceptor.Invoke("slotMetaData#", "slotMetaData(const KIO::MetaData&)", typeof(void), typeof(KIO.MetaData), _metaData);
		}
		~SimpleJob() {
			interceptor.Invoke("~SimpleJob", "~SimpleJob()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~SimpleJob", "~SimpleJob()", typeof(void));
		}
		/// <remarks>
		///  Discard suspended slave.
		///          </remarks>		<short>    Discard suspended slave.</short>
		public static void RemoveOnHold() {
			staticInterceptor.Invoke("removeOnHold", "removeOnHold()", typeof(void));
		}
		protected new ISimpleJobSignals Emit {
			get { return (ISimpleJobSignals) Q_EMIT; }
		}
	}

	public interface ISimpleJobSignals : KIO.IJobSignals {
	}
	}
}
