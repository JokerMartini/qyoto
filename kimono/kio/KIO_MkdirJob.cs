//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KIO {

	using System;
	using Qyoto;

	/// <remarks>
	///  A KIO job that creates a directory
	///  See <see cref="IMkdirJobSignals"></see> for signals emitted by MkdirJob
	/// </remarks>		<short>    A KIO job that creates a directory </short>
	/// 		<see> mkdir</see>

	[SmokeClass("KIO::MkdirJob")]
	public class MkdirJob : KIO.SimpleJob, IDisposable {
 		protected MkdirJob(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(MkdirJob), this);
		}
		/// <remarks>
		///  Do not use this constructor to create a MkdirJob, use KIO.Mkdir() instead.
		/// <param> name="url" the url of the file or directory to check
		/// </param><param> name="command" the command to issue
		/// </param><param> name="packedArgs" the arguments
		/// 	 </param></remarks>		<short>    Do not use this constructor to create a MkdirJob, use KIO.Mkdir() instead.</short>
		public MkdirJob(KUrl url, int command, QByteArray packedArgs) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("MkdirJob#$#", "MkdirJob(const KUrl&, int, const QByteArray&)", typeof(void), typeof(KUrl), url, typeof(int), command, typeof(QByteArray), packedArgs);
		}
		/// <remarks>
		///  Called by the scheduler when a <code>slave</code> gets to
		///  work on this job.
		/// <param> name="slave" the slave that starts working on this job
		///          </param></remarks>		<short>   </short>
		[SmokeMethod("start(KIO::Slave*)")]
		public override void Start(KIO.Slave slave) {
			interceptor.Invoke("start#", "start(KIO::Slave*)", typeof(void), typeof(KIO.Slave), slave);
		}
		[Q_SLOT("void slotRedirection(const KUrl&)")]
		protected void SlotRedirection(KUrl url) {
			interceptor.Invoke("slotRedirection#", "slotRedirection(const KUrl&)", typeof(void), typeof(KUrl), url);
		}
		[Q_SLOT("void slotFinished()")]
		[SmokeMethod("slotFinished()")]
		protected override void SlotFinished() {
			interceptor.Invoke("slotFinished", "slotFinished()", typeof(void));
		}
		~MkdirJob() {
			interceptor.Invoke("~MkdirJob", "~MkdirJob()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~MkdirJob", "~MkdirJob()", typeof(void));
		}
		protected new IMkdirJobSignals Emit {
			get { return (IMkdirJobSignals) Q_EMIT; }
		}
	}

	public interface IMkdirJobSignals : KIO.ISimpleJobSignals {
		/// <remarks>
		///  Signals a redirection.
		///  Use to update the URL shown to the user.
		///  The redirection itself is handled internally.
		/// <param> name="job" the job that is redirected
		/// </param><param> name="url" the new url
		///          </param></remarks>		<short>    Signals a redirection.</short>
		[Q_SIGNAL("void redirection(KIO::Job*, const KUrl&)")]
		void Redirection(KIO.Job job, KUrl url);
		/// <remarks>
		///  Signals a permanent redirection.
		///  The redirection itself is handled internally.
		/// <param> name="job" the job that is redirected
		/// </param><param> name="fromUrl" the original URL
		/// </param><param> name="toUrl" the new URL
		///          </param></remarks>		<short>    Signals a permanent redirection.</short>
		[Q_SIGNAL("void permanentRedirection(KIO::Job*, const KUrl&, const KUrl&)")]
		void PermanentRedirection(KIO.Job job, KUrl fromUrl, KUrl toUrl);
	}
	}
}
