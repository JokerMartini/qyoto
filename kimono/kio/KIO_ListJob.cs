//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KIO {

	using System;
	using Qyoto;

	/// <remarks>
	///  A ListJob is allows you to get the get the content of a directory.
	///  Don't create the job directly, but use KIO.ListRecursive() or
	///  KIO.ListDir() instead.
	///  See <see cref="IListJobSignals"></see> for signals emitted by ListJob
	/// </remarks>		<short>    A ListJob is allows you to get the get the content of a directory.</short>
	/// 		<see> listRecursive</see>
	/// 		<see> listDir</see>

	[SmokeClass("KIO::ListJob")]
	public class ListJob : KIO.SimpleJob, IDisposable {
 		protected ListJob(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(ListJob), this);
		}
		// void slotListEntries(const KIO::UDSEntryList& arg1); >>>> NOT CONVERTED
		// void gotEntries(KIO::Job* arg1,const KIO::UDSEntryList& arg2); >>>> NOT CONVERTED
		/// <remarks>
		///  Do not create a ListJob directly. Use KIO.ListDir() or
		///  KIO.ListRecursive() instead.
		/// <param> name="url" the url of the directory
		/// </param><param> name="recursive" true to get the data recursively from child directories,
		///         false to get only the content of the specified dir
		/// </param><param> name="prefix" the prefix of the files, or string() for no prefix
		/// </param><param> name="includeHidden" true to include hidden files (those starting with '.')
		/// 	</param></remarks>		<short>    Do not create a ListJob directly.</short>
		public ListJob(KUrl url, bool recursive, string prefix, bool includeHidden) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("ListJob#$$$", "ListJob(const KUrl&, bool, const QString&, bool)", typeof(void), typeof(KUrl), url, typeof(bool), recursive, typeof(string), prefix, typeof(bool), includeHidden);
		}
		public ListJob(KUrl url, bool recursive, string prefix) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("ListJob#$$", "ListJob(const KUrl&, bool, const QString&)", typeof(void), typeof(KUrl), url, typeof(bool), recursive, typeof(string), prefix);
		}
		public ListJob(KUrl url, bool recursive) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("ListJob#$", "ListJob(const KUrl&, bool)", typeof(void), typeof(KUrl), url, typeof(bool), recursive);
		}
		public ListJob(KUrl url) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("ListJob#", "ListJob(const KUrl&)", typeof(void), typeof(KUrl), url);
		}
		/// <remarks>
		///  Called by the scheduler when a <code>slave</code> gets to
		///  work on this job.
		/// <param> name="slave" the slave that starts working on this job
		///          </param></remarks>		<short>   </short>
		[SmokeMethod("start(KIO::Slave*)")]
		public override void Start(KIO.Slave slave) {
			interceptor.Invoke("start#", "start(KIO::Slave*)", typeof(void), typeof(KIO.Slave), slave);
		}
		/// <remarks>
		///  Returns the ListJob's redirection URL. This will be invalid if there
		///  was no redirection.
		/// </remarks>		<return> the redirection url
		///          </return>
		/// 		<short>    Returns the ListJob's redirection URL.</short>
		public KUrl RedirectionUrl() {
			return (KUrl) interceptor.Invoke("redirectionUrl", "redirectionUrl() const", typeof(KUrl));
		}
		/// <remarks>
		///  Do not apply any KIOSK restrictions to this job.
		///          </remarks>		<short>    Do not apply any KIOSK restrictions to this job.</short>
		public void SetUnrestricted(bool unrestricted) {
			interceptor.Invoke("setUnrestricted$", "setUnrestricted(bool)", typeof(void), typeof(bool), unrestricted);
		}
		[Q_SLOT("void slotFinished()")]
		[SmokeMethod("slotFinished()")]
		protected override void SlotFinished() {
			interceptor.Invoke("slotFinished", "slotFinished()", typeof(void));
		}
		[Q_SLOT("void slotMetaData(const KIO::MetaData&)")]
		[SmokeMethod("slotMetaData(const KIO::MetaData&)")]
		protected override void SlotMetaData(KIO.MetaData _metaData) {
			interceptor.Invoke("slotMetaData#", "slotMetaData(const KIO::MetaData&)", typeof(void), typeof(KIO.MetaData), _metaData);
		}
		[Q_SLOT("void slotResult(KJob*)")]
		[SmokeMethod("slotResult(KJob*)")]
		protected override void SlotResult(KJob job) {
			interceptor.Invoke("slotResult#", "slotResult(KJob*)", typeof(void), typeof(KJob), job);
		}
		[Q_SLOT("void slotRedirection(const KUrl&)")]
		protected void SlotRedirection(KUrl url) {
			interceptor.Invoke("slotRedirection#", "slotRedirection(const KUrl&)", typeof(void), typeof(KUrl), url);
		}
		~ListJob() {
			interceptor.Invoke("~ListJob", "~ListJob()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~ListJob", "~ListJob()", typeof(void));
		}
		protected new IListJobSignals Emit {
			get { return (IListJobSignals) Q_EMIT; }
		}
	}

	public interface IListJobSignals : KIO.ISimpleJobSignals {
		// void entries(KIO::Job* arg1,const KIO::UDSEntryList& arg2); >>>> NOT CONVERTED
		/// <remarks>
		///  Signals a redirection.
		///  Use to update the URL shown to the user.
		///  The redirection itself is handled internally.
		/// <param> name="job" the job that is redirected
		/// </param><param> name="url" the new url
		///          </param></remarks>		<short>    Signals a redirection.</short>
		[Q_SIGNAL("void redirection(KIO::Job*, const KUrl&)")]
		void Redirection(KIO.Job job, KUrl url);
		/// <remarks>
		///  Signals a permanent redirection.
		///  The redirection itself is handled internally.
		/// <param> name="job" the job that emitted this signal
		/// </param><param> name="fromUrl" the original URL
		/// </param><param> name="toUrl" the new URL
		///          </param></remarks>		<short>    Signals a permanent redirection.</short>
		[Q_SIGNAL("void permanentRedirection(KIO::Job*, const KUrl&, const KUrl&)")]
		void PermanentRedirection(KIO.Job job, KUrl fromUrl, KUrl toUrl);
	}
	}
}
