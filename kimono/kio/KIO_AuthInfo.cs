//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KIO {

	using System;
	using Qyoto;

	/// <remarks>
	///  This class is intended to make it easier to prompt for, cache
	///  and retrieve authorization information.
	///  When using this class to cache, retrieve or prompt authentication
	///  information, you only need to set the necessary attributes. For
	///  example, to check whether a password is already cached, the only
	///  required information is the URL of the resource and optionally
	///  whether or not a path match should be performed.  Similarly, to
	///  prompt for password you only need to optionally set the prompt,
	///  username (if already supplied), comment and commentLabel fields.
	///  <em>SPECIAL NOTE:</em> If you extend this class to add additional
	///  parameters do not forget to overload the stream insertion and
	///  extraction operators ("<<" and ">>") so that the added data can
	///  be correctly serialzed.
	/// </remarks>		<author> Dawit Alemayehu <adawit@kde.org>
	///  </author>
	/// 		<short> A two way messaging class for passing authentication information. </short>

	[SmokeClass("KIO::AuthInfo")]
	public class AuthInfo : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected AuthInfo(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(AuthInfo), this);
		}
		/// <remarks>
		///  Default constructor.
		///     </remarks>		<short>    Default constructor.</short>
		public AuthInfo() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("AuthInfo", "AuthInfo()", typeof(void));
		}
		/// <remarks>
		///  Copy constructor.
		///     </remarks>		<short>    Copy constructor.</short>
		public AuthInfo(KIO.AuthInfo info) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("AuthInfo#", "AuthInfo(const KIO::AuthInfo&)", typeof(void), typeof(KIO.AuthInfo), info);
		}
		/// <remarks>
		///  Use this method to check if the object was modified.
		/// </remarks>		<return> true if the object has been modified
		///     </return>
		/// 		<short>    Use this method to check if the object was modified.</short>
		public bool IsModified() {
			return (bool) interceptor.Invoke("isModified", "isModified() const", typeof(bool));
		}
		/// <remarks>
		///  Use this method to indicate that this object has been modified.
		/// <param> name="flag" true to mark the object as modified, false to clear
		///     </param></remarks>		<short>    Use this method to indicate that this object has been modified.</short>
		public void SetModified(bool flag) {
			interceptor.Invoke("setModified$", "setModified(bool)", typeof(void), typeof(bool), flag);
		}
		~AuthInfo() {
			interceptor.Invoke("~AuthInfo", "~AuthInfo()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~AuthInfo", "~AuthInfo()", typeof(void));
		}
	}
	}
}
