//Auto-generated by kalyptus. DO NOT EDIT.
namespace KIO {
	using Kimono;
	using System;
	using Qyoto;
	/// <remarks>
	///  There are two classes that specifies the protocol between application
	///  ( KIO.Job) and kioslave. SlaveInterface is the class to use on the application
	///  end, SlaveBase is the one to use on the slave end.
	///  A call to foo() results in a call to slotFoo() on the other end.
	///   See <see cref="ISlaveInterfaceSignals"></see> for signals emitted by SlaveInterface
	/// </remarks>		<short>    There are two classes that specifies the protocol between application  ( KIO.Job) and kioslave.</short>
	[SmokeClass("KIO::SlaveInterface")]
	public class SlaveInterface : QObject {
 		protected SlaveInterface(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(SlaveInterface), this);
		}
		// void setOffset(KIO::filesize_t arg1); >>>> NOT CONVERTED
		// KIO::filesize_t offset(); >>>> NOT CONVERTED
		// KIO::SlaveInterface* SlaveInterface(KIO::SlaveInterfacePrivate& arg1,QObject* arg2); >>>> NOT CONVERTED
		// KIO::SlaveInterface* SlaveInterface(KIO::SlaveInterfacePrivate& arg1); >>>> NOT CONVERTED
		public void SetConnection(KIO.Connection connection) {
			interceptor.Invoke("setConnection#", "setConnection(KIO::Connection*)", typeof(void), typeof(KIO.Connection), connection);
		}
		public KIO.Connection Connection() {
			return (KIO.Connection) interceptor.Invoke("connection", "connection() const", typeof(KIO.Connection));
		}
		public void SendResumeAnswer(bool resume) {
			interceptor.Invoke("sendResumeAnswer$", "sendResumeAnswer(bool)", typeof(void), typeof(bool), resume);
		}
		[SmokeMethod("dispatch()")]
		protected virtual bool Dispatch() {
			return (bool) interceptor.Invoke("dispatch", "dispatch()", typeof(bool));
		}
		[SmokeMethod("dispatch(int, const QByteArray&)")]
		protected virtual bool Dispatch(int _cmd, QByteArray data) {
			return (bool) interceptor.Invoke("dispatch$#", "dispatch(int, const QByteArray&)", typeof(bool), typeof(int), _cmd, typeof(QByteArray), data);
		}
		protected void MessageBox(int type, string text, string caption, string buttonYes, string buttonNo) {
			interceptor.Invoke("messageBox$$$$$", "messageBox(int, const QString&, const QString&, const QString&, const QString&)", typeof(void), typeof(int), type, typeof(string), text, typeof(string), caption, typeof(string), buttonYes, typeof(string), buttonNo);
		}
		protected void MessageBox(int type, string text, string caption, string buttonYes, string buttonNo, string dontAskAgainName) {
			interceptor.Invoke("messageBox$$$$$$", "messageBox(int, const QString&, const QString&, const QString&, const QString&, const QString&)", typeof(void), typeof(int), type, typeof(string), text, typeof(string), caption, typeof(string), buttonYes, typeof(string), buttonNo, typeof(string), dontAskAgainName);
		}
		protected void RequestNetwork(string arg1, string arg2) {
			interceptor.Invoke("requestNetwork$$", "requestNetwork(const QString&, const QString&)", typeof(void), typeof(string), arg1, typeof(string), arg2);
		}
		protected void DropNetwork(string arg1, string arg2) {
			interceptor.Invoke("dropNetwork$$", "dropNetwork(const QString&, const QString&)", typeof(void), typeof(string), arg1, typeof(string), arg2);
		}
		[Q_SLOT("void calcSpeed()")]
		protected void CalcSpeed() {
			interceptor.Invoke("calcSpeed", "calcSpeed()", typeof(void));
		}
		protected new ISlaveInterfaceSignals Emit {
			get { return (ISlaveInterfaceSignals) Q_EMIT; }
		}
	}

	public interface ISlaveInterfaceSignals : IQObjectSignals {
		[Q_SIGNAL("void data(const QByteArray&)")]
		void Data(QByteArray arg1);
		[Q_SIGNAL("void dataReq()")]
		void DataReq();
		[Q_SIGNAL("void error(int, const QString&)")]
		void Error(int arg1, string arg2);
		[Q_SIGNAL("void connected()")]
		void Connected();
		[Q_SIGNAL("void finished()")]
		void Finished();
		[Q_SIGNAL("void slaveStatus(pid_t, const QByteArray&, const QString&, bool)")]
		void SlaveStatus(int arg1, QByteArray arg2, string arg3, bool arg4);
		// void listEntries(const KIO::UDSEntryList& arg1); >>>> NOT CONVERTED
		[Q_SIGNAL("void statEntry(const KIO::UDSEntry&)")]
		void StatEntry(KIO.UDSEntry arg1);
		[Q_SIGNAL("void needSubUrlData()")]
		void NeedSubUrlData();
		// void canResume(KIO::filesize_t arg1); >>>> NOT CONVERTED
		[Q_SIGNAL("void open()")]
		void Open();
		// void written(KIO::filesize_t arg1); >>>> NOT CONVERTED
		[Q_SIGNAL("void metaData(const KIO::MetaData&)")]
		void MetaData(KIO.MetaData arg1);
		// void totalSize(KIO::filesize_t arg1); >>>> NOT CONVERTED
		// void processedSize(KIO::filesize_t arg1); >>>> NOT CONVERTED
		[Q_SIGNAL("void redirection(const KUrl&)")]
		void Redirection(KUrl arg1);
		// void position(KIO::filesize_t arg1); >>>> NOT CONVERTED
		[Q_SIGNAL("void speed(long)")]
		void Speed(long arg1);
		[Q_SIGNAL("void errorPage()")]
		void ErrorPage();
		[Q_SIGNAL("void mimeType(const QString&)")]
		void MimeType(string arg1);
		[Q_SIGNAL("void warning(const QString&)")]
		void Warning(string arg1);
		[Q_SIGNAL("void infoMessage(const QString&)")]
		void InfoMessage(string arg1);
	}
}
