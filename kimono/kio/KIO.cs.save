//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {
	using System;
	using Qyoto;
	using System.Text;
	using System.Collections.Generic;

	///<remarks>
	/// </remarks>		<short> A namespace for KIO globals.</short>

	[SmokeClass("KIO")]
	public class KIO : Object {
		protected SmokeInvocation interceptor = null;
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(KIO), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static KIO() {
			staticInterceptor = new SmokeInvocation(typeof(KIO), null);
		}
		///<remarks>
		/// Identifiers for KIO informational messages.
		///  </remarks>		<short>    Identifiers for KIO informational messages.</short>
		public enum Info {
			INF_TOTAL_SIZE = 10,
			INF_PROCESSED_SIZE = 11,
			INF_SPEED = 12,
			INF_REDIRECTION = 20,
			INF_MIME_TYPE = 21,
			INF_ERROR_PAGE = 22,
			INF_WARNING = 23,
			INF_GETTING_FILE = 24,
			INF_UNUSED = 25,
			INF_INFOMESSAGE = 26,
			INF_META_DATA = 27,
			INF_NETWORK_STATUS = 28,
			INF_MESSAGEBOX = 29,
			INF_POSITION = 30,
		}
		///<remarks>
		/// Identifiers for KIO data messages.
		///  </remarks>		<short>    Identifiers for KIO data messages.</short>
		public enum Message {
			MSG_DATA = 100,
			MSG_DATA_REQ = 101,
			MSG_ERROR = 102,
			MSG_CONNECTED = 103,
			MSG_FINISHED = 104,
			MSG_STAT_ENTRY = 105,
			MSG_LIST_ENTRIES = 106,
			MSG_RENAMED = 107,
			MSG_RESUME = 108,
			MSG_SLAVE_STATUS = 109,
			MSG_SLAVE_ACK = 110,
			MSG_NET_REQUEST = 111,
			MSG_NET_DROP = 112,
			MSG_NEED_SUBURL_DATA = 113,
			MSG_CANRESUME = 114,
			MSG_AUTH_KEY = 115,
			MSG_DEL_AUTH_KEY = 116,
			MSG_OPENED = 117,
			MSG_WRITTEN = 118,
		}
		///<remarks>
		/// Commands that can be invoked by a job.
		///   </remarks>		<short>    Commands that can be invoked by a job.</short>
		public enum Command {
			CMD_HOST = '0',
			CMD_CONNECT = '1',
			CMD_DISCONNECT = '2',
			CMD_SLAVE_STATUS = '3',
			CMD_SLAVE_CONNECT = '4',
			CMD_SLAVE_HOLD = '5',
			CMD_NONE = 'A',
			CMD_TESTDIR = 'B',
			CMD_GET = 'C',
			CMD_PUT = 'D',
			CMD_STAT = 'E',
			CMD_MIMETYPE = 'F',
			CMD_LISTDIR = 'G',
			CMD_MKDIR = 'H',
			CMD_RENAME = 'I',
			CMD_COPY = 'J',
			CMD_DEL = 'K',
			CMD_CHMOD = 'L',
			CMD_SPECIAL = 'M',
			CMD_REPARSECONFIGURATION = 'O',
			CMD_META_DATA = 'P',
			CMD_SYMLINK = 'Q',
			CMD_SUBURL = 'R',
			CMD_MESSAGEBOXANSWER = 'S',
			CMD_RESUMEANSWER = 'T',
			CMD_CONFIG = 'U',
			CMD_MULTI_GET = 'V',
			CMD_SETLINKDEST = 'W',
			CMD_OPEN = 'X',
		}
		///<remarks>
		/// Commands that can be invoked on a slave-file.
		///   </remarks>		<short>    Commands that can be invoked on a slave-file.</short>
		public enum FileCommand {
			CMD_READ = 90,
			CMD_WRITE = 91,
			CMD_SEEK = 92,
			CMD_CLOSE = 93,
		}
		///<remarks>
		/// Error codes that can be emitted by KIO.
		///   </remarks>		<short>    Error codes that can be emitted by KIO.</short>
		public enum Error {
			ERR_CANNOT_OPEN_FOR_READING = KJob.UserDefinedError+1,
			ERR_CANNOT_OPEN_FOR_WRITING = KJob.UserDefinedError+2,
			ERR_CANNOT_LAUNCH_PROCESS = KJob.UserDefinedError+3,
			ERR_INTERNAL = KJob.UserDefinedError+4,
			ERR_MALFORMED_URL = KJob.UserDefinedError+5,
			ERR_UNSUPPORTED_PROTOCOL = KJob.UserDefinedError+6,
			ERR_NO_SOURCE_PROTOCOL = KJob.UserDefinedError+7,
			ERR_UNSUPPORTED_ACTION = KJob.UserDefinedError+8,
			ERR_IS_DIRECTORY = KJob.UserDefinedError+9,
			ERR_IS_FILE = KJob.UserDefinedError+10,
			ERR_DOES_NOT_EXIST = KJob.UserDefinedError+11,
			ERR_FILE_ALREADY_EXIST = KJob.UserDefinedError+12,
			ERR_DIR_ALREADY_EXIST = KJob.UserDefinedError+13,
			ERR_UNKNOWN_HOST = KJob.UserDefinedError+14,
			ERR_ACCESS_DENIED = KJob.UserDefinedError+15,
			ERR_WRITE_ACCESS_DENIED = KJob.UserDefinedError+16,
			ERR_CANNOT_ENTER_DIRECTORY = KJob.UserDefinedError+17,
			ERR_PROTOCOL_IS_NOT_A_FILESYSTEM = KJob.UserDefinedError+18,
			ERR_CYCLIC_LINK = KJob.UserDefinedError+19,
			ERR_USER_CANCELED = KJob.KilledJobError,
			ERR_CYCLIC_COPY = KJob.UserDefinedError+21,
			ERR_COULD_NOT_CREATE_SOCKET = KJob.UserDefinedError+22,
			ERR_COULD_NOT_CONNECT = KJob.UserDefinedError+23,
			ERR_CONNECTION_BROKEN = KJob.UserDefinedError+24,
			ERR_NOT_FILTER_PROTOCOL = KJob.UserDefinedError+25,
			ERR_COULD_NOT_MOUNT = KJob.UserDefinedError+26,
			ERR_COULD_NOT_UNMOUNT = KJob.UserDefinedError+27,
			ERR_COULD_NOT_READ = KJob.UserDefinedError+28,
			ERR_COULD_NOT_WRITE = KJob.UserDefinedError+29,
			ERR_COULD_NOT_BIND = KJob.UserDefinedError+30,
			ERR_COULD_NOT_LISTEN = KJob.UserDefinedError+31,
			ERR_COULD_NOT_ACCEPT = KJob.UserDefinedError+32,
			ERR_COULD_NOT_LOGIN = KJob.UserDefinedError+33,
			ERR_COULD_NOT_STAT = KJob.UserDefinedError+34,
			ERR_COULD_NOT_CLOSEDIR = KJob.UserDefinedError+35,
			ERR_COULD_NOT_MKDIR = KJob.UserDefinedError+37,
			ERR_COULD_NOT_RMDIR = KJob.UserDefinedError+38,
			ERR_CANNOT_RESUME = KJob.UserDefinedError+39,
			ERR_CANNOT_RENAME = KJob.UserDefinedError+40,
			ERR_CANNOT_CHMOD = KJob.UserDefinedError+41,
			ERR_CANNOT_DELETE = KJob.UserDefinedError+42,
			ERR_SLAVE_DIED = KJob.UserDefinedError+43,
			ERR_OUT_OF_MEMORY = KJob.UserDefinedError+44,
			ERR_UNKNOWN_PROXY_HOST = KJob.UserDefinedError+45,
			ERR_COULD_NOT_AUTHENTICATE = KJob.UserDefinedError+46,
			ERR_ABORTED = KJob.UserDefinedError+47,
			ERR_INTERNAL_SERVER = KJob.UserDefinedError+48,
			ERR_SERVER_TIMEOUT = KJob.UserDefinedError+49,
			ERR_SERVICE_NOT_AVAILABLE = KJob.UserDefinedError+50,
			ERR_UNKNOWN = KJob.UserDefinedError+51,
			ERR_UNKNOWN_INTERRUPT = KJob.UserDefinedError+53,
			ERR_CANNOT_DELETE_ORIGINAL = KJob.UserDefinedError+54,
			ERR_CANNOT_DELETE_PARTIAL = KJob.UserDefinedError+55,
			ERR_CANNOT_RENAME_ORIGINAL = KJob.UserDefinedError+56,
			ERR_CANNOT_RENAME_PARTIAL = KJob.UserDefinedError+57,
			ERR_NEED_PASSWD = KJob.UserDefinedError+58,
			ERR_CANNOT_SYMLINK = KJob.UserDefinedError+59,
			ERR_NO_CONTENT = KJob.UserDefinedError+60,
			ERR_DISK_FULL = KJob.UserDefinedError+61,
			ERR_IDENTICAL_FILES = KJob.UserDefinedError+62,
			ERR_SLAVE_DEFINED = KJob.UserDefinedError+63,
			ERR_UPGRADE_REQUIRED = KJob.UserDefinedError+64,
			ERR_POST_DENIED = KJob.UserDefinedError+65,
			ERR_COULD_NOT_SEEK = KJob.UserDefinedError+66,
		}
		///<remarks>
		/// Specifies how to use the cache.
		///</remarks>		<short>    Specifies how to use the cache.</short>
		///		<see> parseCacheControl</see>
		///		<see> getCacheControlString</see>
		public enum CacheControl {
			CC_CacheOnly = 0,
			CC_Cache = 1,
			CC_Verify = 2,
			CC_Refresh = 3,
			CC_Reload = 4,
		}
		public enum FileSystemFlag {
			SupportsChmod = 0,
			SupportsChown = 1,
			SupportsUTime = 2,
			SupportsSymlinks = 3,
			CaseInsensitive = 4,
		}
		///<remarks>
		/// Constants used to specify the type of a UDSField.
		///   </remarks>		<short>    Constants used to specify the type of a UDSField.</short>
		public enum UDSFieldTypes {
			UDS_STRING = 0x01000000,
			UDS_NUMBER = 0x02000000,
			UDS_TIME = 0x04000000|UDS_NUMBER,
			UDS_SIZE = 1|UDS_NUMBER,
			UDS_SIZE_LARGE = 2|UDS_NUMBER,
			UDS_USER = 3|UDS_STRING,
			UDS_ICON_NAME = 4|UDS_STRING,
			UDS_GROUP = 5|UDS_STRING,
			UDS_NAME = 6|UDS_STRING,
			UDS_LOCAL_PATH = 7|UDS_STRING,
			UDS_HIDDEN = 8|UDS_NUMBER,
			UDS_ACCESS = 9|UDS_NUMBER,
			UDS_MODIFICATION_TIME = 10|UDS_TIME,
			UDS_ACCESS_TIME = 11|UDS_TIME,
			UDS_CREATION_TIME = 12|UDS_TIME,
			UDS_FILE_TYPE = 13|UDS_NUMBER,
			UDS_LINK_DEST = 14|UDS_STRING,
			UDS_URL = 15|UDS_STRING,
			UDS_MIME_TYPE = 16|UDS_STRING,
			UDS_GUESSED_MIME_TYPE = 17|UDS_STRING,
			UDS_XML_PROPERTIES = 18|UDS_STRING,
			UDS_EXTENDED_ACL = 19|UDS_NUMBER,
			UDS_ACL_STRING = 20|UDS_STRING,
			UDS_DEFAULT_ACL_STRING = 21|UDS_STRING,
			UDS_EXTRA = 100|UDS_STRING,
			UDS_EXTRA_END = 140|UDS_STRING,
		}
		public enum RenameDialog_Mode {
			M_OVERWRITE = 1,
			M_OVERWRITE_ITSELF = 2,
			M_SKIP = 4,
			M_SINGLE = 8,
			M_MULTI = 16,
			M_RESUME = 32,
			M_NORENAME = 64,
		}
		///<remarks>
		/// The result of open_RenameDialog().
		/// </remarks>		<short>    The result of open_RenameDialog().</short>
		public enum RenameDialog_Result {
			R_RESUME = 6,
			R_RESUME_ALL = 7,
			R_OVERWRITE = 4,
			R_OVERWRITE_ALL = 5,
			R_SKIP = 2,
			R_AUTO_SKIP = 3,
			R_RENAME = 1,
			R_CANCEL = 0,
		}
		public enum SkipDialog_Result {
			S_SKIP = 1,
			S_AUTO_SKIP = 2,
			S_CANCEL = 0,
		}
		///<remarks> HTTP / DAV method *</remarks>		<short>   HTTP / DAV method  </short>
		public enum HTTP_METHOD {
			HTTP_GET = 0,
			HTTP_PUT = 1,
			HTTP_POST = 2,
			HTTP_HEAD = 3,
			HTTP_DELETE = 4,
			HTTP_OPTIONS = 5,
			DAV_PROPFIND = 6,
			DAV_PROPPATCH = 7,
			DAV_MKCOL = 8,
			DAV_COPY = 9,
			DAV_MOVE = 10,
			DAV_LOCK = 11,
			DAV_UNLOCK = 12,
			DAV_SEARCH = 13,
			DAV_SUBSCRIBE = 14,
			DAV_UNSUBSCRIBE = 15,
			DAV_POLL = 16,
			DAV_NOTIFY = 17,
			HTTP_UNKNOWN = -1,
		}
		// QPixmap pixmapForUrl(const KUrl& arg1,mode_t arg2,K3Icon::Group arg3,int arg4,int arg5,QString* arg6); >>>> NOT CONVERTED
		// QPixmap pixmapForUrl(const KUrl& arg1,mode_t arg2,K3Icon::Group arg3,int arg4,int arg5); >>>> NOT CONVERTED
		// QPixmap pixmapForUrl(const KUrl& arg1,mode_t arg2,K3Icon::Group arg3,int arg4); >>>> NOT CONVERTED
		// QPixmap pixmapForUrl(const KUrl& arg1,mode_t arg2,K3Icon::Group arg3); >>>> NOT CONVERTED
		// KUiServerJobTracker* getJobTracker(); >>>> NOT CONVERTED
		///<remarks>
		/// Converts <code>size</code> from bytes to the string representation.
		///<param> name="size" size in bytes
		///</param></remarks>		<return> converted size as a string - e.g. 123.4 KiB , 12.0 MiB
		///   </return>
		///		<short>    Converts <code>size</code> from bytes to the string representation.</short>
		///<remarks>
		/// Converts a size to a string representation
		/// Not unlike string.Number(...)
		///<param> name="size" size in bytes
		///</param></remarks>		<return> converted size as a string - e.g. 123456789
		///   </return>
		///		<short>    Converts a size to a string representation  Not unlike string.Number(.</short>
		///<remarks>
		/// Converts size from kibi-bytes (2^10) to the string representation.
		///<param> name="kibSize" size in kibi-bytes (2^10)
		///</param></remarks>		<return> converted size as a string - e.g. 123.4 KiB , 12.0 MiB
		///   </return>
		///		<short>    Converts size from kibi-bytes (2^10) to the string representation.</short>
		///<remarks>
		/// Calculates remaining time in seconds from total size, processed size and speed.
		///<param> name="totalSize" total size in bytes
		///</param><param> name="processedSize" processed size in bytes
		///</param><param> name="speed" speed in bytes per second
		///</param></remarks>		<return> calculated remaining time in seconds
		///   </return>
		///		<short>    Calculates remaining time in seconds from total size, processed size and speed.</short>
		///<remarks>
		/// Convert <code>seconds</code> to a string representing number of days, hours, minutes and seconds
		///<param> name="seconds" number of seconds to convert
		///</param></remarks>		<return> string representation in a locale depending format
		///   </return>
		///		<short>    Convert <code>seconds</code> to a string representing number of days, hours, minutes and seconds </short>
		///<remarks>
		/// Calculates remaining time from total size, processed size and speed.
		/// Warning: As QTime is limited to 23:59:59, use calculateRemainingSeconds() instead
		///<param> name="totalSize" total size in bytes
		///</param><param> name="processedSize" processed size in bytes
		///</param><param> name="speed" speed in bytes per second
		///</param></remarks>		<return> calculated remaining time
		///   </return>
		///		<short>    Calculates remaining time from total size, processed size and speed.</short>
		///<remarks>
		/// Helper for showing information about a set of files and directories
		///<param> name="items" the number of items (= <code>files</code> + <code>dirs</code> + number of symlinks :)
		///</param><param> name="files" the number of files
		///</param><param> name="dirs" the number of dirs
		///</param><param> name="size" the sum of the size of the <code>files</code>
		///</param><param> name="showSize" whether to show the size in the result
		///</param></remarks>		<return> the summary string
		///   </return>
		///		<short>    Helper for showing information about a set of files and directories </short>
		///<remarks>
		/// Encodes (from the text displayed to the real filename)
		/// This translates % into %% and / into %2f
		/// Used by KIO.Link, for instance.
		///<param> name="str" the file name to encode
		///</param></remarks>		<return> the encoded file name
		///   </return>
		///		<short>    Encodes (from the text displayed to the real filename)  This translates % into %% and / into %2f  Used by KIO.Link, for instance.</short>
		///<remarks>
		/// Decodes (from the filename to the text displayed)
		/// This translates %2[fF] into / and %% into %
		///<param> name="str" the file name to decode
		///</param></remarks>		<return> the decoded file name
		///   </return>
		///		<short>    Decodes (from the filename to the text displayed)  This translates %2[fF] into / and %% into % </short>
		///<remarks>
		/// Returns a translated error message for <code>errorCode</code> using the
		/// additional error information provided by <code>errorText.</code>
		///<param> name="errorCode" the error code
		///</param><param> name="errorText" the additional error text
		///</param></remarks>		<return> the created error string
		///   </return>
		///		<short>    Returns a translated error message for <code>errorCode</code> using the  additional error information provided by <code>errorText.</code></short>
		///<remarks>
		/// Returns translated error details for <code>errorCode</code> using the
		/// additional error information provided by <code>errorText</code> , <code>reqUrl</code>
		/// (the request URL), and the ioslave <code>method</code> .
		///<param> name="errorCode" the error code
		///</param><param> name="errorText" the additional error text
		///</param><param> name="reqUrl" the request URL
		///</param><param> name="method" the ioslave method
		///</param>
		///<li>
		///string errorName - the name of the error
		///</li>
		///
		///<li>
		///string techName - if not null, the more technical name of the error
		///</li>
		///
		///<li>
		///string description - a description of the error
		///</li>
		///
		///<li>
		///List<string> causes - a list of possible causes of the error
		///</li>
		///
		///<li>
		///List<string> solutions - a liso of solutions for the error
		///   
		///</li></remarks>		<return> the following data:
		///</return>
		///		<short>    Returns translated error details for <code>errorCode</code> using the  additional error information provided by <code>errorText</code> , <code>reqUrl</code>  (the request URL), and the ioslave <code>method</code> .</short>
		///<remarks>
		/// Returns an appropriate error message if the given command <code>cmd</code>
		/// is an unsupported action (ERR_UNSUPPORTED_ACTION).
		///<param> name="protocol" name of the protocol
		///</param><param> name="cmd" given command
		///</param></remarks>		<short>    Returns an appropriate error message if the given command <code>cmd</code>  is an unsupported action (ERR_UNSUPPORTED_ACTION).</short>
		///		<see> enum</see>
		///		<see> Command</see>
		///<remarks>
		/// Parses the string representation of the cache control option.
		///<param> name="cacheControl" the string representation
		///</param></remarks>		<return> the cache control value
		///</return>
		///		<short>    Parses the string representation of the cache control option.</short>
		///		<see> getCacheControlString</see>
		///<remarks>
		/// Returns a string representation of the given cache control method.
		///<param> name="cacheControl" the cache control method
		///</param></remarks>		<return> the string representation
		///</return>
		///		<short>    Returns a string representation of the given cache control method.</short>
		///		<see> parseCacheControl</see>
		///<remarks>
		/// Checks if the path belongs to a filesystem that is probably
		/// slow. It checks for NFS or for paths belonging to automounted
		/// paths not yet mounted
		///<param> name="filename" the file name to check
		///</param></remarks>		<return> true if the filesystem is probably slow
		///   </return>
		///		<short>    Checks if the path belongs to a filesystem that is probably  slow.</short>
		///<remarks>
		/// Checks if the path belongs to a filesystem that is manually
		/// mounted.
		///<param> name="filename" the file name to check
		///</param></remarks>		<return> true if the filesystem is manually mounted
		///   </return>
		///		<short>    Checks if the path belongs to a filesystem that is manually  mounted.</short>
		///<remarks>
		/// Checks the capabilities of the filesystem to which a given file belongs.
		/// given feature (e.g. chmod).
		///<param> name="filename" the file name to check
		///</param><param> name="flag" the flag to check
		///</param> The availables flags are:
		///
		///<li>
		///SupportsChmod: returns true if the filesystem supports chmod
		/// (e.g. msdos filesystems return false)
		///</li>
		///
		///<li>
		///SupportsChown: returns true if the filesystem supports chown
		/// (e.g. msdos filesystems return false)
		///</li>
		///
		///<li>
		///SupportsUtime: returns true if the filesystems supports utime
		/// (e.g. msdos filesystems return false)
		///</li>
		///
		///<li>
		///SupportsSymlinks: returns true if the filesystems supports symlinks
		/// (e.g. msdos filesystems return false)
		///</li>
		///
		///<li>
		///CaseInsensitive: returns true if the filesystem treats
		/// "foo" and "FOO" as being the same file (true for msdos systems)
		///</li>
		///   </remarks>		<return> true if the filesystem has that flag, false if not (or some error occurred)
		///</return>
		///		<short>    Checks the capabilities of the filesystem to which a given file belongs.</short>
		///<remarks>
		/// Convenience method to find the pixmap for a URL.
		/// Call this one when you don't know the mimetype.
		///<param> name="_url" URL for the file.
		///</param><param> name="_mode" the mode of the file. The mode may modify the icon
		///              with overlays that show special properties of the
		///              icon. Use 0 for default
		///</param><param> name="_group" The icon group where the icon is going to be used.
		///</param><param> name="_force_size" Override globally configured icon size.
		///        Use 0 for the default size
		///</param><param> name="_state" The icon state, one of: K3Icon.DefaultState,
		/// K3Icon.ActiveState or K3Icon.DisabledState.
		///</param><param> name="_path" Output parameter to get the full path. Seldom needed.
		///              Ignored if 0
		///</param></remarks>		<return> the pixmap of the URL, can be a default icon if not found
		///   </return>
		///		<short>    Convenience method to find the pixmap for a URL.</short>
		///<remarks>
		/// Creates a single directory.
		///<param> name="url" The URL of the directory to create.
		///</param><param> name="permissions" The permissions to set after creating the
		///                    directory (unix-style), -1 for default permissions.
		///</param></remarks>		<return> A pointer to the job handling the operation.
		///     </return>
		///		<short>    Creates a single directory.</short>
		///<remarks>
		/// Removes a single directory.
		/// The directory is assumed to be empty.
		///<param> name="url" The URL of the directory to remove.
		///</param></remarks>		<return> A pointer to the job handling the operation.
		///     </return>
		///		<short>    Removes a single directory.</short>
		///<remarks>
		/// Changes permissions on a file or directory.
		/// See the other chmod below for changing many files
		/// or directories.
		///<param> name="url" The URL of file or directory.
		///</param><param> name="permissions" The permissions to set.
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Changes permissions on a file or directory.</short>
		///<remarks>
		/// Rename a file or directory.
		/// Warning: this operation fails if a direct renaming is not
		/// possible (like with files or dirs on separate partitions)
		/// Use move or file_move in this case.
		///<param> name="src" The original URL
		///</param><param> name="dest" The final URL
		///</param><param> name="overwrite" whether to automatically overwrite if the dest exists
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Rename a file or directory.</short>
		///<remarks>
		/// Create or move a symlink.
		/// This is the lowlevel operation, similar to file_copy and file_move.
		/// It doesn't do any check (other than those the slave does)
		/// and it doesn't show rename and skip dialogs - use KIO.Link for that.
		///<param> name="target" The string that will become the "target" of the link (can be relative)
		///</param><param> name="dest" The symlink to create.
		///</param><param> name="overwrite" whether to automatically overwrite if the dest exists
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Create or move a symlink.</short>
		///<remarks>
		/// Execute any command that is specific to one slave (protocol).
		/// Examples are : HTTP POST, mount and unmount (kio_file)
		///<param> name="url" The URL isn't passed to the slave, but is used to know
		///        which slave to send it to :-)
		///</param><param> name="data" Packed data.  The meaning is completely dependent on the
		///        slave, but usually starts with an int for the command number.
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Execute any command that is specific to one slave (protocol).</short>
		///<remarks>
		/// Mount filesystem.
		/// Special job for <code>kio_file.</code>
		///<param> name="ro" Mount read-only if <code>true.</code>
		///</param><param> name="fstype" File system type (e.g. "ext2", can be empty).
		///</param><param> name="dev" Device (e.g. /dev/sda0).
		///</param><param> name="point" Mount point, can be <code>null.</code>
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Mount filesystem.</short>
		///<remarks>
		/// Unmount filesystem.
		/// Special job for <code>kio_file.</code>
		///<param> name="point" Point to unmount.
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Unmount filesystem.</short>
		///<remarks>
		/// HTTP cache update
		///<param> name="url" Url to update, protocol must be "http".
		///</param><param> name="no_cache" If true, cache entry for <code>url</code> is deleted.
		///</param><param> name="expireDate" Local machine time indicating when the entry is
		/// supposed to expire.
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    HTTP cache update </short>
		///<remarks>
		/// Find all details for one file or directory.
		///<param> name="url" the URL of the file
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Find all details for one file or directory.</short>
		///<remarks>
		/// Find all details for one file or directory.
		/// This version of the call includes two additional booleans, <code>sideIsSource</code> and <code>details.</code>
		///<param> name="url" the URL of the file
		///</param><param> name="sideIsSource" is true when stating a source file (we will do a get on it if
		/// the stat works) and false when stating a destination file (target of a copy).
		/// The reason for this parameter is that in some cases the kioslave might not
		/// be able to determine a file's existence (e.g. HTTP doesn't allow it, FTP
		/// has issues with case-sensitivity on some systems).
		/// When the slave can't reliably determine the existence of a file, it will:
		///</param>
		///<li>
		///be optimistic if sideIsSource=true, i.e. it will assume the file exists,
		/// and if it doesn't this will appear when actually trying to download it
		///</li>
		///
		///<li>
		///be pessimistic if sideIsSource=false, i.e. it will assume the file
		/// doesn't exist, to prevent showing "about to overwrite" errors to the user.
		/// If you simply want to check for existence without downloading/uploading afterwards,
		/// then you should use sideIsSource=false.
		///</li>
		///<param> name="details" selects the level of details we want.
		/// By default this is 2 (all details wanted, including modification time, size, etc.),
		/// setDetails(1) is used when deleting: we don't need all the information if it takes
		/// too much time, no need to follow symlinks etc.
		/// setDetails(0) is used for very simple probing: we'll only get the answer
		/// "it's a file or a directory, or it doesn't exist". This is used by KRun.
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Find all details for one file or directory.</short>
		///<remarks>
		/// Get (a.k.a. read).
		/// The slave emits the data through data().
		///<param> name="url" the URL of the file
		///</param><param> name="reload" true to reload the file, false if it can be taken from the cache
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Get (a.</short>
		///<remarks>
		/// Open ( random access I/O )
		/// The file-job emits open() when opened
		///<param> name="url" the URL of the file
		///</param><param> name="mode" the access privileges: see \ref OpenMode
		///</param></remarks>		<return> The file-handling job. It will never return 0. Errors are handled asynchronously
		/// (emitted as signals).
		///     </return>
		///		<short>    Open ( random access I/O ) </short>
		///<remarks>
		/// Put (a.k.a. write)
		///<param> name="url" Where to write data.
		///</param><param> name="permissions" May be -1. In this case no special permission mode is set.
		///</param><param> name="overwrite" If true, any existing file will be overwritten.
		///</param><param> name="resume" true to resume an operation. Warning, setting this to true means
		///               that the data will be appended to <code>dest</code> if <code>dest</code> exists.
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///</return>
		///		<short>    Put (a.</short>
		///		<see> multi_get</see>
		///<remarks>
		/// HTTP POST (for form data).
		/// Example:
		/// <pre>
		///    job = KIO.Http_post( url, postData, false );
		///    job.AddMetaData("content-type", contentType );
		///    job.AddMetaData("referrer", referrerURL);
		/// </pre>
		/// <code>postData</code> is the data that you want to send and
		/// <code>contentType</code> is the complete HTTP header line that
		/// specifies the content's MIME type, for example
		/// "Content-Type: text/xml".
		/// You MUST specify content-type!
		/// Often <code>contentType</code> is
		/// "Content-Type: application/x-www-form-urlencoded" and
		/// the <code>postData</code> is then an ASCII string (without null-termination!)
		/// with characters like space, linefeed and percent escaped like %20,
		/// %0A and %25.
		///<param> name="url" Where to write the data.
		///</param><param> name="postData" Encoded data to post.
		///</param><param> name="showProgressInfo" true to display
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    HTTP POST (for form data).</short>
		///<remarks>
		/// Get (a.k.a. read), into a single QByteArray.
		///<param> name="url" the URL of the file
		///</param><param> name="reload" true to reload the file, false if it can be taken from the cache
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Get (a.</short>
		///		<see> StoredTransferJob</see>
		///<remarks>
		/// Put (a.k.a. write) data from a single QByteArray.
		///<param> name="arr" The data to write
		///</param><param> name="url" Where to write data.
		///</param><param> name="permissions" May be -1. In this case no special permission mode is set.
		///</param><param> name="overwrite" If true, any existing file will be overwritten.
		///</param><param> name="resume" true to resume an operation. Warning, setting this to true means
		///               that the data will be appended to <code>dest</code> if <code>dest</code> exists.
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Put (a.</short>
		///		<see> StoredTransferJob</see>
		///<remarks>
		/// Creates a new multiple get job.
		///<param> name="id" the id of the get operation
		///</param><param> name="url" the URL of the file
		///</param><param> name="metaData" the MetaData associated with the file
		///</param></remarks>		<return> the job handling the operation.
		///</return>
		///		<short>    Creates a new multiple get job.</short>
		///		<see> get</see>
		///<remarks>
		/// Find mimetype for one file or directory.
		///<param> name="url" the URL of the file
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Find mimetype for one file or directory.</short>
		///<remarks>
		/// Copy a single file.
		/// Uses either SlaveBase.Copy() if the slave supports that
		/// or get() and put() otherwise.
		///<param> name="src" Where to get the file.
		///</param><param> name="dest" Where to put the file.
		///</param><param> name="permissions" May be -1. In this case no special permission mode is set.
		///</param><param> name="overwrite" If true, any existing file will be overwritten.
		///</param><param> name="resume" true to resume an operation. Warning, setting this to true means
		///               that <code>src</code> will be appended to <code>dest</code> if <code>dest</code> exists.
		///               You probably don't want that, so leave it to false :)
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Copy a single file.</short>
		///<remarks>
		/// Move a single file.
		/// Use either SlaveBase.Rename() if the slave supports that,
		/// or copy() and del() otherwise, or eventually get() & put() & del()
		///<param> name="src" Where to get the file.
		///</param><param> name="dest" Where to put the file.
		///</param><param> name="permissions" May be -1. In this case no special permission mode is set.
		///</param><param> name="overwrite" If <code>true</code>, any existing file will be overwritten.
		///</param><param> name="resume" true to resume an operation. Warning, setting this to true means
		///               that <code>src</code> will be appended to <code>dest</code> if <code>dest</code> exists.
		///               You probably don't want that, so leave it to false :)
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Move a single file.</short>
		///<remarks>
		/// Delete a single file.
		///<param> name="src" File to delete.
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    Delete a single file.</short>
		///<remarks>
		/// List the contents of <code>url</code>, which is assumed to be a directory.
		/// "." and ".." are returned, filter them out if you don't want them.
		///<param> name="url" the url of the directory
		///</param><param> name="showProgressInfo" true to show progress information
		///</param><param> name="includeHidden" true for all files, false to cull out UNIX hidden
		///                      files/dirs (whose names start with dot)
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    List the contents of <code>url</code>, which is assumed to be a directory.</short>
		///<remarks>
		/// The same as the previous method, but recurses subdirectories.
		/// Directory links are not followed.
		/// "." and ".." are returned but only for the toplevel directory.
		/// Filter them out if you don't want them.
		///<param> name="url" the url of the directory
		///</param><param> name="showProgressInfo" true to show progress information
		///</param><param> name="includeHidden" true for all files, false to cull out UNIX hidden
		///                      files/dirs (whose names start with dot)
		///</param></remarks>		<return> the job handling the operation.
		///     </return>
		///		<short>    The same as the previous method, but recurses subdirectories.</short>
		///<remarks>
		/// Copy a file or directory <code>src</code> into the destination <code>dest</code>,
		/// which can be a file (including the final filename) or a directory
		/// (into which <code>src</code> will be copied).
		/// This emulates the cp command completely.
		///<param> name="src" the file or directory to copy
		///</param><param> name="dest" the destination
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///</return>
		///		<short>    Copy a file or directory <code>src</code> into the destination <code>dest</code>,  which can be a file (including the final filename) or a directory  (into which <code>src</code> will be copied).</short>
		///		<see> copyAs</see>
		///<remarks>
		/// Copy a file or directory <code>src</code> into the destination <code>dest</code>,
		/// which is the destination name in any case, even for a directory.
		/// As opposed to copy(), this doesn't emulate cp, but is the only
		/// way to copy a directory, giving it a new name and getting an error
		/// box if a directory already exists with the same name.
		///<param> name="src" the file or directory to copy
		///</param><param> name="dest" the destination
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///     </return>
		///		<short>    Copy a file or directory <code>src</code> into the destination <code>dest</code>,  which is the destination name in any case, even for a directory.</short>
		///<remarks>
		/// Copy a list of file/dirs <code>src</code> into a destination directory <code>dest.</code>
		///<param> name="src" the list of files and/or directories
		///</param><param> name="dest" the destination
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///     </return>
		///		<short>    Copy a list of file/dirs <code>src</code> into a destination directory <code>dest.</code></short>
		///<remarks>
		/// Moves a file or directory <code>src</code> to the given destination <code>dest.</code>
		///<param> name="src" the file or directory to copy
		///</param><param> name="dest" the destination
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///</return>
		///		<short>    Moves a file or directory <code>src</code> to the given destination <code>dest.</code></short>
		///		<see> copy</see>
		///		<see> moveAs</see>
		///<remarks>
		/// Moves a file or directory <code>src</code> to the given destination <code>dest.</code> Unlike move()
		/// this operation will fail when the directory already exists.
		///<param> name="src" the file or directory to copy
		///</param><param> name="dest" the destination
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///</return>
		///		<short>    Moves a file or directory <code>src</code> to the given destination <code>dest.</code></short>
		///		<see> copyAs</see>
		///<remarks>
		/// Moves a list of files or directories <code>src</code> to the given destination <code>dest.</code>
		///<param> name="src" the list of files or directories to copy
		///</param><param> name="dest" the destination
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///</return>
		///		<short>    Moves a list of files or directories <code>src</code> to the given destination <code>dest.</code></short>
		///		<see> copy</see>
		///<remarks>
		/// Create a link.
		/// If the protocols and hosts are the same, a Unix symlink will be created.
		/// Otherwise, a .desktop file of Type Link and pointing to the src URL will be created.
		///<param> name="src" The existing file or directory, 'target' of the link.
		///</param><param> name="destDir" Destination directory where the link will be created.
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///     </return>
		///		<short>    Create a link.</short>
		///<remarks>
		/// Create several links
		/// If the protocols and hosts are the same, a Unix symlink will be created.
		/// Otherwise, a .desktop file of Type Link and pointing to the src URL will be created.
		///<param> name="src" The existing files or directories, 'targets' of the link.
		///</param><param> name="destDir" Destination directory where the links will be created.
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///</return>
		///		<short>    Create several links  If the protocols and hosts are the same, a Unix symlink will be created.</short>
		///		<see> link</see>
		///<remarks>
		/// Create a link. Unlike link() this operation will fail when the directory already
		/// exists.
		/// If the protocols and hosts are the same, a Unix symlink will be created.
		/// Otherwise, a .desktop file of Type Link and pointing to the src URL will be created.
		///<param> name="src" The existing file or directory, 'target' of the link.
		///</param><param> name="dest" Destination directory where the link will be created.
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///</return>
		///		<short>    Create a link.</short>
		///		<see> link</see>
		///		<see> copyAs</see>
		///<remarks>
		/// Trash a file or directory.
		/// This is currently only supported for local files and directories.
		/// Use "KUrl src; src.setPath( path );" to create a URL from a path.
		///<param> name="src" file to delete
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///     </return>
		///		<short>    Trash a file or directory.</short>
		///<remarks>
		/// Trash a list of files or directories.
		/// This is currently only supported for local files and directories.
		///<param> name="src" the files to delete
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///     </return>
		///		<short>    Trash a list of files or directories.</short>
		///<remarks>
		/// Delete a file or directory.
		///<param> name="src" file to delete
		///</param><param> name="shred" obsolete (TODO remove in KDE4)
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///     </return>
		///		<short>    Delete a file or directory.</short>
		///<remarks>
		/// Deletes a list of files or directories.
		///<param> name="src" the files to delete
		///</param><param> name="shred" obsolete (TODO remove in KDE4)
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the job handling the operation
		///     </return>
		///		<short>    Deletes a list of files or directories.</short>
		///<remarks>
		/// Save the given mimesource <code>data</code> to the given destination URL
		/// after offering the user to choose a data format.
		/// This is the method used when handling drops (of anything else than URLs)
		/// onto kdesktop and konqueror.
		///<param> name="data" the QMimeData (from a QDropEvent or from the clipboard when pasting)
		///</param><param> name="destURL" the URL of the directory where the data will be pasted.
		/// The filename to use in that directory is prompted by this method.
		///</param><param> name="dialogText" the text to show in the dialog
		///</param><param> name="widget" parent widget to use for dialogs
		///</param><param> name="clipboard" whether the QMimeSource comes from QClipboard. If you
		/// use pasteClipboard for that case, you never have to worry about this parameter.
		///</param></remarks>		<short>    Save the given mimesource <code>data</code> to the given destination URL  after offering the user to choose a data format.</short>
		///		<see> pasteClipboard</see>
		///<remarks>
		/// Returns the text to use for the Paste action, when the application supports
		/// pasting files, urls, and clipboard data, using pasteClipboard().
		///</remarks>		<return> a string suitable for KAction.SetText, or an empty string if pasting
		/// isn't possible right now.
		///   </return>
		///		<short>    Returns the text to use for the Paste action, when the application supports  pasting files, urls, and clipboard data, using pasteClipboard().</short>
		///<remarks>
		/// Creates a PreviewJob to generate or retrieve a preview image
		/// for the given URL.
		///<param> name="items" files to get previews for
		///</param><param> name="width" the maximum width to use
		///</param><param> name="height" the maximum height to use, if this is 0, the same
		/// value as width is used.
		///</param><param> name="iconSize" the size of the mimetype icon to overlay over the
		/// preview or zero to not overlay an icon. This has no effect if the
		/// preview plugin that will be used doesn't use icon overlays.
		///</param><param> name="iconAlpha" transparency to use for the icon overlay
		///</param><param> name="scale" if the image is to be scaled to the requested size or
		/// returned in its original size
		///</param><param> name="save" if the image should be cached for later use
		///</param><param> name="enabledPlugins" if non-zero, this points to a list containing
		/// the names of the plugins that may be used.
		///</param></remarks>		<return> the new PreviewJob
		///</return>
		///		<short>    Creates a PreviewJob to generate or retrieve a preview image  for the given URL.</short>
		///		<see> PreviewJob.AvailablePlugins</see>
		///<remarks>
		/// Creates a PreviewJob to generate or retrieve a preview image
		/// for the given URL.
		///<param> name="items" files to get previews for
		///</param><param> name="width" the maximum width to use
		///</param><param> name="height" the maximum height to use, if this is 0, the same
		/// value as width is used.
		///</param><param> name="iconSize" the size of the mimetype icon to overlay over the
		/// preview or zero to not overlay an icon. This has no effect if the
		/// preview plugin that will be used doesn't use icon overlays.
		///</param><param> name="iconAlpha" transparency to use for the icon overlay
		///</param><param> name="scale" if the image is to be scaled to the requested size or
		/// returned in its original size
		///</param><param> name="save" if the image should be cached for later use
		///</param><param> name="enabledPlugins" if non-zero, this points to a list containing
		/// the names of the plugins that may be used.
		///</param></remarks>		<return> the new PreviewJob
		///</return>
		///		<short>    Creates a PreviewJob to generate or retrieve a preview image  for the given URL.</short>
		///		<see> PreviewJob.AvailablePlugins</see>
		///<remarks>
		/// Retrieves meta information for the given items.
		///<param> name="items" files to get metainfo for
		///</param></remarks>		<return> the MetaInfoJob to retrieve the items
		///     </return>
		///		<short>    Retrieves meta information for the given items.</short>
		///<remarks>
		/// Retrieves meta information for the given items.
		///<param> name="items" files to get metainfo for
		///</param></remarks>		<return> the MetaInfoJob to retrieve the items
		///     </return>
		///		<short>    Retrieves meta information for the given items.</short>
		///<remarks>
		/// Creates a new DavJob that issues a PROPFIND command. PROPFIND retrieves
		/// the properties of the resource identified by the given <code>url.</code>
		///<param> name="url" the URL of the resource
		///</param><param> name="properties" a propfind document that describes the properties that
		///        should be retrieved
		///</param><param> name="depth" the depth of the request. Can be "0", "1" or "infinity"
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the new DavJob
		///    </return>
		///		<short>    Creates a new DavJob that issues a PROPFIND command.</short>
		///<remarks>
		/// Creates a new DavJob that issues a PROPPATCH command. PROPPATCH sets
		/// the properties of the resource identified by the given <code>url.</code>
		///<param> name="url" the URL of the resource
		///</param><param> name="properties" a PROPPACTCH document that describes the properties that
		///        should be modified and its new values
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the new DavJob
		///    </return>
		///		<short>    Creates a new DavJob that issues a PROPPATCH command.</short>
		///<remarks>
		/// Creates a new DavJob that issues a SEARCH command.
		///<param> name="url" the URL of the resource
		///</param><param> name="nsURI" the URI of the search method's qualified name
		///</param><param> name="qName" the local part of the search method's qualified name
		///</param><param> name="query" the search string
		///</param><param> name="showProgressInfo" true to show progress information
		///</param></remarks>		<return> the new DavJob
		///    </return>
		///		<short>    Creates a new DavJob that issues a SEARCH command.</short>
		///<remarks>
		/// <see cref="KIO.RenameDialog"></see>
		/// Construct a modal, parent-less "rename" dialog, and return
		/// a result code, as well as the new dest. Much easier to use than the
		/// class RenameDialog directly.
		///<param> name="caption" the caption for the dialog box
		///</param><param> name="src" the URL of the file/dir we're trying to copy, as it's part of the text message
		///</param><param> name="dest" the URL of the destination file/dir, i.e. the one that already exists
		///</param><param> name="mode" parameters for the dialog (which buttons to show...),
		///             see RenameDialog_Mode
		///</param><param> name="newDestPath" the new destination path, valid if R_RENAME was returned.
		///</param><param> name="sizeSrc" size of source file
		///</param><param> name="sizeDest" size of destination file
		///</param><param> name="ctimeSrc" creation time of source file
		///</param><param> name="ctimeDest" creation time of destination file
		///</param><param> name="mtimeSrc" modification time of source file
		///</param><param> name="mtimeDest" modification time of destination file
		///</param></remarks>		<return> the result
		///   </return>
		///		<short>    <see cref="KIO.RenameDialog"></see>  Construct a modal, parent-less "rename" dialog, and return  a result code, as well as the new dest.</short>
		public static string ConvertSize(long size) {
			return (string) staticInterceptor.Invoke("convertSize$", "convertSize(KIO::filesize_t)", typeof(string), typeof(long), size);
		}
		public static string Number(long size) {
			return (string) staticInterceptor.Invoke("number$", "number(KIO::filesize_t)", typeof(string), typeof(long), size);
		}
		public static string ConvertSizeFromKiB(long kibSize) {
			return (string) staticInterceptor.Invoke("convertSizeFromKiB$", "convertSizeFromKiB(KIO::filesize_t)", typeof(string), typeof(long), kibSize);
		}
		public static uint CalculateRemainingSeconds(long totalSize, long processedSize, long speed) {
			return (uint) staticInterceptor.Invoke("calculateRemainingSeconds$$$", "calculateRemainingSeconds(KIO::filesize_t, KIO::filesize_t, KIO::filesize_t)", typeof(uint), typeof(long), totalSize, typeof(long), processedSize, typeof(long), speed);
		}
		public static string ConvertSeconds(uint seconds) {
			return (string) staticInterceptor.Invoke("convertSeconds$", "convertSeconds(unsigned int)", typeof(string), typeof(uint), seconds);
		}
		public static QTime CalculateRemaining(long totalSize, long processedSize, long speed) {
			return (QTime) staticInterceptor.Invoke("calculateRemaining$$$", "calculateRemaining(KIO::filesize_t, KIO::filesize_t, KIO::filesize_t)", typeof(QTime), typeof(long), totalSize, typeof(long), processedSize, typeof(long), speed);
		}
		public static string ItemsSummaryString(uint items, uint files, uint dirs, long size, bool showSize) {
			return (string) staticInterceptor.Invoke("itemsSummaryString$$$$$", "itemsSummaryString(uint, uint, uint, KIO::filesize_t, bool)", typeof(string), typeof(uint), items, typeof(uint), files, typeof(uint), dirs, typeof(long), size, typeof(bool), showSize);
		}
		public static string EncodeFileName(string str) {
			return (string) staticInterceptor.Invoke("encodeFileName$", "encodeFileName(const QString&)", typeof(string), typeof(string), str);
		}
		public static string DecodeFileName(string str) {
			return (string) staticInterceptor.Invoke("decodeFileName$", "decodeFileName(const QString&)", typeof(string), typeof(string), str);
		}
		public static string BuildErrorString(int errorCode, string errorText) {
			return (string) staticInterceptor.Invoke("buildErrorString$$", "buildErrorString(int, const QString&)", typeof(string), typeof(int), errorCode, typeof(string), errorText);
		}
		public static QByteArray RawErrorDetail(int errorCode, string errorText, KUrl reqUrl, int method) {
			return (QByteArray) staticInterceptor.Invoke("rawErrorDetail$$#$", "rawErrorDetail(int, const QString&, const KUrl*, int)", typeof(QByteArray), typeof(int), errorCode, typeof(string), errorText, typeof(KUrl), reqUrl, typeof(int), method);
		}
		public static QByteArray RawErrorDetail(int errorCode, string errorText, KUrl reqUrl) {
			return (QByteArray) staticInterceptor.Invoke("rawErrorDetail$$#", "rawErrorDetail(int, const QString&, const KUrl*)", typeof(QByteArray), typeof(int), errorCode, typeof(string), errorText, typeof(KUrl), reqUrl);
		}
		public static QByteArray RawErrorDetail(int errorCode, string errorText) {
			return (QByteArray) staticInterceptor.Invoke("rawErrorDetail$$", "rawErrorDetail(int, const QString&)", typeof(QByteArray), typeof(int), errorCode, typeof(string), errorText);
		}
		public static string UnsupportedActionErrorString(string protocol, int cmd) {
			return (string) staticInterceptor.Invoke("unsupportedActionErrorString$$", "unsupportedActionErrorString(const QString&, int)", typeof(string), typeof(string), protocol, typeof(int), cmd);
		}
		public static KIO.CacheControl ParseCacheControl(string cacheControl) {
			return (KIO.CacheControl) staticInterceptor.Invoke("parseCacheControl$", "parseCacheControl(const QString&)", typeof(KIO.CacheControl), typeof(string), cacheControl);
		}
		public static string GetCacheControlString(KIO.CacheControl cacheControl) {
			return (string) staticInterceptor.Invoke("getCacheControlString$", "getCacheControlString(KIO::CacheControl)", typeof(string), typeof(KIO.CacheControl), cacheControl);
		}
		public static bool Probably_slow_mounted(string filename) {
			return (bool) staticInterceptor.Invoke("probably_slow_mounted$", "probably_slow_mounted(const QString&)", typeof(bool), typeof(string), filename);
		}
		public static bool Manually_mounted(string filename) {
			return (bool) staticInterceptor.Invoke("manually_mounted$", "manually_mounted(const QString&)", typeof(bool), typeof(string), filename);
		}
		public static bool TestFileSystemFlag(string filename, KIO.FileSystemFlag flag) {
			return (bool) staticInterceptor.Invoke("testFileSystemFlag$$", "testFileSystemFlag(const QString&, KIO::FileSystemFlag)", typeof(bool), typeof(string), filename, typeof(KIO.FileSystemFlag), flag);
		}
		public static QPixmap PixmapForUrl(KUrl _url, long _mode) {
			return (QPixmap) staticInterceptor.Invoke("pixmapForUrl#$", "pixmapForUrl(const KUrl&, mode_t)", typeof(QPixmap), typeof(KUrl), _url, typeof(long), _mode);
		}
		public static QPixmap PixmapForUrl(KUrl _url) {
			return (QPixmap) staticInterceptor.Invoke("pixmapForUrl#", "pixmapForUrl(const KUrl&)", typeof(QPixmap), typeof(KUrl), _url);
		}
		public static KIO.SimpleJob Mkdir(KUrl url, int permissions) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("mkdir#$", "mkdir(const KUrl&, int)", typeof(KIO.SimpleJob), typeof(KUrl), url, typeof(int), permissions);
		}
		public static KIO.SimpleJob Mkdir(KUrl url) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("mkdir#", "mkdir(const KUrl&)", typeof(KIO.SimpleJob), typeof(KUrl), url);
		}
		public static KIO.SimpleJob Rmdir(KUrl url) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("rmdir#", "rmdir(const KUrl&)", typeof(KIO.SimpleJob), typeof(KUrl), url);
		}
		public static KIO.SimpleJob Chmod(KUrl url, int permissions) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("chmod#$", "chmod(const KUrl&, int)", typeof(KIO.SimpleJob), typeof(KUrl), url, typeof(int), permissions);
		}
		public static KIO.SimpleJob Rename(KUrl src, KUrl dest, bool overwrite) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("rename##$", "rename(const KUrl&, const KUrl&, bool)", typeof(KIO.SimpleJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(bool), overwrite);
		}
		public static KIO.SimpleJob Symlink(string target, KUrl dest, bool overwrite, bool showProgressInfo) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("symlink$#$$", "symlink(const QString&, const KUrl&, bool, bool)", typeof(KIO.SimpleJob), typeof(string), target, typeof(KUrl), dest, typeof(bool), overwrite, typeof(bool), showProgressInfo);
		}
		public static KIO.SimpleJob Symlink(string target, KUrl dest, bool overwrite) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("symlink$#$", "symlink(const QString&, const KUrl&, bool)", typeof(KIO.SimpleJob), typeof(string), target, typeof(KUrl), dest, typeof(bool), overwrite);
		}
		public static KIO.SimpleJob Special(KUrl url, QByteArray data, bool showProgressInfo) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("special##$", "special(const KUrl&, const QByteArray&, bool)", typeof(KIO.SimpleJob), typeof(KUrl), url, typeof(QByteArray), data, typeof(bool), showProgressInfo);
		}
		public static KIO.SimpleJob Special(KUrl url, QByteArray data) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("special##", "special(const KUrl&, const QByteArray&)", typeof(KIO.SimpleJob), typeof(KUrl), url, typeof(QByteArray), data);
		}
		public static KIO.SimpleJob Mount(bool ro, QByteArray fstype, string dev, string point, bool showProgressInfo) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("mount$#$$$", "mount(bool, const QByteArray&, const QString&, const QString&, bool)", typeof(KIO.SimpleJob), typeof(bool), ro, typeof(QByteArray), fstype, typeof(string), dev, typeof(string), point, typeof(bool), showProgressInfo);
		}
		public static KIO.SimpleJob Mount(bool ro, QByteArray fstype, string dev, string point) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("mount$#$$", "mount(bool, const QByteArray&, const QString&, const QString&)", typeof(KIO.SimpleJob), typeof(bool), ro, typeof(QByteArray), fstype, typeof(string), dev, typeof(string), point);
		}
		public static KIO.SimpleJob Unmount(string point, bool showProgressInfo) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("unmount$$", "unmount(const QString&, bool)", typeof(KIO.SimpleJob), typeof(string), point, typeof(bool), showProgressInfo);
		}
		public static KIO.SimpleJob Unmount(string point) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("unmount$", "unmount(const QString&)", typeof(KIO.SimpleJob), typeof(string), point);
		}
		public static KIO.SimpleJob Http_update_cache(KUrl url, bool no_cache, int expireDate) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("http_update_cache#$$", "http_update_cache(const KUrl&, bool, time_t)", typeof(KIO.SimpleJob), typeof(KUrl), url, typeof(bool), no_cache, typeof(int), expireDate);
		}
		public static KIO.StatJob Stat(KUrl url, bool showProgressInfo) {
			return (KIO.StatJob) staticInterceptor.Invoke("stat#$", "stat(const KUrl&, bool)", typeof(KIO.StatJob), typeof(KUrl), url, typeof(bool), showProgressInfo);
		}
		public static KIO.StatJob Stat(KUrl url) {
			return (KIO.StatJob) staticInterceptor.Invoke("stat#", "stat(const KUrl&)", typeof(KIO.StatJob), typeof(KUrl), url);
		}
		public static KIO.StatJob Stat(KUrl url, bool sideIsSource, short details, bool showProgressInfo) {
			return (KIO.StatJob) staticInterceptor.Invoke("stat#$$$", "stat(const KUrl&, bool, short int, bool)", typeof(KIO.StatJob), typeof(KUrl), url, typeof(bool), sideIsSource, typeof(short), details, typeof(bool), showProgressInfo);
		}
		public static KIO.StatJob Stat(KUrl url, bool sideIsSource, short details) {
			return (KIO.StatJob) staticInterceptor.Invoke("stat#$$", "stat(const KUrl&, bool, short int)", typeof(KIO.StatJob), typeof(KUrl), url, typeof(bool), sideIsSource, typeof(short), details);
		}
		public static KIO.TransferJob Get(KUrl url, bool reload, bool showProgressInfo) {
			return (KIO.TransferJob) staticInterceptor.Invoke("get#$$", "get(const KUrl&, bool, bool)", typeof(KIO.TransferJob), typeof(KUrl), url, typeof(bool), reload, typeof(bool), showProgressInfo);
		}
		public static KIO.TransferJob Get(KUrl url, bool reload) {
			return (KIO.TransferJob) staticInterceptor.Invoke("get#$", "get(const KUrl&, bool)", typeof(KIO.TransferJob), typeof(KUrl), url, typeof(bool), reload);
		}
		public static KIO.TransferJob Get(KUrl url) {
			return (KIO.TransferJob) staticInterceptor.Invoke("get#", "get(const KUrl&)", typeof(KIO.TransferJob), typeof(KUrl), url);
		}
		public static KIO.FileJob Open(KUrl url, int mode) {
			return (KIO.FileJob) staticInterceptor.Invoke("open#$", "open(const KUrl&, QIODevice::OpenMode)", typeof(KIO.FileJob), typeof(KUrl), url, typeof(int), mode);
		}
		public static KIO.TransferJob Put(KUrl url, int permissions, bool overwrite, bool resume, bool showProgressInfo) {
			return (KIO.TransferJob) staticInterceptor.Invoke("put#$$$$", "put(const KUrl&, int, bool, bool, bool)", typeof(KIO.TransferJob), typeof(KUrl), url, typeof(int), permissions, typeof(bool), overwrite, typeof(bool), resume, typeof(bool), showProgressInfo);
		}
		public static KIO.TransferJob Put(KUrl url, int permissions, bool overwrite, bool resume) {
			return (KIO.TransferJob) staticInterceptor.Invoke("put#$$$", "put(const KUrl&, int, bool, bool)", typeof(KIO.TransferJob), typeof(KUrl), url, typeof(int), permissions, typeof(bool), overwrite, typeof(bool), resume);
		}
		public static KIO.TransferJob Http_post(KUrl url, QByteArray postData, bool showProgressInfo) {
			return (KIO.TransferJob) staticInterceptor.Invoke("http_post##$", "http_post(const KUrl&, const QByteArray&, bool)", typeof(KIO.TransferJob), typeof(KUrl), url, typeof(QByteArray), postData, typeof(bool), showProgressInfo);
		}
		public static KIO.TransferJob Http_post(KUrl url, QByteArray postData) {
			return (KIO.TransferJob) staticInterceptor.Invoke("http_post##", "http_post(const KUrl&, const QByteArray&)", typeof(KIO.TransferJob), typeof(KUrl), url, typeof(QByteArray), postData);
		}
		public static KIO.StoredTransferJob StoredGet(KUrl url, bool reload, bool showProgressInfo) {
			return (KIO.StoredTransferJob) staticInterceptor.Invoke("storedGet#$$", "storedGet(const KUrl&, bool, bool)", typeof(KIO.StoredTransferJob), typeof(KUrl), url, typeof(bool), reload, typeof(bool), showProgressInfo);
		}
		public static KIO.StoredTransferJob StoredGet(KUrl url, bool reload) {
			return (KIO.StoredTransferJob) staticInterceptor.Invoke("storedGet#$", "storedGet(const KUrl&, bool)", typeof(KIO.StoredTransferJob), typeof(KUrl), url, typeof(bool), reload);
		}
		public static KIO.StoredTransferJob StoredGet(KUrl url) {
			return (KIO.StoredTransferJob) staticInterceptor.Invoke("storedGet#", "storedGet(const KUrl&)", typeof(KIO.StoredTransferJob), typeof(KUrl), url);
		}
		public static KIO.StoredTransferJob StoredPut(QByteArray arr, KUrl url, int permissions, bool overwrite, bool resume, bool showProgressInfo) {
			return (KIO.StoredTransferJob) staticInterceptor.Invoke("storedPut##$$$$", "storedPut(const QByteArray&, const KUrl&, int, bool, bool, bool)", typeof(KIO.StoredTransferJob), typeof(QByteArray), arr, typeof(KUrl), url, typeof(int), permissions, typeof(bool), overwrite, typeof(bool), resume, typeof(bool), showProgressInfo);
		}
		public static KIO.StoredTransferJob StoredPut(QByteArray arr, KUrl url, int permissions, bool overwrite, bool resume) {
			return (KIO.StoredTransferJob) staticInterceptor.Invoke("storedPut##$$$", "storedPut(const QByteArray&, const KUrl&, int, bool, bool)", typeof(KIO.StoredTransferJob), typeof(QByteArray), arr, typeof(KUrl), url, typeof(int), permissions, typeof(bool), overwrite, typeof(bool), resume);
		}
		public static KIO.MultiGetJob Multi_get(long id, KUrl url, KIO.MetaData metaData) {
			return (KIO.MultiGetJob) staticInterceptor.Invoke("multi_get$##", "multi_get(long, const KUrl&, const KIO::MetaData&)", typeof(KIO.MultiGetJob), typeof(long), id, typeof(KUrl), url, typeof(KIO.MetaData), metaData);
		}
		public static KIO.MimetypeJob Mimetype(KUrl url, bool showProgressInfo) {
			return (KIO.MimetypeJob) staticInterceptor.Invoke("mimetype#$", "mimetype(const KUrl&, bool)", typeof(KIO.MimetypeJob), typeof(KUrl), url, typeof(bool), showProgressInfo);
		}
		public static KIO.MimetypeJob Mimetype(KUrl url) {
			return (KIO.MimetypeJob) staticInterceptor.Invoke("mimetype#", "mimetype(const KUrl&)", typeof(KIO.MimetypeJob), typeof(KUrl), url);
		}
		public static KIO.FileCopyJob File_copy(KUrl src, KUrl dest, int permissions, bool overwrite, bool resume, bool showProgressInfo) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_copy##$$$$", "file_copy(const KUrl&, const KUrl&, int, bool, bool, bool)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions, typeof(bool), overwrite, typeof(bool), resume, typeof(bool), showProgressInfo);
		}
		public static KIO.FileCopyJob File_copy(KUrl src, KUrl dest, int permissions, bool overwrite, bool resume) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_copy##$$$", "file_copy(const KUrl&, const KUrl&, int, bool, bool)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions, typeof(bool), overwrite, typeof(bool), resume);
		}
		public static KIO.FileCopyJob File_copy(KUrl src, KUrl dest, int permissions, bool overwrite) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_copy##$$", "file_copy(const KUrl&, const KUrl&, int, bool)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions, typeof(bool), overwrite);
		}
		public static KIO.FileCopyJob File_copy(KUrl src, KUrl dest, int permissions) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_copy##$", "file_copy(const KUrl&, const KUrl&, int)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions);
		}
		public static KIO.FileCopyJob File_copy(KUrl src, KUrl dest) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_copy##", "file_copy(const KUrl&, const KUrl&)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest);
		}
		public static KIO.FileCopyJob File_move(KUrl src, KUrl dest, int permissions, bool overwrite, bool resume, bool showProgressInfo) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_move##$$$$", "file_move(const KUrl&, const KUrl&, int, bool, bool, bool)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions, typeof(bool), overwrite, typeof(bool), resume, typeof(bool), showProgressInfo);
		}
		public static KIO.FileCopyJob File_move(KUrl src, KUrl dest, int permissions, bool overwrite, bool resume) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_move##$$$", "file_move(const KUrl&, const KUrl&, int, bool, bool)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions, typeof(bool), overwrite, typeof(bool), resume);
		}
		public static KIO.FileCopyJob File_move(KUrl src, KUrl dest, int permissions, bool overwrite) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_move##$$", "file_move(const KUrl&, const KUrl&, int, bool)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions, typeof(bool), overwrite);
		}
		public static KIO.FileCopyJob File_move(KUrl src, KUrl dest, int permissions) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_move##$", "file_move(const KUrl&, const KUrl&, int)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions);
		}
		public static KIO.FileCopyJob File_move(KUrl src, KUrl dest) {
			return (KIO.FileCopyJob) staticInterceptor.Invoke("file_move##", "file_move(const KUrl&, const KUrl&)", typeof(KIO.FileCopyJob), typeof(KUrl), src, typeof(KUrl), dest);
		}
		public static KIO.SimpleJob File_delete(KUrl src, bool showProgressInfo) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("file_delete#$", "file_delete(const KUrl&, bool)", typeof(KIO.SimpleJob), typeof(KUrl), src, typeof(bool), showProgressInfo);
		}
		public static KIO.SimpleJob File_delete(KUrl src) {
			return (KIO.SimpleJob) staticInterceptor.Invoke("file_delete#", "file_delete(const KUrl&)", typeof(KIO.SimpleJob), typeof(KUrl), src);
		}
		public static KIO.ListJob ListDir(KUrl url, bool showProgressInfo, bool includeHidden) {
			return (KIO.ListJob) staticInterceptor.Invoke("listDir#$$", "listDir(const KUrl&, bool, bool)", typeof(KIO.ListJob), typeof(KUrl), url, typeof(bool), showProgressInfo, typeof(bool), includeHidden);
		}
		public static KIO.ListJob ListDir(KUrl url, bool showProgressInfo) {
			return (KIO.ListJob) staticInterceptor.Invoke("listDir#$", "listDir(const KUrl&, bool)", typeof(KIO.ListJob), typeof(KUrl), url, typeof(bool), showProgressInfo);
		}
		public static KIO.ListJob ListDir(KUrl url) {
			return (KIO.ListJob) staticInterceptor.Invoke("listDir#", "listDir(const KUrl&)", typeof(KIO.ListJob), typeof(KUrl), url);
		}
		public static KIO.ListJob ListRecursive(KUrl url, bool showProgressInfo, bool includeHidden) {
			return (KIO.ListJob) staticInterceptor.Invoke("listRecursive#$$", "listRecursive(const KUrl&, bool, bool)", typeof(KIO.ListJob), typeof(KUrl), url, typeof(bool), showProgressInfo, typeof(bool), includeHidden);
		}
		public static KIO.ListJob ListRecursive(KUrl url, bool showProgressInfo) {
			return (KIO.ListJob) staticInterceptor.Invoke("listRecursive#$", "listRecursive(const KUrl&, bool)", typeof(KIO.ListJob), typeof(KUrl), url, typeof(bool), showProgressInfo);
		}
		public static KIO.ListJob ListRecursive(KUrl url) {
			return (KIO.ListJob) staticInterceptor.Invoke("listRecursive#", "listRecursive(const KUrl&)", typeof(KIO.ListJob), typeof(KUrl), url);
		}
		public static KIO.CopyJob Copy(KUrl src, KUrl dest, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("copy##$", "copy(const KUrl&, const KUrl&, bool)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob Copy(KUrl src, KUrl dest) {
			return (KIO.CopyJob) staticInterceptor.Invoke("copy##", "copy(const KUrl&, const KUrl&)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest);
		}
		public static KIO.CopyJob CopyAs(KUrl src, KUrl dest, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("copyAs##$", "copyAs(const KUrl&, const KUrl&, bool)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob CopyAs(KUrl src, KUrl dest) {
			return (KIO.CopyJob) staticInterceptor.Invoke("copyAs##", "copyAs(const KUrl&, const KUrl&)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest);
		}
		public static KIO.CopyJob Copy(List<KUrl> src, KUrl dest, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("copy##$", "copy(const KUrl::List&, const KUrl&, bool)", typeof(KIO.CopyJob), typeof(List<KUrl>), src, typeof(KUrl), dest, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob Copy(List<KUrl> src, KUrl dest) {
			return (KIO.CopyJob) staticInterceptor.Invoke("copy##", "copy(const KUrl::List&, const KUrl&)", typeof(KIO.CopyJob), typeof(List<KUrl>), src, typeof(KUrl), dest);
		}
		public static KIO.CopyJob Move(KUrl src, KUrl dest, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("move##$", "move(const KUrl&, const KUrl&, bool)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob Move(KUrl src, KUrl dest) {
			return (KIO.CopyJob) staticInterceptor.Invoke("move##", "move(const KUrl&, const KUrl&)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest);
		}
		public static KIO.CopyJob MoveAs(KUrl src, KUrl dest, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("moveAs##$", "moveAs(const KUrl&, const KUrl&, bool)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob MoveAs(KUrl src, KUrl dest) {
			return (KIO.CopyJob) staticInterceptor.Invoke("moveAs##", "moveAs(const KUrl&, const KUrl&)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest);
		}
		public static KIO.CopyJob Move(List<KUrl> src, KUrl dest, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("move##$", "move(const KUrl::List&, const KUrl&, bool)", typeof(KIO.CopyJob), typeof(List<KUrl>), src, typeof(KUrl), dest, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob Move(List<KUrl> src, KUrl dest) {
			return (KIO.CopyJob) staticInterceptor.Invoke("move##", "move(const KUrl::List&, const KUrl&)", typeof(KIO.CopyJob), typeof(List<KUrl>), src, typeof(KUrl), dest);
		}
		public static KIO.CopyJob Link(KUrl src, KUrl destDir, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("link##$", "link(const KUrl&, const KUrl&, bool)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), destDir, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob Link(KUrl src, KUrl destDir) {
			return (KIO.CopyJob) staticInterceptor.Invoke("link##", "link(const KUrl&, const KUrl&)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), destDir);
		}
		public static KIO.CopyJob Link(List<KUrl> src, KUrl destDir, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("link##$", "link(const KUrl::List&, const KUrl&, bool)", typeof(KIO.CopyJob), typeof(List<KUrl>), src, typeof(KUrl), destDir, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob Link(List<KUrl> src, KUrl destDir) {
			return (KIO.CopyJob) staticInterceptor.Invoke("link##", "link(const KUrl::List&, const KUrl&)", typeof(KIO.CopyJob), typeof(List<KUrl>), src, typeof(KUrl), destDir);
		}
		public static KIO.CopyJob LinkAs(KUrl src, KUrl dest, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("linkAs##$", "linkAs(const KUrl&, const KUrl&, bool)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob LinkAs(KUrl src, KUrl dest) {
			return (KIO.CopyJob) staticInterceptor.Invoke("linkAs##", "linkAs(const KUrl&, const KUrl&)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(KUrl), dest);
		}
		public static KIO.CopyJob Trash(KUrl src, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("trash#$", "trash(const KUrl&, bool)", typeof(KIO.CopyJob), typeof(KUrl), src, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob Trash(KUrl src) {
			return (KIO.CopyJob) staticInterceptor.Invoke("trash#", "trash(const KUrl&)", typeof(KIO.CopyJob), typeof(KUrl), src);
		}
		public static KIO.CopyJob Trash(List<KUrl> src, bool showProgressInfo) {
			return (KIO.CopyJob) staticInterceptor.Invoke("trash#$", "trash(const KUrl::List&, bool)", typeof(KIO.CopyJob), typeof(List<KUrl>), src, typeof(bool), showProgressInfo);
		}
		public static KIO.CopyJob Trash(List<KUrl> src) {
			return (KIO.CopyJob) staticInterceptor.Invoke("trash#", "trash(const KUrl::List&)", typeof(KIO.CopyJob), typeof(List<KUrl>), src);
		}
		public static KIO.DeleteJob Del(KUrl src, bool shred, bool showProgressInfo) {
			return (KIO.DeleteJob) staticInterceptor.Invoke("del#$$", "del(const KUrl&, bool, bool)", typeof(KIO.DeleteJob), typeof(KUrl), src, typeof(bool), shred, typeof(bool), showProgressInfo);
		}
		public static KIO.DeleteJob Del(KUrl src, bool shred) {
			return (KIO.DeleteJob) staticInterceptor.Invoke("del#$", "del(const KUrl&, bool)", typeof(KIO.DeleteJob), typeof(KUrl), src, typeof(bool), shred);
		}
		public static KIO.DeleteJob Del(KUrl src) {
			return (KIO.DeleteJob) staticInterceptor.Invoke("del#", "del(const KUrl&)", typeof(KIO.DeleteJob), typeof(KUrl), src);
		}
		public static KIO.DeleteJob Del(List<KUrl> src, bool shred, bool showProgressInfo) {
			return (KIO.DeleteJob) staticInterceptor.Invoke("del#$$", "del(const KUrl::List&, bool, bool)", typeof(KIO.DeleteJob), typeof(List<KUrl>), src, typeof(bool), shred, typeof(bool), showProgressInfo);
		}
		public static KIO.DeleteJob Del(List<KUrl> src, bool shred) {
			return (KIO.DeleteJob) staticInterceptor.Invoke("del#$", "del(const KUrl::List&, bool)", typeof(KIO.DeleteJob), typeof(List<KUrl>), src, typeof(bool), shred);
		}
		public static KIO.DeleteJob Del(List<KUrl> src) {
			return (KIO.DeleteJob) staticInterceptor.Invoke("del#", "del(const KUrl::List&)", typeof(KIO.DeleteJob), typeof(List<KUrl>), src);
		}
		public static KIO.CopyJob PasteMimeSource(QMimeData data, KUrl destURL, string dialogText, QWidget widget, bool clipboard) {
			return (KIO.CopyJob) staticInterceptor.Invoke("pasteMimeSource##$#$", "pasteMimeSource(const QMimeData*, const KUrl&, const QString&, QWidget*, bool)", typeof(KIO.CopyJob), typeof(QMimeData), data, typeof(KUrl), destURL, typeof(string), dialogText, typeof(QWidget), widget, typeof(bool), clipboard);
		}
		public static KIO.CopyJob PasteMimeSource(QMimeData data, KUrl destURL, string dialogText, QWidget widget) {
			return (KIO.CopyJob) staticInterceptor.Invoke("pasteMimeSource##$#", "pasteMimeSource(const QMimeData*, const KUrl&, const QString&, QWidget*)", typeof(KIO.CopyJob), typeof(QMimeData), data, typeof(KUrl), destURL, typeof(string), dialogText, typeof(QWidget), widget);
		}
		public static string PasteActionText() {
			return (string) staticInterceptor.Invoke("pasteActionText", "pasteActionText()", typeof(string));
		}
		public static QDataStream Write(QDataStream s, KIO.AuthInfo a) {
			return (QDataStream) staticInterceptor.Invoke("operator<<##", "operator<<(QDataStream&, const KIO::AuthInfo&)", typeof(QDataStream), typeof(QDataStream), s, typeof(KIO.AuthInfo), a);
		}
		public static QDataStream Read(QDataStream s, KIO.AuthInfo a) {
			return (QDataStream) staticInterceptor.Invoke("operator>>##", "operator>>(QDataStream&, KIO::AuthInfo&)", typeof(QDataStream), typeof(QDataStream), s, typeof(KIO.AuthInfo), a);
		}
		public static KIO.PreviewJob FilePreview(List<KFileItem> items, int width, int height, int iconSize, int iconAlpha, bool scale, bool save, List<string> enabledPlugins) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$$$$?", "filePreview(const KFileItemList&, int, int, int, int, bool, bool, const QStringList*)", typeof(KIO.PreviewJob), typeof(List<KFileItem>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize, typeof(int), iconAlpha, typeof(bool), scale, typeof(bool), save, typeof(List<string>), enabledPlugins);
		}
		public static KIO.PreviewJob FilePreview(List<KFileItem> items, int width, int height, int iconSize, int iconAlpha, bool scale, bool save) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$$$$", "filePreview(const KFileItemList&, int, int, int, int, bool, bool)", typeof(KIO.PreviewJob), typeof(List<KFileItem>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize, typeof(int), iconAlpha, typeof(bool), scale, typeof(bool), save);
		}
		public static KIO.PreviewJob FilePreview(List<KFileItem> items, int width, int height, int iconSize, int iconAlpha, bool scale) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$$$", "filePreview(const KFileItemList&, int, int, int, int, bool)", typeof(KIO.PreviewJob), typeof(List<KFileItem>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize, typeof(int), iconAlpha, typeof(bool), scale);
		}
		public static KIO.PreviewJob FilePreview(List<KFileItem> items, int width, int height, int iconSize, int iconAlpha) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$$", "filePreview(const KFileItemList&, int, int, int, int)", typeof(KIO.PreviewJob), typeof(List<KFileItem>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize, typeof(int), iconAlpha);
		}
		public static KIO.PreviewJob FilePreview(List<KFileItem> items, int width, int height, int iconSize) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$", "filePreview(const KFileItemList&, int, int, int)", typeof(KIO.PreviewJob), typeof(List<KFileItem>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize);
		}
		public static KIO.PreviewJob FilePreview(List<KFileItem> items, int width, int height) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$", "filePreview(const KFileItemList&, int, int)", typeof(KIO.PreviewJob), typeof(List<KFileItem>), items, typeof(int), width, typeof(int), height);
		}
		public static KIO.PreviewJob FilePreview(List<KFileItem> items, int width) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$", "filePreview(const KFileItemList&, int)", typeof(KIO.PreviewJob), typeof(List<KFileItem>), items, typeof(int), width);
		}
		public static KIO.PreviewJob FilePreview(List<KUrl> items, int width, int height, int iconSize, int iconAlpha, bool scale, bool save, List<string> enabledPlugins) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$$$$?", "filePreview(const KUrl::List&, int, int, int, int, bool, bool, const QStringList*)", typeof(KIO.PreviewJob), typeof(List<KUrl>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize, typeof(int), iconAlpha, typeof(bool), scale, typeof(bool), save, typeof(List<string>), enabledPlugins);
		}
		public static KIO.PreviewJob FilePreview(List<KUrl> items, int width, int height, int iconSize, int iconAlpha, bool scale, bool save) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$$$$", "filePreview(const KUrl::List&, int, int, int, int, bool, bool)", typeof(KIO.PreviewJob), typeof(List<KUrl>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize, typeof(int), iconAlpha, typeof(bool), scale, typeof(bool), save);
		}
		public static KIO.PreviewJob FilePreview(List<KUrl> items, int width, int height, int iconSize, int iconAlpha, bool scale) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$$$", "filePreview(const KUrl::List&, int, int, int, int, bool)", typeof(KIO.PreviewJob), typeof(List<KUrl>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize, typeof(int), iconAlpha, typeof(bool), scale);
		}
		public static KIO.PreviewJob FilePreview(List<KUrl> items, int width, int height, int iconSize, int iconAlpha) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$$", "filePreview(const KUrl::List&, int, int, int, int)", typeof(KIO.PreviewJob), typeof(List<KUrl>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize, typeof(int), iconAlpha);
		}
		public static KIO.PreviewJob FilePreview(List<KUrl> items, int width, int height, int iconSize) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$$", "filePreview(const KUrl::List&, int, int, int)", typeof(KIO.PreviewJob), typeof(List<KUrl>), items, typeof(int), width, typeof(int), height, typeof(int), iconSize);
		}
		public static KIO.PreviewJob FilePreview(List<KUrl> items, int width, int height) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$$", "filePreview(const KUrl::List&, int, int)", typeof(KIO.PreviewJob), typeof(List<KUrl>), items, typeof(int), width, typeof(int), height);
		}
		public static KIO.PreviewJob FilePreview(List<KUrl> items, int width) {
			return (KIO.PreviewJob) staticInterceptor.Invoke("filePreview#$", "filePreview(const KUrl::List&, int)", typeof(KIO.PreviewJob), typeof(List<KUrl>), items, typeof(int), width);
		}
		public static KIO.MetaInfoJob FileMetaInfo(List<KFileItem> items) {
			return (KIO.MetaInfoJob) staticInterceptor.Invoke("fileMetaInfo#", "fileMetaInfo(const KFileItemList&)", typeof(KIO.MetaInfoJob), typeof(List<KFileItem>), items);
		}
		public static KIO.MetaInfoJob FileMetaInfo(List<KUrl> items) {
			return (KIO.MetaInfoJob) staticInterceptor.Invoke("fileMetaInfo#", "fileMetaInfo(const KUrl::List&)", typeof(KIO.MetaInfoJob), typeof(List<KUrl>), items);
		}
		public static KIO.DavJob DavPropFind(KUrl url, QDomDocument properties, string depth, bool showProgressInfo) {
			return (KIO.DavJob) staticInterceptor.Invoke("davPropFind##$$", "davPropFind(const KUrl&, const QDomDocument&, const QString&, bool)", typeof(KIO.DavJob), typeof(KUrl), url, typeof(QDomDocument), properties, typeof(string), depth, typeof(bool), showProgressInfo);
		}
		public static KIO.DavJob DavPropFind(KUrl url, QDomDocument properties, string depth) {
			return (KIO.DavJob) staticInterceptor.Invoke("davPropFind##$", "davPropFind(const KUrl&, const QDomDocument&, const QString&)", typeof(KIO.DavJob), typeof(KUrl), url, typeof(QDomDocument), properties, typeof(string), depth);
		}
		public static KIO.DavJob DavPropPatch(KUrl url, QDomDocument properties, bool showProgressInfo) {
			return (KIO.DavJob) staticInterceptor.Invoke("davPropPatch##$", "davPropPatch(const KUrl&, const QDomDocument&, bool)", typeof(KIO.DavJob), typeof(KUrl), url, typeof(QDomDocument), properties, typeof(bool), showProgressInfo);
		}
		public static KIO.DavJob DavPropPatch(KUrl url, QDomDocument properties) {
			return (KIO.DavJob) staticInterceptor.Invoke("davPropPatch##", "davPropPatch(const KUrl&, const QDomDocument&)", typeof(KIO.DavJob), typeof(KUrl), url, typeof(QDomDocument), properties);
		}
		public static KIO.DavJob DavSearch(KUrl url, string nsURI, string qName, string query, bool showProgressInfo) {
			return (KIO.DavJob) staticInterceptor.Invoke("davSearch#$$$$", "davSearch(const KUrl&, const QString&, const QString&, const QString&, bool)", typeof(KIO.DavJob), typeof(KUrl), url, typeof(string), nsURI, typeof(string), qName, typeof(string), query, typeof(bool), showProgressInfo);
		}
		public static KIO.DavJob DavSearch(KUrl url, string nsURI, string qName, string query) {
			return (KIO.DavJob) staticInterceptor.Invoke("davSearch#$$$", "davSearch(const KUrl&, const QString&, const QString&, const QString&)", typeof(KIO.DavJob), typeof(KUrl), url, typeof(string), nsURI, typeof(string), qName, typeof(string), query);
		}
		public static KIO.RenameDialog_Result Open_RenameDialog(string caption, KUrl src, KUrl dest, KIO.RenameDialog_Mode mode, StringBuilder newDestPath, long sizeSrc, long sizeDest, int ctimeSrc, int ctimeDest, int mtimeSrc, int mtimeDest) {
			return (KIO.RenameDialog_Result) staticInterceptor.Invoke("open_RenameDialog$##$$$$$$$$", "open_RenameDialog(const QString&, const KUrl&, const KUrl&, KIO::RenameDialog_Mode, QString&, KIO::filesize_t, KIO::filesize_t, time_t, time_t, time_t, time_t)", typeof(KIO.RenameDialog_Result), typeof(string), caption, typeof(KUrl), src, typeof(KUrl), dest, typeof(KIO.RenameDialog_Mode), mode, typeof(StringBuilder), newDestPath, typeof(long), sizeSrc, typeof(long), sizeDest, typeof(int), ctimeSrc, typeof(int), ctimeDest, typeof(int), mtimeSrc, typeof(int), mtimeDest);
		}
		public static KIO.RenameDialog_Result Open_RenameDialog(string caption, KUrl src, KUrl dest, KIO.RenameDialog_Mode mode, StringBuilder newDestPath, long sizeSrc, long sizeDest, int ctimeSrc, int ctimeDest, int mtimeSrc) {
			return (KIO.RenameDialog_Result) staticInterceptor.Invoke("open_RenameDialog$##$$$$$$$", "open_RenameDialog(const QString&, const KUrl&, const KUrl&, KIO::RenameDialog_Mode, QString&, KIO::filesize_t, KIO::filesize_t, time_t, time_t, time_t)", typeof(KIO.RenameDialog_Result), typeof(string), caption, typeof(KUrl), src, typeof(KUrl), dest, typeof(KIO.RenameDialog_Mode), mode, typeof(StringBuilder), newDestPath, typeof(long), sizeSrc, typeof(long), sizeDest, typeof(int), ctimeSrc, typeof(int), ctimeDest, typeof(int), mtimeSrc);
		}
		public static KIO.RenameDialog_Result Open_RenameDialog(string caption, KUrl src, KUrl dest, KIO.RenameDialog_Mode mode, StringBuilder newDestPath, long sizeSrc, long sizeDest, int ctimeSrc, int ctimeDest) {
			return (KIO.RenameDialog_Result) staticInterceptor.Invoke("open_RenameDialog$##$$$$$$", "open_RenameDialog(const QString&, const KUrl&, const KUrl&, KIO::RenameDialog_Mode, QString&, KIO::filesize_t, KIO::filesize_t, time_t, time_t)", typeof(KIO.RenameDialog_Result), typeof(string), caption, typeof(KUrl), src, typeof(KUrl), dest, typeof(KIO.RenameDialog_Mode), mode, typeof(StringBuilder), newDestPath, typeof(long), sizeSrc, typeof(long), sizeDest, typeof(int), ctimeSrc, typeof(int), ctimeDest);
		}
		public static KIO.RenameDialog_Result Open_RenameDialog(string caption, KUrl src, KUrl dest, KIO.RenameDialog_Mode mode, StringBuilder newDestPath, long sizeSrc, long sizeDest, int ctimeSrc) {
			return (KIO.RenameDialog_Result) staticInterceptor.Invoke("open_RenameDialog$##$$$$$", "open_RenameDialog(const QString&, const KUrl&, const KUrl&, KIO::RenameDialog_Mode, QString&, KIO::filesize_t, KIO::filesize_t, time_t)", typeof(KIO.RenameDialog_Result), typeof(string), caption, typeof(KUrl), src, typeof(KUrl), dest, typeof(KIO.RenameDialog_Mode), mode, typeof(StringBuilder), newDestPath, typeof(long), sizeSrc, typeof(long), sizeDest, typeof(int), ctimeSrc);
		}
		public static KIO.RenameDialog_Result Open_RenameDialog(string caption, KUrl src, KUrl dest, KIO.RenameDialog_Mode mode, StringBuilder newDestPath, long sizeSrc, long sizeDest) {
			return (KIO.RenameDialog_Result) staticInterceptor.Invoke("open_RenameDialog$##$$$$", "open_RenameDialog(const QString&, const KUrl&, const KUrl&, KIO::RenameDialog_Mode, QString&, KIO::filesize_t, KIO::filesize_t)", typeof(KIO.RenameDialog_Result), typeof(string), caption, typeof(KUrl), src, typeof(KUrl), dest, typeof(KIO.RenameDialog_Mode), mode, typeof(StringBuilder), newDestPath, typeof(long), sizeSrc, typeof(long), sizeDest);
		}
		public static KIO.RenameDialog_Result Open_RenameDialog(string caption, KUrl src, KUrl dest, KIO.RenameDialog_Mode mode, StringBuilder newDestPath, long sizeSrc) {
			return (KIO.RenameDialog_Result) staticInterceptor.Invoke("open_RenameDialog$##$$$", "open_RenameDialog(const QString&, const KUrl&, const KUrl&, KIO::RenameDialog_Mode, QString&, KIO::filesize_t)", typeof(KIO.RenameDialog_Result), typeof(string), caption, typeof(KUrl), src, typeof(KUrl), dest, typeof(KIO.RenameDialog_Mode), mode, typeof(StringBuilder), newDestPath, typeof(long), sizeSrc);
		}
		public static KIO.RenameDialog_Result Open_RenameDialog(string caption, KUrl src, KUrl dest, KIO.RenameDialog_Mode mode, StringBuilder newDestPath) {
			return (KIO.RenameDialog_Result) staticInterceptor.Invoke("open_RenameDialog$##$$", "open_RenameDialog(const QString&, const KUrl&, const KUrl&, KIO::RenameDialog_Mode, QString&)", typeof(KIO.RenameDialog_Result), typeof(string), caption, typeof(KUrl), src, typeof(KUrl), dest, typeof(KIO.RenameDialog_Mode), mode, typeof(StringBuilder), newDestPath);
		}
		public static KIO.SkipDialog_Result Open_SkipDialog(bool _multi, string _error_text) {
			return (KIO.SkipDialog_Result) staticInterceptor.Invoke("open_SkipDialog$$", "open_SkipDialog(bool, const QString&)", typeof(KIO.SkipDialog_Result), typeof(bool), _multi, typeof(string), _error_text);
		}
		public static KIO.SkipDialog_Result Open_SkipDialog(bool _multi) {
			return (KIO.SkipDialog_Result) staticInterceptor.Invoke("open_SkipDialog$", "open_SkipDialog(bool)", typeof(KIO.SkipDialog_Result), typeof(bool), _multi);
		}
	}
}
