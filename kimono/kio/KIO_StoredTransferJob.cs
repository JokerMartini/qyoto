//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KIO {

	using System;
	using Qyoto;

	/// <remarks>
	///  StoredTransferJob is a TransferJob (for downloading or uploading data) that
	///  also stores a QByteArray with the data, making it simpler to use than the
	///  standard TransferJob.
	///  For KIO.StoredGet it puts the data into the member QByteArray, so the user
	///  of this class can get hold of the whole data at once by calling data()
	///  when the result signal is emitted.
	///  You should only use StoredTransferJob to download data if you cannot
	///  process the data by chunks while it's being downloaded, since storing
	///  everything in a QByteArray can potentially require a lot of memory.
	///  For KIO.StoredPut the user of this class simply provides the bytearray from
	///  the start, and the job takes care of uploading it.
	///  You should only use StoredTransferJob to upload data if you cannot
	///  provide the in chunks while it's being uploaded, since storing
	///  everything in a QByteArray can potentially require a lot of memory.
	///      </remarks>		<short>    StoredTransferJob is a TransferJob (for downloading or uploading data) that  also stores a QByteArray with the data, making it simpler to use than the  standard TransferJob.</short>

	[SmokeClass("KIO::StoredTransferJob")]
	public class StoredTransferJob : KIO.TransferJob, IDisposable {
 		protected StoredTransferJob(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(StoredTransferJob), this);
		}
		/// <remarks>
		///  Do not create a StoredTransferJob. Use storedGet() or storedPut()
		///  instead.
		/// <param> name="url" the url to get or put
		/// </param><param> name="command" the command to issue
		/// </param><param> name="packedArgs" the arguments
		/// </param><param> name="_staticData" additional data to transmit (e.g. in a HTTP Post)
		/// 	</param></remarks>		<short>    Do not create a StoredTransferJob.</short>
		public StoredTransferJob(KUrl url, int command, QByteArray packedArgs, QByteArray _staticData) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("StoredTransferJob#$##", "StoredTransferJob(const KUrl&, int, const QByteArray&, const QByteArray&)", typeof(void), typeof(KUrl), url, typeof(int), command, typeof(QByteArray), packedArgs, typeof(QByteArray), _staticData);
		}
		/// <remarks>
		///  Set data to be uploaded. This is for put jobs.
		///  Automatically called by KIO.StoredPut(QByteArray, ...),
		///  do not call this yourself.
		///          </remarks>		<short>    Set data to be uploaded.</short>
		public void SetData(QByteArray arr) {
			interceptor.Invoke("setData#", "setData(const QByteArray&)", typeof(void), typeof(QByteArray), arr);
		}
		/// <remarks>
		///  Get hold of the downloaded data. This is for get jobs.
		///  You're supposed to call this only from the slot connected to the result() signal.
		///          </remarks>		<short>    Get hold of the downloaded data.</short>
		public QByteArray Data() {
			return (QByteArray) interceptor.Invoke("data", "data() const", typeof(QByteArray));
		}
		~StoredTransferJob() {
			interceptor.Invoke("~StoredTransferJob", "~StoredTransferJob()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~StoredTransferJob", "~StoredTransferJob()", typeof(void));
		}
		protected new IStoredTransferJobSignals Emit {
			get { return (IStoredTransferJobSignals) Q_EMIT; }
		}
	}

	public interface IStoredTransferJobSignals : KIO.ITransferJobSignals {
	}
	}
}
