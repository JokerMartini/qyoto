//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KIO {

	using System;
	using Qyoto;

	/// <remarks>
	///  The FileCopyJob copies data from one place to another.
	///  See <see cref="IFileCopyJobSignals"></see> for signals emitted by FileCopyJob
	/// </remarks>		<short>    The FileCopyJob copies data from one place to another.</short>
	/// 		<see> file_copy</see>
	/// 		<see> file_move</see>

	[SmokeClass("KIO::FileCopyJob")]
	public class FileCopyJob : KIO.Job {
 		protected FileCopyJob(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(FileCopyJob), this);
		}
		/// <remarks>
		///  Do not create a FileCopyJob directly. Use KIO.File_move()
		///  or KIO.File_copy() instead.
		/// <param> name="src" the source URL
		/// </param><param> name="dest" the destination URL
		/// </param><param> name="permissions" the permissions of the resulting resource
		/// </param><param> name="move" true to move, false to copy
		/// </param><param> name="overwrite" true to allow overwriting, false otherwise
		/// </param><param> name="resume" true to resume an operation, false otherwise
		/// 	 </param></remarks>		<short>    Do not create a FileCopyJob directly.</short>
		public FileCopyJob(KUrl src, KUrl dest, int permissions, bool move, bool overwrite, bool resume) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("FileCopyJob##$$$$", "FileCopyJob(const KUrl&, const KUrl&, int, bool, bool, bool)", typeof(void), typeof(KUrl), src, typeof(KUrl), dest, typeof(int), permissions, typeof(bool), move, typeof(bool), overwrite, typeof(bool), resume);
		}
		/// <remarks>
		///  If you know the size of the source file, call this method
		///  to inform this job. It will be displayed in the "resume" dialog.
		/// <param> name="size" the size of the source file
		///          </param></remarks>		<short>    If you know the size of the source file, call this method  to inform this job.</short>
		public void SetSourceSize(long size) {
			interceptor.Invoke("setSourceSize$", "setSourceSize(KIO::filesize_t)", typeof(void), typeof(long), size);
		}
		/// <remarks>
		///  Sets the modification time of the file
		///  Note that this is ignored if a direct copy (SlaveBase.Copy) can be done,
		///  in which case the mtime of the source is applied to the destination (if the protocol
		///  supports the concept).
		///          </remarks>		<short>    Sets the modification time of the file </short>
		public void SetModificationTime(QDateTime mtime) {
			interceptor.Invoke("setModificationTime#", "setModificationTime(const QDateTime&)", typeof(void), typeof(QDateTime), mtime);
		}
		/// <remarks>
		///  Returns the source URL.
		/// </remarks>		<return> the source URL
		/// 	 </return>
		/// 		<short>    Returns the source URL.</short>
		public KUrl SrcUrl() {
			return (KUrl) interceptor.Invoke("srcUrl", "srcUrl() const", typeof(KUrl));
		}
		/// <remarks>
		///  Returns the destination URL.
		/// </remarks>		<return> the destination URL
		/// 	 </return>
		/// 		<short>    Returns the destination URL.</short>
		public KUrl DestUrl() {
			return (KUrl) interceptor.Invoke("destUrl", "destUrl() const", typeof(KUrl));
		}
		[Q_SLOT("void slotStart()")]
		public void SlotStart() {
			interceptor.Invoke("slotStart", "slotStart()", typeof(void));
		}
		[Q_SLOT("void slotData(KIO::Job*, const QByteArray&)")]
		public void SlotData(KIO.Job arg1, QByteArray data) {
			interceptor.Invoke("slotData##", "slotData(KIO::Job*, const QByteArray&)", typeof(void), typeof(KIO.Job), arg1, typeof(QByteArray), data);
		}
		[Q_SLOT("void slotDataReq(KIO::Job*, QByteArray&)")]
		public void SlotDataReq(KIO.Job arg1, QByteArray data) {
			interceptor.Invoke("slotDataReq##", "slotDataReq(KIO::Job*, QByteArray&)", typeof(void), typeof(KIO.Job), arg1, typeof(QByteArray), data);
		}
		[Q_SLOT("void slotMimetype(KIO::Job*, const QString&)")]
		public void SlotMimetype(KIO.Job arg1, string type) {
			interceptor.Invoke("slotMimetype#$", "slotMimetype(KIO::Job*, const QString&)", typeof(void), typeof(KIO.Job), arg1, typeof(string), type);
		}
		protected void StartCopyJob() {
			interceptor.Invoke("startCopyJob", "startCopyJob()", typeof(void));
		}
		protected void StartCopyJob(KUrl slave_url) {
			interceptor.Invoke("startCopyJob#", "startCopyJob(const KUrl&)", typeof(void), typeof(KUrl), slave_url);
		}
		protected void StartRenameJob(KUrl slave_url) {
			interceptor.Invoke("startRenameJob#", "startRenameJob(const KUrl&)", typeof(void), typeof(KUrl), slave_url);
		}
		protected void StartDataPump() {
			interceptor.Invoke("startDataPump", "startDataPump()", typeof(void));
		}
		protected void ConnectSubjob(KIO.SimpleJob job) {
			interceptor.Invoke("connectSubjob#", "connectSubjob(KIO::SimpleJob*)", typeof(void), typeof(KIO.SimpleJob), job);
		}
		[SmokeMethod("doSuspend()")]
		protected new virtual bool DoSuspend() {
			return (bool) interceptor.Invoke("doSuspend", "doSuspend()", typeof(bool));
		}
		[SmokeMethod("doResume()")]
		protected new virtual bool DoResume() {
			return (bool) interceptor.Invoke("doResume", "doResume()", typeof(bool));
		}
		/// <remarks>
		///  Called whenever a subjob finishes.
		/// <param> name="job" the job that emitted this signal
		///          </param></remarks>		<short>    Called whenever a subjob finishes.</short>
		[Q_SLOT("void slotResult(KJob*)")]
		[SmokeMethod("slotResult(KJob*)")]
		protected override void SlotResult(KJob job) {
			interceptor.Invoke("slotResult#", "slotResult(KJob*)", typeof(void), typeof(KJob), job);
		}
		/// <remarks>
		///  Forward signal from subjob
		/// <param> name="job" the job that emitted this signal
		/// </param><param> name="size" the processed size in bytes
		///          </param></remarks>		<short>    Forward signal from subjob </short>
		[Q_SLOT("void slotProcessedSize(KJob*, qulonglong)")]
		protected void SlotProcessedSize(KJob job, ulong size) {
			interceptor.Invoke("slotProcessedSize#$", "slotProcessedSize(KJob*, qulonglong)", typeof(void), typeof(KJob), job, typeof(ulong), size);
		}
		/// <remarks>
		///  Forward signal from subjob
		/// <param> name="job" the job that emitted this signal
		/// </param><param> name="size" the total size
		///          </param></remarks>		<short>    Forward signal from subjob </short>
		[Q_SLOT("void slotTotalSize(KJob*, qulonglong)")]
		protected void SlotTotalSize(KJob job, ulong size) {
			interceptor.Invoke("slotTotalSize#$", "slotTotalSize(KJob*, qulonglong)", typeof(void), typeof(KJob), job, typeof(ulong), size);
		}
		/// <remarks>
		///  Forward signal from subjob
		/// <param> name="job" the job that emitted this signal
		/// </param><param> name="pct" the percentage
		///          </param></remarks>		<short>    Forward signal from subjob </short>
		[Q_SLOT("void slotPercent(KJob*, unsigned long)")]
		protected void SlotPercent(KJob job, ulong pct) {
			interceptor.Invoke("slotPercent#$", "slotPercent(KJob*, unsigned long)", typeof(void), typeof(KJob), job, typeof(ulong), pct);
		}
		/// <remarks>
		///  Forward signal from subjob
		/// <param> name="job" the job that emitted this signal
		/// </param><param> name="offset" the offset to resume from
		///          </param></remarks>		<short>    Forward signal from subjob </short>
		[Q_SLOT("void slotCanResume(KIO::Job*, KIO::filesize_t)")]
		protected void SlotCanResume(KIO.Job job, long offset) {
			interceptor.Invoke("slotCanResume#$", "slotCanResume(KIO::Job*, KIO::filesize_t)", typeof(void), typeof(KIO.Job), job, typeof(long), offset);
		}
		protected new IFileCopyJobSignals Emit {
			get { return (IFileCopyJobSignals) Q_EMIT; }
		}
	}

	public interface IFileCopyJobSignals : KIO.IJobSignals {
		/// <remarks>
		///  Mimetype determined during a file copy.
		///  This is never emitted during a move, and might not be emitted during
		///  a file copy, depending on the slave. But when a get and a put are
		///  being used (which is the common case), this signal forwards the
		///  mimetype information from the get job.
		/// <param> name="job" the job that emitted this signal
		/// </param><param> name="type" the mime type
		///          </param></remarks>		<short>    Mimetype determined during a file copy.</short>
		[Q_SIGNAL("void mimetype(KIO::Job*, const QString&)")]
		void Mimetype(KIO.Job job, string type);
	}
	}
}
