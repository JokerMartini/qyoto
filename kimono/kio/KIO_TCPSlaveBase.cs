//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KIO {

	using System;
	using Qyoto;

	/// <remarks>
	///  There are two classes that specifies the protocol between application (job)
	///  and kioslave. SlaveInterface is the class to use on the application end,
	///  SlaveBase is the one to use on the slave end.
	///  Slave implementations should simply inherit SlaveBase
	///  A call to foo() results in a call to slotFoo() on the other end.
	///  </remarks>		<short>    There are two classes that specifies the protocol between application (job)  and kioslave.</short>

	[SmokeClass("KIO::TCPSlaveBase")]
	public class TCPSlaveBase : KIO.SlaveBase {
 		protected TCPSlaveBase(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(TCPSlaveBase), this);
		}
		public TCPSlaveBase(ushort defaultPort, QByteArray protocol, QByteArray poolSocket, QByteArray appSocket, bool useSSL) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("TCPSlaveBase$###$", "TCPSlaveBase(unsigned short int, const QByteArray&, const QByteArray&, const QByteArray&, bool)", typeof(void), typeof(ushort), defaultPort, typeof(QByteArray), protocol, typeof(QByteArray), poolSocket, typeof(QByteArray), appSocket, typeof(bool), useSSL);
		}
		public TCPSlaveBase(ushort defaultPort, QByteArray protocol, QByteArray poolSocket, QByteArray appSocket) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("TCPSlaveBase$###", "TCPSlaveBase(unsigned short int, const QByteArray&, const QByteArray&, const QByteArray&)", typeof(void), typeof(ushort), defaultPort, typeof(QByteArray), protocol, typeof(QByteArray), poolSocket, typeof(QByteArray), appSocket);
		}
		/// <remarks>
		///  This function acts like standard write function call
		///  except it is also capable of making SSL or SOCKS
		///  connections.
		/// <param> name="data" info to be sent to remote machine
		/// </param><param> name="len" the length of the data to be sent
		/// </param></remarks>		<return> the actual size of the data that was sent
		///      </return>
		/// 		<short>    This function acts like standard write function call  except it is also capable of making SSL or SOCKS  connections.</short>
		protected int Write(string data, int len) {
			return (int) interceptor.Invoke("write$?", "write(const char*, ssize_t)", typeof(int), typeof(string), data, typeof(int), len);
		}
		/// <remarks>
		///  This function acts like standard read function call
		///  except it is also capable of deciphering SSL data as
		///  well as handling data over SOCKSified connections.
		/// <param> name="data" storage for the info read from server
		/// </param><param> name="len" length of the info to read from the server
		/// </param></remarks>		<return> the actual size of data that was obtained
		///      </return>
		/// 		<short>    This function acts like standard read function call  except it is also capable of deciphering SSL data as  well as handling data over SOCKSified connections.</short>
		protected int Read(string data, int len) {
			return (int) interceptor.Invoke("read$?", "read(char*, ssize_t)", typeof(int), typeof(string), data, typeof(int), len);
		}
		/// <remarks>
		///  Same as above except it reads data one line at a time.
		///      </remarks>		<short>    Same as above except it reads data one line at a time.</short>
		protected int ReadLine(string data, int len) {
			return (int) interceptor.Invoke("readLine$?", "readLine(char*, ssize_t)", typeof(int), typeof(string), data, typeof(int), len);
		}
		/// <remarks>
		///  Sets the maximum size of blocks read in during calls to readLine().
		///  This allows a slave to optimize for the protocol which it implements.
		///  Ideally this should be (common_line_length+1) or so.
		///  Making this too large will have adverse effects on performance.
		///  Initial/default value is 256(bytes)
		///      </remarks>		<short>    Sets the maximum size of blocks read in during calls to readLine().</short>
		protected void SetBlockSize(int sz) {
			interceptor.Invoke("setBlockSize$", "setBlockSize(int)", typeof(void), typeof(int), sz);
		}
		/// <remarks>
		///  Performs the initial TCP connection stuff and/or
		///  SSL handshaking as necessary.
		///  Please note that unlike its deprecated counterpart, this
		///  function allows you to disable any error message from being
		///  sent back to the calling application!  You can then use the
		///  connectResult() function to determine the result of the
		///  request for connection.
		/// <param> name="protocol" the protocol being used
		/// </param><param> name="host" hostname
		/// </param><param> name="port" port number
		/// </param><param> name="sendError" if true sends error message to calling app.
		/// </param></remarks>		<return> on succes, true is returned.
		///          on failure, false is returned and an appropriate
		///          error message is send to the application.
		///      </return>
		/// 		<short>    Performs the initial TCP connection stuff and/or  SSL handshaking as necessary.</short>
		protected bool ConnectToHost(string protocol, string host, ushort port, bool sendError) {
			return (bool) interceptor.Invoke("connectToHost$$$$", "connectToHost(const QString&, const QString&, quint16, bool)", typeof(bool), typeof(string), protocol, typeof(string), host, typeof(ushort), port, typeof(bool), sendError);
		}
		protected bool ConnectToHost(string protocol, string host, ushort port) {
			return (bool) interceptor.Invoke("connectToHost$$$", "connectToHost(const QString&, const QString&, quint16)", typeof(bool), typeof(string), protocol, typeof(string), host, typeof(ushort), port);
		}
		/// <remarks>
		///  set the default port for this service
		///      </remarks>		<short>    set the default port for this service </short>
		protected void SetDefaultPort(ushort port) {
			interceptor.Invoke("setDefaultPort$", "setDefaultPort(quint16)", typeof(void), typeof(ushort), port);
		}
		/// <remarks>
		///  the current default port for this service
		///      </remarks>		<short>    the current default port for this service </short>
		protected ushort DefaultPort() {
			return (ushort) interceptor.Invoke("defaultPort", "defaultPort() const", typeof(ushort));
		}
		/// <remarks>
		///  the current port for this service
		///      </remarks>		<short>    the current port for this service </short>
		protected ushort Port() {
			return (ushort) interceptor.Invoke("port", "port() const", typeof(ushort));
		}
		/// <remarks>
		///  Are we using SSL?
		/// </remarks>		<return> if so, true is returned.
		///          if not, true isn't returned.
		///      </return>
		/// 		<short>    Are we using SSL? </short>
		protected bool UsingSSL() {
			return (bool) interceptor.Invoke("usingSSL", "usingSSL() const", typeof(bool));
		}
		/// <remarks>
		///  Are we using TLS?
		/// </remarks>		<return> if so, true is returned.
		///          if not, true isn't returned.
		///      </return>
		/// 		<short>    Are we using TLS? </short>
		protected bool UsingTLS() {
			return (bool) interceptor.Invoke("usingTLS", "usingTLS() const", typeof(bool));
		}
		/// <remarks>
		///  Can we use TLS?
		/// </remarks>		<return> if so, true is returned.
		///          if not, true isn't returned.
		///      </return>
		/// 		<short>    Can we use TLS? </short>
		protected bool CanUseTLS() {
			return (bool) interceptor.Invoke("canUseTLS", "canUseTLS() const", typeof(bool));
		}
		/// <remarks>
		///  Start using TLS on the connection.
		/// </remarks>		<return> on success, 1 is returned.
		///          on failure, 0 is returned.
		///          on TLS init failure, -1 is returned.
		///          on connect failure, -2 is returned.
		///          on certificate failure, -3 is returned.
		///      </return>
		/// 		<short>    Start using TLS on the connection.</short>
		protected int StartTLS() {
			return (int) interceptor.Invoke("startTLS", "startTLS()", typeof(int));
		}
		/// <remarks>
		///  Stop using TLS on the connection.
		///      </remarks>		<short>    Stop using TLS on the connection.</short>
		protected void StopTLS() {
			interceptor.Invoke("stopTLS", "stopTLS()", typeof(void));
		}
		/// <remarks>
		///  Closes the current file descriptor.
		///  Call this function to properly close up the socket
		///  since it also takes care to prroperly close the stdio
		///  fstream stuff, as well as sets the socket back to -1
		///      </remarks>		<short>    Closes the current file descriptor.</short>
		protected void CloseDescriptor() {
			interceptor.Invoke("closeDescriptor", "closeDescriptor()", typeof(void));
		}
		/// <remarks>
		///  Returns true when end of data is reached
		///      </remarks>		<short>    Returns true when end of data is reached      </short>
		protected bool AtEnd() {
			return (bool) interceptor.Invoke("atEnd", "atEnd() const", typeof(bool));
		}
		/// <remarks>
		///  Call this if you use persistent connections and want all the
		///  metadata restored.  This is particularly important for SSL
		///  sessions since the app needs to know the state of connection,
		///  certificates, etc.
		///      </remarks>		<short>    Call this if you use persistent connections and want all the  metadata restored.</short>
		protected void SetSSLMetaData() {
			interceptor.Invoke("setSSLMetaData", "setSSLMetaData()", typeof(void));
		}
		/// <remarks>
		///  Initializs all SSL variables
		///      </remarks>		<short>    Initializs all SSL variables      </short>
		protected bool InitializeSSL() {
			return (bool) interceptor.Invoke("initializeSSL", "initializeSSL()", typeof(bool));
		}
		/// <remarks>
		///  Cleans up all SSL settings.
		///      </remarks>		<short>    Cleans up all SSL settings.</short>
		protected void CleanSSL() {
			interceptor.Invoke("cleanSSL", "cleanSSL()", typeof(void));
		}
		/// <remarks>
		///  Determines whether or not we are still connected
		///  to the remote machine.
		///  This method may fail to detect a closed SSL connection.
		///  return <code>true</code> if the socket is still active or
		///            false otherwise.
		///      </remarks>		<short>    Determines whether or not we are still connected  to the remote machine.</short>
		protected bool IsConnectionValid() {
			return (bool) interceptor.Invoke("isConnectionValid", "isConnectionValid()", typeof(bool));
		}
		/// <remarks>
		///  Returns the status of the connection.
		///  This function allows you to invoke ConnectToHost
		///  with the <code>sendError</code> flag set to false so that you
		///  can send the appropriate error message back to the
		///  calling io-slave.
		/// </remarks>		<return> the error code after the connection
		///      </return>
		/// 		<short>    Returns the status of the connection.</short>
		protected int ConnectResult() {
			return (int) interceptor.Invoke("connectResult", "connectResult()", typeof(int));
		}
		/// <remarks>
		///  Wait for some type of activity on the socket
		///  for the period specified by <code>t.</code>
		/// <param> name="t" length of time in seconds that we should monitor the
		///            socket before timing out.
		/// </param></remarks>		<return> true if any activity was seen on the socket before the
		///               timeout value was reached, false otherwise.
		///      </return>
		/// 		<short>    Wait for some type of activity on the socket  for the period specified by <code>t.</code></short>
		protected bool WaitForResponse(int t) {
			return (bool) interceptor.Invoke("waitForResponse$", "waitForResponse(int)", typeof(bool), typeof(int), t);
		}
		/// <remarks>
		///  Sets the mode of the connection to blocking or non-blocking.
		///  Be sure to call this function before calling connectToHost.
		///  Otherwise, this setting will not have any effect until the next
		///  <code>connectToHost.</code>
		/// <param> name="b" true to make the connection a blocking one, false otherwise.
		///      </param></remarks>		<short>    Sets the mode of the connection to blocking or non-blocking.</short>
		protected void SetBlockConnection(bool b) {
			interceptor.Invoke("setBlockConnection$", "setBlockConnection(bool)", typeof(void), typeof(bool), b);
		}
		/// <remarks>
		///  Sets how long to wait for orignally connecting to
		///  the requested before timinig out.
		///  Be sure to call this function before calling ConnectToHost,
		///  otherwise the setting will not take effect until the next call
		///  to <code>ConnectToHost.</code>
		/// <param> name="t" timeout value
		///      </param></remarks>		<short>    Sets how long to wait for orignally connecting to  the requested before timinig out.</short>
		protected void SetConnectTimeout(int t) {
			interceptor.Invoke("setConnectTimeout$", "setConnectTimeout(int)", typeof(void), typeof(int), t);
		}
		/// <remarks>
		///  Returns true if SSL tunneling is enabled.
		/// </remarks>		<short>    Returns true if SSL tunneling is enabled.</short>
		/// 		<see> setEnableSSlTunnel</see>
		protected bool IsSSLTunnelEnabled() {
			return (bool) interceptor.Invoke("isSSLTunnelEnabled", "isSSLTunnelEnabled() const", typeof(bool));
		}
		/// <remarks>
		///  Set up SSL tunneling mode.
		///  Calling this function with a <code>true</code> argument will allow
		///  you to temprarly ignore the <code>m_bIsSSL</code> flag setting and
		///  make a non-SSL connection.  It is mostly useful for making
		///  connections to SSL sites through a non-transparent proxy
		///  server (i.e. most proxy servers out there).
		///  Note that once you have successfully "tunneled" through the
		///  proxy server you must call this function with its argument
		///  set to false to properly connect to the SSL site.
		/// <param> name="enable" if true SSL Tunneling will be enabled
		///      </param></remarks>		<short>    Set up SSL tunneling mode.</short>
		protected void SetEnableSSLTunnel(bool enable) {
			interceptor.Invoke("setEnableSSLTunnel$", "setEnableSSLTunnel(bool)", typeof(void), typeof(bool), enable);
		}
		/// <remarks>
		///  Sets up the the real hostname for an SSL connection
		///  that goes through a proxy server.
		///  This function is essential in making sure that the
		///  real hostname is used for validating certificates from
		///  SSL sites!
		/// <param> name="realHost" the actual host name we are connecting to
		///      </param></remarks>		<short>    Sets up the the real hostname for an SSL connection  that goes through a proxy server.</short>
		protected void SetRealHost(string realHost) {
			interceptor.Invoke("setRealHost$", "setRealHost(const QString&)", typeof(void), typeof(string), realHost);
		}
		protected int VerifyCertificate() {
			return (int) interceptor.Invoke("verifyCertificate", "verifyCertificate()", typeof(int));
		}
		protected void CertificatePrompt() {
			interceptor.Invoke("certificatePrompt", "certificatePrompt()", typeof(void));
		}
		protected bool UserAborted() {
			return (bool) interceptor.Invoke("userAborted", "userAborted() const", typeof(bool));
		}
		/// <remarks>
		///  Return the socket object, if the class ever needs to do anything to it
		///      </remarks>		<short>    Return the socket object, if the class ever needs to do anything to it      </short>
		protected QIODevice Socket() {
			return (QIODevice) interceptor.Invoke("socket", "socket() const", typeof(QIODevice));
		}
	}
	}
}
