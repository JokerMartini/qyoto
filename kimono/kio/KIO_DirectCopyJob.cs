//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	namespace KIO {

	using System;
	using Qyoto;

	/// <remarks>
	///  Used for direct copy from or to the local filesystem (i.e. SlaveBase.Copy())
	///       See <see cref="IDirectCopyJobSignals"></see> for signals emitted by DirectCopyJob
	/// </remarks>		<short>   </short>

	[SmokeClass("KIO::DirectCopyJob")]
	public class DirectCopyJob : KIO.SimpleJob {
 		protected DirectCopyJob(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(DirectCopyJob), this);
		}
		/// <remarks>
		///  Do not create a DirectCopyJob. Use KIO.Copy() or KIO.File_copy() instead.
		///          </remarks>		<short>    Do not create a DirectCopyJob.</short>
		public DirectCopyJob(KUrl url, int command, QByteArray packedArgs) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("DirectCopyJob#$#", "DirectCopyJob(const KUrl&, int, const QByteArray&)", typeof(void), typeof(KUrl), url, typeof(int), command, typeof(QByteArray), packedArgs);
		}
		/// <remarks>
		///  Called by the scheduler when a <code>slave</code> gets to
		///  work on this job.
		/// <param> name="slave" the slave that starts working on this job
		///          </param></remarks>		<short>   </short>
		[SmokeMethod("start(KIO::Slave*)")]
		public override void Start(KIO.Slave slave) {
			interceptor.Invoke("start#", "start(KIO::Slave*)", typeof(void), typeof(KIO.Slave), slave);
		}
		protected new IDirectCopyJobSignals Emit {
			get { return (IDirectCopyJobSignals) Q_EMIT; }
		}
	}

	public interface IDirectCopyJobSignals : KIO.ISimpleJobSignals {
		/// <remarks>
		///  Emitted if the job found an existing partial file
		///  and supports resuming. Used by FileCopyJob.
		///          </remarks>		<short>   </short>
		[Q_SIGNAL("void canResume(KIO::Job*, KIO::filesize_t)")]
		void CanResume(KIO.Job job, long offset);
	}
	}
}
