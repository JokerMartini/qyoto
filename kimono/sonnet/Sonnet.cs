//Auto-generated by kalyptus. DO NOT EDIT.
namespace Kimono {

	using System;
	using Qyoto;
	using System.Collections.Generic;

	/// <remarks>
	///  configdialog.h
	///  Copyright (C)  2004  Zack Rusin <zack@kde.org>
	///  This library is free software; you can redistribute it and/or
	///  modify it under the terms of the GNU Lesser General Public
	///  License as published by the Free Software Foundation; either
	///  version 2.1 of the License, or (at your option) any later version.
	///  This library is distributed in the hope that it will be useful,
	///  but WITHOUT ANY WARRANTY; without even the implied warranty of
	///  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	///  Lesser General Public License for more details.
	///  You should have received a copy of the GNU Lesser General Public
	///  License along with this library; if not, write to the Free Software
	///  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
	///  02110-1301  USA
	///  </remarks>		<short>    configdialog.</short>

	[SmokeClass("Sonnet")]
	public class Sonnet : Object {
		protected SmokeInvocation interceptor = null;

		/// <remarks>
		///  Spell checker object.
		/// </remarks>		<short> class used for actuall spell checking.</short>

		[SmokeClass("Sonnet::Speller")]
		public class Speller : Object, IDisposable {
			protected SmokeInvocation interceptor = null;
			private IntPtr smokeObject;
			protected Speller(Type dummy) {}
			protected void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(Speller), this);
			}
			// void setAttribute(Sonnet::Speller::Attribute arg1,bool arg2); >>>> NOT CONVERTED
			// void setAttribute(Sonnet::Speller::Attribute arg1); >>>> NOT CONVERTED
			// bool testAttribute(Sonnet::Speller::Attribute arg1); >>>> NOT CONVERTED
			public Speller(string lang) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Speller$", "Speller(const QString&)", typeof(void), typeof(string), lang);
			}
			public Speller() : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Speller", "Speller()", typeof(void));
			}
			public Speller(Sonnet.Speller speller) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Speller#", "Speller(const Sonnet::Speller&)", typeof(void), typeof(Sonnet.Speller), speller);
			}
			/// <remarks>
			///  Returns true is the speller supports currently selected
			///  language.
			///          </remarks>		<short>    Returns true is the speller supports currently selected  language.</short>
			public bool IsValid() {
				return (bool) interceptor.Invoke("isValid", "isValid() const", typeof(bool));
			}
			/// <remarks>
			///  Sets the language supported by this speller.
			///          </remarks>		<short>    Sets the language supported by this speller.</short>
			public void SetLanguage(string lang) {
				interceptor.Invoke("setLanguage$", "setLanguage(const QString&)", typeof(void), typeof(string), lang);
			}
			/// <remarks>
			///  Returns language supported by this speller.
			///          </remarks>		<short>    Returns language supported by this speller.</short>
			public string Language() {
				return (string) interceptor.Invoke("language", "language() const", typeof(string));
			}
			/// <remarks>
			///  Checks the given word.
			/// </remarks>		<return> false if the word is misspelled. true otherwise
			///          </return>
			/// 		<short>    Checks the given word.</short>
			public bool IsCorrect(string word) {
				return (bool) interceptor.Invoke("isCorrect$", "isCorrect(const QString&) const", typeof(bool), typeof(string), word);
			}
			/// <remarks>
			///  Checks the given word.
			/// </remarks>		<return> true if the word is misspelled. false otherwise
			///          </return>
			/// 		<short>    Checks the given word.</short>
			public bool IsMisspelled(string word) {
				return (bool) interceptor.Invoke("isMisspelled$", "isMisspelled(const QString&) const", typeof(bool), typeof(string), word);
			}
			/// <remarks>
			///  Fetches suggestions for the word.
			/// </remarks>		<return> list of all suggestions for the word
			///          </return>
			/// 		<short>    Fetches suggestions for the word.</short>
			public List<string> Suggest(string word) {
				return (List<string>) interceptor.Invoke("suggest$", "suggest(const QString&) const", typeof(List<string>), typeof(string), word);
			}
			/// <remarks>
			///  Convience method calling isCorrect() and suggest()
			///  if the word isn't correct.
			///          </remarks>		<short>    Convience method calling isCorrect() and suggest()  if the word isn't correct.</short>
			public bool CheckAndSuggest(string word, List<string> suggestions) {
				return (bool) interceptor.Invoke("checkAndSuggest$?", "checkAndSuggest(const QString&, QStringList&) const", typeof(bool), typeof(string), word, typeof(List<string>), suggestions);
			}
			/// <remarks>
			///  Stores user defined good replacement for the bad word.
			/// </remarks>		<return> true on success
			///          </return>
			/// 		<short>    Stores user defined good replacement for the bad word.</short>
			public bool StoreReplacement(string bad, string good) {
				return (bool) interceptor.Invoke("storeReplacement$$", "storeReplacement(const QString&, const QString&)", typeof(bool), typeof(string), bad, typeof(string), good);
			}
			/// <remarks>
			///  Adds word to the list of of personal words.
			/// </remarks>		<return> true on success
			///          </return>
			/// 		<short>    Adds word to the list of of personal words.</short>
			public bool AddToPersonal(string word) {
				return (bool) interceptor.Invoke("addToPersonal$", "addToPersonal(const QString&)", typeof(bool), typeof(string), word);
			}
			/// <remarks>
			///  Adds word to the words recognizable in the current session.
			/// </remarks>		<return> true on success
			///          </return>
			/// 		<short>    Adds word to the words recognizable in the current session.</short>
			public bool AddToSession(string word) {
				return (bool) interceptor.Invoke("addToSession$", "addToSession(const QString&)", typeof(bool), typeof(string), word);
			}
			public void Save(KConfig config) {
				interceptor.Invoke("save#", "save(KConfig*)", typeof(void), typeof(KConfig), config);
			}
			public void Restore(KConfig config) {
				interceptor.Invoke("restore#", "restore(KConfig*)", typeof(void), typeof(KConfig), config);
			}
			/// <remarks>
			///  Returns names of all supported backends (e.g. ISpell, ASpell)
			///          </remarks>		<short>    Returns names of all supported backends (e.</short>
			public List<string> AvailableBackends() {
				return (List<string>) interceptor.Invoke("availableBackends", "availableBackends() const", typeof(List<string>));
			}
			/// <remarks>
			///  Returns a list of supported languages.
			///          </remarks>		<short>    Returns a list of supported languages.</short>
			public List<string> AvailableLanguages() {
				return (List<string>) interceptor.Invoke("availableLanguages", "availableLanguages() const", typeof(List<string>));
			}
			/// <remarks>
			///  Returns a localized list of names of supported languages.
			///          </remarks>		<short>    Returns a localized list of names of supported languages.</short>
			public List<string> AvailableLanguageNames() {
				return (List<string>) interceptor.Invoke("availableLanguageNames", "availableLanguageNames() const", typeof(List<string>));
			}
			public void SetDefaultLanguage(string lang) {
				interceptor.Invoke("setDefaultLanguage$", "setDefaultLanguage(const QString&)", typeof(void), typeof(string), lang);
			}
			public string DefaultLanguage() {
				return (string) interceptor.Invoke("defaultLanguage", "defaultLanguage() const", typeof(string));
			}
			public void SetDefaultClient(string client) {
				interceptor.Invoke("setDefaultClient$", "setDefaultClient(const QString&)", typeof(void), typeof(string), client);
			}
			public string DefaultClient() {
				return (string) interceptor.Invoke("defaultClient", "defaultClient() const", typeof(string));
			}
			~Speller() {
				interceptor.Invoke("~Speller", "~Speller()", typeof(void));
			}
			public void Dispose() {
				interceptor.Invoke("~Speller", "~Speller()", typeof(void));
			}
		}

		/// <remarks>
		///  BackgroundChecker is used to perform spell checking without
		///  blocking the application. You can use it as is by calling
		///  the checkText function or subclass it and reimplement
		///  getMoreText function.
		///  The misspelling signal is emitted whenever a misspelled word
		///  is found. The background checker stops right before emitting
		///  the signal. So the parent has to call continueChecking function
		///  to resume the checking.
		///  done signal is emitted when whole text is spell checked.
		///  See <see cref="IBackgroundCheckerSignals"></see> for signals emitted by BackgroundChecker
		/// </remarks>		<author> Zack Rusin <zack@kde.org>
		/// </author>
		/// 		<short> class used for spell checking in the background.</short>

		[SmokeClass("Sonnet::BackgroundChecker")]
		public class BackgroundChecker : QObject, IDisposable {
	 		protected BackgroundChecker(Type dummy) : base((Type) null) {}
			protected new void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(BackgroundChecker), this);
			}
			public BackgroundChecker(QObject parent) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("BackgroundChecker#", "BackgroundChecker(QObject*)", typeof(void), typeof(QObject), parent);
			}
			public BackgroundChecker() : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("BackgroundChecker", "BackgroundChecker()", typeof(void));
			}
			public BackgroundChecker(Sonnet.Speller speller, QObject parent) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("BackgroundChecker##", "BackgroundChecker(const Sonnet::Speller&, QObject*)", typeof(void), typeof(Sonnet.Speller), speller, typeof(QObject), parent);
			}
			public BackgroundChecker(Sonnet.Speller speller) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("BackgroundChecker#", "BackgroundChecker(const Sonnet::Speller&)", typeof(void), typeof(Sonnet.Speller), speller);
			}
			/// <remarks>
			///  This method is used to spell check static text.
			///  It automatically invokes start().
			///  Use fetchMoreText() with start() to spell check a stream.
			///          </remarks>		<short>    This method is used to spell check static text.</short>
			public void SetText(string text) {
				interceptor.Invoke("setText$", "setText(const QString&)", typeof(void), typeof(string), text);
			}
			public string Text() {
				return (string) interceptor.Invoke("text", "text() const", typeof(string));
			}
			public string CurrentContext() {
				return (string) interceptor.Invoke("currentContext", "currentContext() const", typeof(string));
			}
			public Sonnet.Speller Speller() {
				return (Sonnet.Speller) interceptor.Invoke("speller", "speller() const", typeof(Sonnet.Speller));
			}
			public void SetSpeller(Sonnet.Speller speller) {
				interceptor.Invoke("setSpeller#", "setSpeller(const Sonnet::Speller&)", typeof(void), typeof(Sonnet.Speller), speller);
			}
			public void ChangeLanguage(string lang) {
				interceptor.Invoke("changeLanguage$", "changeLanguage(const QString&)", typeof(void), typeof(string), lang);
			}
			public bool CheckWord(string word) {
				return (bool) interceptor.Invoke("checkWord$", "checkWord(const QString&)", typeof(bool), typeof(string), word);
			}
			public List<string> Suggest(string word) {
				return (List<string>) interceptor.Invoke("suggest$", "suggest(const QString&) const", typeof(List<string>), typeof(string), word);
			}
			public bool AddWordToPersonal(string word) {
				return (bool) interceptor.Invoke("addWordToPersonal$", "addWordToPersonal(const QString&)", typeof(bool), typeof(string), word);
			}
			[Q_SLOT("void start()")]
			[SmokeMethod("start()")]
			public virtual void Start() {
				interceptor.Invoke("start", "start()", typeof(void));
			}
			[Q_SLOT("void stop()")]
			[SmokeMethod("stop()")]
			public virtual void Stop() {
				interceptor.Invoke("stop", "stop()", typeof(void));
			}
			[Q_SLOT("void replace(int, const QString&, const QString&)")]
			public void Replace(int start, string oldText, string newText) {
				interceptor.Invoke("replace$$$", "replace(int, const QString&, const QString&)", typeof(void), typeof(int), start, typeof(string), oldText, typeof(string), newText);
			}
			/// <remarks>
			///  After emitting misspelling signal the background
			///  checker stops. The catcher is responsible for calling
			///  continueChecking function to resume checking.
			///          </remarks>		<short>    After emitting misspelling signal the background  checker stops.</short>
			[Q_SLOT("void continueChecking()")]
			[SmokeMethod("continueChecking()")]
			public virtual void ContinueChecking() {
				interceptor.Invoke("continueChecking", "continueChecking()", typeof(void));
			}
			/// <remarks>
			///  This function is called to get the text to spell check.
			///  It will be called continuesly until it returns string()
			///  in which case the done() signal is emitted.
			///  Note: the start parameter in mispelling() is not a combined
			///  position but a position in the last string returned
			///  by fetchMoreText. You need to store the state in the derivatives.
			///          </remarks>		<short>    This function is called to get the text to spell check.</short>
			[SmokeMethod("fetchMoreText()")]
			protected virtual string FetchMoreText() {
				return (string) interceptor.Invoke("fetchMoreText", "fetchMoreText()", typeof(string));
			}
			/// <remarks>
			///  This function will be called whenever the background checker
			///  will be finished text which it got from fetchMoreText.
			///          </remarks>		<short>    This function will be called whenever the background checker  will be finished text which it got from fetchMoreText.</short>
			[SmokeMethod("finishedCurrentFeed()")]
			protected virtual void FinishedCurrentFeed() {
				interceptor.Invoke("finishedCurrentFeed", "finishedCurrentFeed()", typeof(void));
			}
			[Q_SLOT("void slotEngineDone()")]
			protected void SlotEngineDone() {
				interceptor.Invoke("slotEngineDone", "slotEngineDone()", typeof(void));
			}
			~BackgroundChecker() {
				interceptor.Invoke("~BackgroundChecker", "~BackgroundChecker()", typeof(void));
			}
			public new void Dispose() {
				interceptor.Invoke("~BackgroundChecker", "~BackgroundChecker()", typeof(void));
			}
			protected new IBackgroundCheckerSignals Emit {
				get { return (IBackgroundCheckerSignals) Q_EMIT; }
			}
		}

		public interface IBackgroundCheckerSignals : IQObjectSignals {
		/// <remarks>
		///  Emitted whenever a misspelled word is found
		///          </remarks>		<short>    Emitted whenever a misspelled word is found          </short>
		[Q_SIGNAL("void misspelling(const QString&, int)")]
		void Misspelling(string word, int start);
		/// <remarks>
		///  Emitted after the whole text has been spell checked.
		///          </remarks>		<short>    Emitted after the whole text has been spell checked.</short>
		[Q_SIGNAL("void done()")]
		void Done();
		}

		/// <remarks>
		///  <pre>
		///  Sonnet.Dialog = dlg=new Sonnet.Dialog(new Sonnet.BackgroundChecker(
		///           this), this);
		///  //connect signals
		///  ...
		///  dlg.SetBuffer( someText );
		///  dlg.Show();
		///  </pre>
		///       See <see cref="IDialogSignals"></see> for signals emitted by Dialog
		/// </remarks>		<short> Spellcheck dialog.</short>

		[SmokeClass("Sonnet::Dialog")]
		public class Dialog : KDialog, IDisposable {
	 		protected Dialog(Type dummy) : base((Type) null) {}
			protected new void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(Dialog), this);
			}
			public Dialog(Sonnet.BackgroundChecker checker, QWidget parent) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Dialog##", "Dialog(Sonnet::BackgroundChecker*, QWidget*)", typeof(void), typeof(Sonnet.BackgroundChecker), checker, typeof(QWidget), parent);
			}
			public string OriginalBuffer() {
				return (string) interceptor.Invoke("originalBuffer", "originalBuffer() const", typeof(string));
			}
			public string Buffer() {
				return (string) interceptor.Invoke("buffer", "buffer() const", typeof(string));
			}
			public new void Show() {
				interceptor.Invoke("show", "show()", typeof(void));
			}
			public void ActiveAutoCorrect(bool _active) {
				interceptor.Invoke("activeAutoCorrect$", "activeAutoCorrect(bool)", typeof(void), typeof(bool), _active);
			}
			[Q_SLOT("void setBuffer(const QString&)")]
			public void SetBuffer(string arg1) {
				interceptor.Invoke("setBuffer$", "setBuffer(const QString&)", typeof(void), typeof(string), arg1);
			}
			~Dialog() {
				interceptor.Invoke("~Dialog", "~Dialog()", typeof(void));
			}
			public new void Dispose() {
				interceptor.Invoke("~Dialog", "~Dialog()", typeof(void));
			}
			protected new IDialogSignals Emit {
				get { return (IDialogSignals) Q_EMIT; }
			}
		}

		public interface IDialogSignals : IKDialogSignals {
		/// <remarks>
		///  The dialog won't be closed if you setBuffer() in slot connected to this signal
		///  Also emitted after stop() signal
		///          </remarks>		<short>    The dialog won't be closed if you setBuffer() in slot connected to this signal </short>
		[Q_SIGNAL("void done(const QString&)")]
		void Done(string newBuffer);
		[Q_SIGNAL("void misspelling(const QString&, int)")]
		void Misspelling(string word, int start);
		[Q_SIGNAL("void replace(const QString&, int, const QString&)")]
		void Replace(string oldWord, int start, string newWord);
		[Q_SIGNAL("void stop()")]
		void Stop();
		[Q_SIGNAL("void cancel()")]
		void Cancel();
		[Q_SIGNAL("void autoCorrect(const QString&, const QString&)")]
		void AutoCorrect(string currentWord, string replaceWord);
		}

		/// <remarks> See <see cref="IHighlighterSignals"></see> for signals emitted by Highlighter
		/// </remarks>

		[SmokeClass("Sonnet::Highlighter")]
		public class Highlighter : QSyntaxHighlighter, IDisposable {
	 		protected Highlighter(Type dummy) : base((Type) null) {}
			protected new void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(Highlighter), this);
			}
			private static SmokeInvocation staticInterceptor = null;
			static Highlighter() {
				staticInterceptor = new SmokeInvocation(typeof(Highlighter), null);
			}
			public Highlighter(QTextEdit textEdit, string configFile, QColor col) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Highlighter#$#", "Highlighter(QTextEdit*, const QString&, const QColor&)", typeof(void), typeof(QTextEdit), textEdit, typeof(string), configFile, typeof(QColor), col);
			}
			public Highlighter(QTextEdit textEdit, string configFile) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Highlighter#$", "Highlighter(QTextEdit*, const QString&)", typeof(void), typeof(QTextEdit), textEdit, typeof(string), configFile);
			}
			public Highlighter(QTextEdit textEdit) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("Highlighter#", "Highlighter(QTextEdit*)", typeof(void), typeof(QTextEdit), textEdit);
			}
			public bool SpellCheckerFound() {
				return (bool) interceptor.Invoke("spellCheckerFound", "spellCheckerFound() const", typeof(bool));
			}
			public string CurrentLanguage() {
				return (string) interceptor.Invoke("currentLanguage", "currentLanguage() const", typeof(string));
			}
			public void SetCurrentLanguage(string lang) {
				interceptor.Invoke("setCurrentLanguage$", "setCurrentLanguage(const QString&)", typeof(void), typeof(string), lang);
			}
			/// <remarks>
			///  If <code>active</code> is true then spell checking is enabled; otherwise it
			///  is disabled. Note that you have to disable automatic (de)activation
			///  with <see cref="#setAutomatic"></see> before you change the state of spell
			///  checking if you want to persistently enable/disable spell
			///  checking.
			/// <param> name="active" if true, then spell checking is enabled
			/// </param></remarks>		<short> Enable/Disable spell checking. </short>
			/// 		<see> isActive</see>
			/// 		<see> setAutomatic</see>
			public void SetActive(bool active) {
				interceptor.Invoke("setActive$", "setActive(bool)", typeof(void), typeof(bool), active);
			}
			/// <remarks>
			///  Returns the state of spell checking.
			/// </remarks>		<return> true if spell checking is active
			/// </return>
			/// 		<short>    Returns the state of spell checking.</short>
			/// 		<see> setActive</see>
			public bool IsActive() {
				return (bool) interceptor.Invoke("isActive", "isActive() const", typeof(bool));
			}
			public bool Automatic() {
				return (bool) interceptor.Invoke("automatic", "automatic() const", typeof(bool));
			}
			public void SetAutomatic(bool automatic) {
				interceptor.Invoke("setAutomatic$", "setAutomatic(bool)", typeof(void), typeof(bool), automatic);
			}
			[Q_SLOT("void slotAutoDetection()")]
			public void SlotAutoDetection() {
				interceptor.Invoke("slotAutoDetection", "slotAutoDetection()", typeof(void));
			}
			[Q_SLOT("void slotRehighlight()")]
			public void SlotRehighlight() {
				interceptor.Invoke("slotRehighlight", "slotRehighlight()", typeof(void));
			}
			[SmokeMethod("highlightBlock(const QString&)")]
			protected override void HighlightBlock(string text) {
				interceptor.Invoke("highlightBlock$", "highlightBlock(const QString&)", typeof(void), typeof(string), text);
			}
			[SmokeMethod("setMisspelled(int, int)")]
			protected virtual void SetMisspelled(int start, int count) {
				interceptor.Invoke("setMisspelled$$", "setMisspelled(int, int)", typeof(void), typeof(int), start, typeof(int), count);
			}
			[SmokeMethod("unsetMisspelled(int, int)")]
			protected virtual void UnsetMisspelled(int start, int count) {
				interceptor.Invoke("unsetMisspelled$$", "unsetMisspelled(int, int)", typeof(void), typeof(int), start, typeof(int), count);
			}
			[SmokeMethod("eventFilter(QObject*, QEvent*)")]
			protected new virtual bool EventFilter(QObject o, QEvent e) {
				return (bool) interceptor.Invoke("eventFilter##", "eventFilter(QObject*, QEvent*)", typeof(bool), typeof(QObject), o, typeof(QEvent), e);
			}
			protected bool IntraWordEditing() {
				return (bool) interceptor.Invoke("intraWordEditing", "intraWordEditing() const", typeof(bool));
			}
			protected void SetIntraWordEditing(bool editing) {
				interceptor.Invoke("setIntraWordEditing$", "setIntraWordEditing(bool)", typeof(void), typeof(bool), editing);
			}
			~Highlighter() {
				interceptor.Invoke("~Highlighter", "~Highlighter()", typeof(void));
			}
			public new void Dispose() {
				interceptor.Invoke("~Highlighter", "~Highlighter()", typeof(void));
			}
			public static List<string> PersonalWords() {
				return (List<string>) staticInterceptor.Invoke("personalWords", "personalWords()", typeof(List<string>));
			}
			protected new IHighlighterSignals Emit {
				get { return (IHighlighterSignals) Q_EMIT; }
			}
		}

		public interface IHighlighterSignals : IQSyntaxHighlighterSignals {
		/// <remarks>
		///  Emitted when as-you-type spell checking is enabled or disabled.
		/// <param> name="description" is a i18n description of the new state,
		///         with an optional reason
		/// 	 </param></remarks>		<short>    Emitted when as-you-type spell checking is enabled or disabled.</short>
		[Q_SIGNAL("void activeChanged(const QString&)")]
		void ActiveChanged(string description);
		/// <remarks>
		/// <param> name="originalWord" missspelled word
		/// </param><param> name="suggestions" list of word which can replace missspelled word
		/// 	 </param></remarks>		<short>   </short>
		[Q_SIGNAL("void newSuggestions(const QString&, const QStringList&)")]
		void NewSuggestions(string originalWord, List<string> suggestions);
		}


		[SmokeClass("Sonnet::ConfigDialog")]
		public class ConfigDialog : KDialog, IDisposable {
	 		protected ConfigDialog(Type dummy) : base((Type) null) {}
			protected new void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(ConfigDialog), this);
			}
			public ConfigDialog(KConfig config, QWidget parent) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("ConfigDialog##", "ConfigDialog(KConfig*, QWidget*)", typeof(void), typeof(KConfig), config, typeof(QWidget), parent);
			}
			[Q_SLOT("void slotOk()")]
			[SmokeMethod("slotOk()")]
			protected virtual void SlotOk() {
				interceptor.Invoke("slotOk", "slotOk()", typeof(void));
			}
			[Q_SLOT("void slotApply()")]
			[SmokeMethod("slotApply()")]
			protected virtual void SlotApply() {
				interceptor.Invoke("slotApply", "slotApply()", typeof(void));
			}
			~ConfigDialog() {
				interceptor.Invoke("~ConfigDialog", "~ConfigDialog()", typeof(void));
			}
			public new void Dispose() {
				interceptor.Invoke("~ConfigDialog", "~ConfigDialog()", typeof(void));
			}
			protected new IConfigDialogSignals Emit {
				get { return (IConfigDialogSignals) Q_EMIT; }
			}
		}

		public interface IConfigDialogSignals : IKDialogSignals {
		}


		[SmokeClass("Sonnet::ConfigWidget")]
		public class ConfigWidget : QWidget, IDisposable {
	 		protected ConfigWidget(Type dummy) : base((Type) null) {}
			protected new void CreateProxy() {
				interceptor = new SmokeInvocation(typeof(ConfigWidget), this);
			}
			public ConfigWidget(KConfig config, QWidget parent) : this((Type) null) {
				CreateProxy();
				interceptor.Invoke("ConfigWidget##", "ConfigWidget(KConfig*, QWidget*)", typeof(void), typeof(KConfig), config, typeof(QWidget), parent);
			}
			public bool BackgroundCheckingButtonShown() {
				return (bool) interceptor.Invoke("backgroundCheckingButtonShown", "backgroundCheckingButtonShown() const", typeof(bool));
			}
			[Q_SLOT("void save()")]
			public void Save() {
				interceptor.Invoke("save", "save()", typeof(void));
			}
			[Q_SLOT("void setBackgroundCheckingButtonShown(bool)")]
			public void SetBackgroundCheckingButtonShown(bool arg1) {
				interceptor.Invoke("setBackgroundCheckingButtonShown$", "setBackgroundCheckingButtonShown(bool)", typeof(void), typeof(bool), arg1);
			}
			[Q_SLOT("void slotDefault()")]
			public void SlotDefault() {
				interceptor.Invoke("slotDefault", "slotDefault()", typeof(void));
			}
			[Q_SLOT("void slotChanged()")]
			protected void SlotChanged() {
				interceptor.Invoke("slotChanged", "slotChanged()", typeof(void));
			}
			~ConfigWidget() {
				interceptor.Invoke("~ConfigWidget", "~ConfigWidget()", typeof(void));
			}
			public new void Dispose() {
				interceptor.Invoke("~ConfigWidget", "~ConfigWidget()", typeof(void));
			}
			protected new IConfigWidgetSignals Emit {
				get { return (IConfigWidgetSignals) Q_EMIT; }
			}
		}

		public interface IConfigWidgetSignals : IQWidgetSignals {
		}
	}
}
