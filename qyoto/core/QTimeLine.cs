//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {

	using System;

	/// See <see cref="IQTimeLineSignals"></see> for signals emitted by QTimeLine
	[SmokeClass("QTimeLine")]
	public class QTimeLine : QObject, IDisposable {
 		protected QTimeLine(Type dummy) : base((Type) null) {}
		[SmokeClass("QTimeLine")]
		interface IQTimeLineProxy {
			[SmokeMethod("tr", "(const char*, const char*)", "$$")]
			string Tr(string s, string c);
			[SmokeMethod("tr", "(const char*)", "$")]
			string Tr(string s);
		}
		protected new void CreateProxy() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(QTimeLine), this);
			interceptor = (QTimeLine) realProxy.GetTransparentProxy();
		}
		private static IQTimeLineProxy staticInterceptor = null;
		static QTimeLine() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(IQTimeLineProxy), null);
			staticInterceptor = (IQTimeLineProxy) realProxy.GetTransparentProxy();
		}
		public enum State {
			NotRunning = 0,
			Paused = 1,
			Running = 2,
		}
		public enum Direction {
			Forward = 0,
			Backward = 1,
		}
		public enum CurveShape {
			EaseInCurve = 0,
			EaseOutCurve = 1,
			EaseInOutCurve = 2,
			LinearCurve = 3,
			SineCurve = 4,
		}
		[Q_PROPERTY("int", "duration")]
		public int Duration {
			get { return Property("duration").Value<int>(); }
			set { SetProperty("duration", QVariant.FromValue<int>(value)); }
		}
		[Q_PROPERTY("int", "updateInterval")]
		public int UpdateInterval {
			get { return Property("updateInterval").Value<int>(); }
			set { SetProperty("updateInterval", QVariant.FromValue<int>(value)); }
		}
		[Q_PROPERTY("int", "currentTime")]
		public int CurrentTime {
			get { return Property("currentTime").Value<int>(); }
			set { SetProperty("currentTime", QVariant.FromValue<int>(value)); }
		}
		[Q_PROPERTY("QTimeLine::Direction", "direction")]
		public QTimeLine.Direction direction {
			get { return Property("direction").Value<QTimeLine.Direction>(); }
			set { SetProperty("direction", QVariant.FromValue<QTimeLine.Direction>(value)); }
		}
		[Q_PROPERTY("int", "loopCount")]
		public int LoopCount {
			get { return Property("loopCount").Value<int>(); }
			set { SetProperty("loopCount", QVariant.FromValue<int>(value)); }
		}
		[Q_PROPERTY("QTimeLine::CurveShape", "curveShape")]
		public QTimeLine.CurveShape curveShape {
			get { return Property("curveShape").Value<QTimeLine.CurveShape>(); }
			set { SetProperty("curveShape", QVariant.FromValue<QTimeLine.CurveShape>(value)); }
		}
		public QTimeLine(int duration, QObject parent) : this((Type) null) {
			CreateProxy();
			NewQTimeLine(duration,parent);
		}
		[SmokeMethod("QTimeLine", "(int, QObject*)", "$#")]
		private void NewQTimeLine(int duration, QObject parent) {
			((QTimeLine) interceptor).NewQTimeLine(duration,parent);
		}
		public QTimeLine(int duration) : this((Type) null) {
			CreateProxy();
			NewQTimeLine(duration);
		}
		[SmokeMethod("QTimeLine", "(int)", "$")]
		private void NewQTimeLine(int duration) {
			((QTimeLine) interceptor).NewQTimeLine(duration);
		}
		public QTimeLine() : this((Type) null) {
			CreateProxy();
			NewQTimeLine();
		}
		[SmokeMethod("QTimeLine", "()", "")]
		private void NewQTimeLine() {
			((QTimeLine) interceptor).NewQTimeLine();
		}
		[SmokeMethod("state", "() const", "")]
		public QTimeLine.State state() {
			return ((QTimeLine) interceptor).state();
		}
		[SmokeMethod("startFrame", "() const", "")]
		public int StartFrame() {
			return ((QTimeLine) interceptor).StartFrame();
		}
		[SmokeMethod("setStartFrame", "(int)", "$")]
		public void SetStartFrame(int frame) {
			((QTimeLine) interceptor).SetStartFrame(frame);
		}
		[SmokeMethod("endFrame", "() const", "")]
		public int EndFrame() {
			return ((QTimeLine) interceptor).EndFrame();
		}
		[SmokeMethod("setEndFrame", "(int)", "$")]
		public void SetEndFrame(int frame) {
			((QTimeLine) interceptor).SetEndFrame(frame);
		}
		[SmokeMethod("setFrameRange", "(int, int)", "$$")]
		public void SetFrameRange(int startFrame, int endFrame) {
			((QTimeLine) interceptor).SetFrameRange(startFrame,endFrame);
		}
		[SmokeMethod("currentFrame", "() const", "")]
		public int CurrentFrame() {
			return ((QTimeLine) interceptor).CurrentFrame();
		}
		[SmokeMethod("currentValue", "() const", "")]
		public double CurrentValue() {
			return ((QTimeLine) interceptor).CurrentValue();
		}
		[SmokeMethod("frameForTime", "(int) const", "$")]
		public int FrameForTime(int msec) {
			return ((QTimeLine) interceptor).FrameForTime(msec);
		}
		[SmokeMethod("valueForTime", "(int) const", "$")]
		public virtual double ValueForTime(int msec) {
			return ((QTimeLine) interceptor).ValueForTime(msec);
		}
		[Q_SLOT("void start()")]
		[SmokeMethod("start", "()", "")]
		public void Start() {
			((QTimeLine) interceptor).Start();
		}
		[Q_SLOT("void stop()")]
		[SmokeMethod("stop", "()", "")]
		public void Stop() {
			((QTimeLine) interceptor).Stop();
		}
		[Q_SLOT("void setPaused(bool)")]
		[SmokeMethod("setPaused", "(bool)", "$")]
		public void SetPaused(bool paused) {
			((QTimeLine) interceptor).SetPaused(paused);
		}
		[Q_SLOT("void toggleDirection()")]
		[SmokeMethod("toggleDirection", "()", "")]
		public void ToggleDirection() {
			((QTimeLine) interceptor).ToggleDirection();
		}
		[SmokeMethod("timerEvent", "(QTimerEvent*)", "#")]
		protected override void TimerEvent(QTimerEvent arg1) {
			((QTimeLine) interceptor).TimerEvent(arg1);
		}
		~QTimeLine() {
			DisposeQTimeLine();
		}
		public new void Dispose() {
			DisposeQTimeLine();
		}
		[SmokeMethod("~QTimeLine", "()", "")]
		private void DisposeQTimeLine() {
			((QTimeLine) interceptor).DisposeQTimeLine();
		}
		public static string Tr(string s, string c) {
			return staticInterceptor.Tr(s,c);
		}
		public static string Tr(string s) {
			return staticInterceptor.Tr(s);
		}
		protected new IQTimeLineSignals Emit {
			get { return (IQTimeLineSignals) Q_EMIT; }
		}
	}

	public interface IQTimeLineSignals : IQObjectSignals {
		[Q_SIGNAL("void valueChanged(qreal)")]
		void ValueChanged(double x);
		[Q_SIGNAL("void frameChanged(int)")]
		void FrameChanged(int arg1);
		[Q_SIGNAL("void stateChanged(QTimeLine::State)")]
		void StateChanged(QTimeLine.State newState);
		[Q_SIGNAL("void finished()")]
		void Finished();
	}
}
