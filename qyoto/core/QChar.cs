//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {

	using System;

	[SmokeClass("QChar")]
	public class QChar : Object, IDisposable {
		protected SmokeInvocation interceptor = null;
		private IntPtr smokeObject;
		protected QChar(Type dummy) {}
		protected void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(QChar), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static QChar() {
			staticInterceptor = new SmokeInvocation(typeof(QChar), null);
		}
		public enum SpecialCharacter {
			Null = 0x0000,
			Nbsp = 0x00a0,
			ReplacementCharacter = 0xfffd,
			ObjectReplacementCharacter = 0xfffc,
			ByteOrderMark = 0xfeff,
			ByteOrderSwapped = 0xfffe,
			ParagraphSeparator = 0x2029,
			LineSeparator = 0x2028,
		}
		public enum Category {
			NoCategory = 0,
			Mark_NonSpacing = 1,
			Mark_SpacingCombining = 2,
			Mark_Enclosing = 3,
			Number_DecimalDigit = 4,
			Number_Letter = 5,
			Number_Other = 6,
			Separator_Space = 7,
			Separator_Line = 8,
			Separator_Paragraph = 9,
			Other_Control = 10,
			Other_Format = 11,
			Other_Surrogate = 12,
			Other_PrivateUse = 13,
			Other_NotAssigned = 14,
			Letter_Uppercase = 15,
			Letter_Lowercase = 16,
			Letter_Titlecase = 17,
			Letter_Modifier = 18,
			Letter_Other = 19,
			Punctuation_Connector = 20,
			Punctuation_Dash = 21,
			Punctuation_Open = 22,
			Punctuation_Close = 23,
			Punctuation_InitialQuote = 24,
			Punctuation_FinalQuote = 25,
			Punctuation_Other = 26,
			Symbol_Math = 27,
			Symbol_Currency = 28,
			Symbol_Modifier = 29,
			Symbol_Other = 30,
			Punctuation_Dask = Punctuation_Dash,
		}
		public enum Direction {
			DirL = 0,
			DirR = 1,
			DirEN = 2,
			DirES = 3,
			DirET = 4,
			DirAN = 5,
			DirCS = 6,
			DirB = 7,
			DirS = 8,
			DirWS = 9,
			DirON = 10,
			DirLRE = 11,
			DirLRO = 12,
			DirAL = 13,
			DirRLE = 14,
			DirRLO = 15,
			DirPDF = 16,
			DirNSM = 17,
			DirBN = 18,
		}
		public enum Decomposition {
			NoDecomposition = 0,
			Canonical = 1,
			Font = 2,
			NoBreak = 3,
			Initial = 4,
			Medial = 5,
			Final = 6,
			Isolated = 7,
			Circle = 8,
			Super = 9,
			Sub = 10,
			Vertical = 11,
			Wide = 12,
			Narrow = 13,
			Small = 14,
			Square = 15,
			Compat = 16,
			Fraction = 17,
		}
		public enum Joining {
			OtherJoining = 0,
			Dual = 1,
			Right = 2,
			Center = 3,
		}
		public enum CombiningClass {
			Combining_BelowLeftAttached = 200,
			Combining_BelowAttached = 202,
			Combining_BelowRightAttached = 204,
			Combining_LeftAttached = 208,
			Combining_RightAttached = 210,
			Combining_AboveLeftAttached = 212,
			Combining_AboveAttached = 214,
			Combining_AboveRightAttached = 216,
			Combining_BelowLeft = 218,
			Combining_Below = 220,
			Combining_BelowRight = 222,
			Combining_Left = 224,
			Combining_Right = 226,
			Combining_AboveLeft = 228,
			Combining_Above = 230,
			Combining_AboveRight = 232,
			Combining_DoubleBelow = 233,
			Combining_DoubleAbove = 234,
			Combining_IotaSubscript = 240,
		}
		public enum UnicodeVersion {
			Unicode_Unassigned = 0,
			Unicode_1_1 = 1,
			Unicode_2_0 = 2,
			Unicode_2_1_2 = 3,
			Unicode_3_0 = 4,
			Unicode_3_1 = 5,
			Unicode_3_2 = 6,
			Unicode_4_0 = 7,
			Unicode_4_1 = 8,
			Unicode_5_0 = 9,
		}
		// ushort& unicode(); >>>> NOT CONVERTED
		public QChar() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QChar", "QChar()", typeof(void));
		}
		public QChar(char c) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QChar$", "QChar(char)", typeof(void), typeof(char), c);
		}
		public QChar(ushort c) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QChar$", "QChar(uchar)", typeof(void), typeof(ushort), c);
		}
		public QChar(QLatin1Char ch) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QChar#", "QChar(QLatin1Char)", typeof(void), typeof(QLatin1Char), ch);
		}
		public QChar(ushort c, ushort r) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QChar$$", "QChar(uchar, uchar)", typeof(void), typeof(ushort), c, typeof(ushort), r);
		}
		public QChar(short rc) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QChar$", "QChar(short)", typeof(void), typeof(short), rc);
		}
		public QChar(uint rc) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QChar$", "QChar(uint)", typeof(void), typeof(uint), rc);
		}
		public QChar(int rc) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QChar$", "QChar(int)", typeof(void), typeof(int), rc);
		}
		public char category() {
			return (char) interceptor.Invoke("category", "category() const", typeof(char));
		}
		public char direction() {
			return (char) interceptor.Invoke("direction", "direction() const", typeof(char));
		}
		public char joining() {
			return (char) interceptor.Invoke("joining", "joining() const", typeof(char));
		}
		public bool HasMirrored() {
			return (bool) interceptor.Invoke("hasMirrored", "hasMirrored() const", typeof(bool));
		}
		public ushort combiningClass() {
			return (ushort) interceptor.Invoke("combiningClass", "combiningClass() const", typeof(ushort));
		}
		public char MirroredChar() {
			return (char) interceptor.Invoke("mirroredChar", "mirroredChar() const", typeof(char));
		}
		public string decomposition() {
			return (string) interceptor.Invoke("decomposition", "decomposition() const", typeof(string));
		}
		public char DecompositionTag() {
			return (char) interceptor.Invoke("decompositionTag", "decompositionTag() const", typeof(char));
		}
		public int DigitValue() {
			return (int) interceptor.Invoke("digitValue", "digitValue() const", typeof(int));
		}
		public char ToLower() {
			return (char) interceptor.Invoke("toLower", "toLower() const", typeof(char));
		}
		public char ToUpper() {
			return (char) interceptor.Invoke("toUpper", "toUpper() const", typeof(char));
		}
		public char ToTitleCase() {
			return (char) interceptor.Invoke("toTitleCase", "toTitleCase() const", typeof(char));
		}
		public char ToCaseFolded() {
			return (char) interceptor.Invoke("toCaseFolded", "toCaseFolded() const", typeof(char));
		}
		public char unicodeVersion() {
			return (char) interceptor.Invoke("unicodeVersion", "unicodeVersion() const", typeof(char));
		}
		public char ToAscii() {
			return (char) interceptor.Invoke("toAscii", "toAscii() const", typeof(char));
		}
		public char ToLatin1() {
			return (char) interceptor.Invoke("toLatin1", "toLatin1() const", typeof(char));
		}
		public ushort Unicode() {
			return (ushort) interceptor.Invoke("unicode", "unicode() const", typeof(ushort));
		}
		public bool IsNull() {
			return (bool) interceptor.Invoke("isNull", "isNull() const", typeof(bool));
		}
		public bool IsPrint() {
			return (bool) interceptor.Invoke("isPrint", "isPrint() const", typeof(bool));
		}
		public bool IsPunct() {
			return (bool) interceptor.Invoke("isPunct", "isPunct() const", typeof(bool));
		}
		public bool IsSpace() {
			return (bool) interceptor.Invoke("isSpace", "isSpace() const", typeof(bool));
		}
		public bool IsMark() {
			return (bool) interceptor.Invoke("isMark", "isMark() const", typeof(bool));
		}
		public bool IsLetter() {
			return (bool) interceptor.Invoke("isLetter", "isLetter() const", typeof(bool));
		}
		public bool IsNumber() {
			return (bool) interceptor.Invoke("isNumber", "isNumber() const", typeof(bool));
		}
		public bool IsLetterOrNumber() {
			return (bool) interceptor.Invoke("isLetterOrNumber", "isLetterOrNumber() const", typeof(bool));
		}
		public bool IsDigit() {
			return (bool) interceptor.Invoke("isDigit", "isDigit() const", typeof(bool));
		}
		public bool IsSymbol() {
			return (bool) interceptor.Invoke("isSymbol", "isSymbol() const", typeof(bool));
		}
		public bool IsLower() {
			return (bool) interceptor.Invoke("isLower", "isLower() const", typeof(bool));
		}
		public bool IsUpper() {
			return (bool) interceptor.Invoke("isUpper", "isUpper() const", typeof(bool));
		}
		public bool IsTitleCase() {
			return (bool) interceptor.Invoke("isTitleCase", "isTitleCase() const", typeof(bool));
		}
		public bool IsHighSurrogate() {
			return (bool) interceptor.Invoke("isHighSurrogate", "isHighSurrogate() const", typeof(bool));
		}
		public bool IsLowSurrogate() {
			return (bool) interceptor.Invoke("isLowSurrogate", "isLowSurrogate() const", typeof(bool));
		}
		public ushort Cell() {
			return (ushort) interceptor.Invoke("cell", "cell() const", typeof(ushort));
		}
		public ushort Row() {
			return (ushort) interceptor.Invoke("row", "row() const", typeof(ushort));
		}
		public void SetCell(ushort cell) {
			interceptor.Invoke("setCell$", "setCell(uchar)", typeof(void), typeof(ushort), cell);
		}
		public void SetRow(ushort row) {
			interceptor.Invoke("setRow$", "setRow(uchar)", typeof(void), typeof(ushort), row);
		}
		~QChar() {
			interceptor.Invoke("~QChar", "~QChar()", typeof(void));
		}
		public void Dispose() {
			interceptor.Invoke("~QChar", "~QChar()", typeof(void));
		}
		public static char FromAscii(char c) {
			return (char) staticInterceptor.Invoke("fromAscii$", "fromAscii(char)", typeof(char), typeof(char), c);
		}
		public static char FromLatin1(char c) {
			return (char) staticInterceptor.Invoke("fromLatin1$", "fromLatin1(char)", typeof(char), typeof(char), c);
		}
		public static uint SurrogateToUcs4(ushort high, ushort low) {
			return (uint) staticInterceptor.Invoke("surrogateToUcs4$$", "surrogateToUcs4(ushort, ushort)", typeof(uint), typeof(ushort), high, typeof(ushort), low);
		}
		public static uint SurrogateToUcs4(char high, char low) {
			return (uint) staticInterceptor.Invoke("surrogateToUcs4##", "surrogateToUcs4(QChar, QChar)", typeof(uint), typeof(char), high, typeof(char), low);
		}
		public static ushort HighSurrogate(uint ucs4) {
			return (ushort) staticInterceptor.Invoke("highSurrogate$", "highSurrogate(uint)", typeof(ushort), typeof(uint), ucs4);
		}
		public static ushort LowSurrogate(uint ucs4) {
			return (ushort) staticInterceptor.Invoke("lowSurrogate$", "lowSurrogate(uint)", typeof(ushort), typeof(uint), ucs4);
		}
		public static char category(uint ucs4) {
			return (char) staticInterceptor.Invoke("category$", "category(uint)", typeof(char), typeof(uint), ucs4);
		}
		public static char category(ushort ucs2) {
			return (char) staticInterceptor.Invoke("category$", "category(ushort)", typeof(char), typeof(ushort), ucs2);
		}
		public static char direction(uint ucs4) {
			return (char) staticInterceptor.Invoke("direction$", "direction(uint)", typeof(char), typeof(uint), ucs4);
		}
		public static char direction(ushort ucs2) {
			return (char) staticInterceptor.Invoke("direction$", "direction(ushort)", typeof(char), typeof(ushort), ucs2);
		}
		public static char joining(uint ucs4) {
			return (char) staticInterceptor.Invoke("joining$", "joining(uint)", typeof(char), typeof(uint), ucs4);
		}
		public static char joining(ushort ucs2) {
			return (char) staticInterceptor.Invoke("joining$", "joining(ushort)", typeof(char), typeof(ushort), ucs2);
		}
		public static ushort combiningClass(uint ucs4) {
			return (ushort) staticInterceptor.Invoke("combiningClass$", "combiningClass(uint)", typeof(ushort), typeof(uint), ucs4);
		}
		public static ushort combiningClass(ushort ucs2) {
			return (ushort) staticInterceptor.Invoke("combiningClass$", "combiningClass(ushort)", typeof(ushort), typeof(ushort), ucs2);
		}
		public static uint MirroredChar(uint ucs4) {
			return (uint) staticInterceptor.Invoke("mirroredChar$", "mirroredChar(uint)", typeof(uint), typeof(uint), ucs4);
		}
		public static ushort MirroredChar(ushort ucs2) {
			return (ushort) staticInterceptor.Invoke("mirroredChar$", "mirroredChar(ushort)", typeof(ushort), typeof(ushort), ucs2);
		}
		public static char DecompositionTag(uint ucs4) {
			return (char) staticInterceptor.Invoke("decompositionTag$", "decompositionTag(uint)", typeof(char), typeof(uint), ucs4);
		}
		public static int DigitValue(uint ucs4) {
			return (int) staticInterceptor.Invoke("digitValue$", "digitValue(uint)", typeof(int), typeof(uint), ucs4);
		}
		public static int DigitValue(ushort ucs2) {
			return (int) staticInterceptor.Invoke("digitValue$", "digitValue(ushort)", typeof(int), typeof(ushort), ucs2);
		}
		public static uint ToLower(uint ucs4) {
			return (uint) staticInterceptor.Invoke("toLower$", "toLower(uint)", typeof(uint), typeof(uint), ucs4);
		}
		public static ushort ToLower(ushort ucs2) {
			return (ushort) staticInterceptor.Invoke("toLower$", "toLower(ushort)", typeof(ushort), typeof(ushort), ucs2);
		}
		public static uint ToUpper(uint ucs4) {
			return (uint) staticInterceptor.Invoke("toUpper$", "toUpper(uint)", typeof(uint), typeof(uint), ucs4);
		}
		public static ushort ToUpper(ushort ucs2) {
			return (ushort) staticInterceptor.Invoke("toUpper$", "toUpper(ushort)", typeof(ushort), typeof(ushort), ucs2);
		}
		public static uint ToTitleCase(uint ucs4) {
			return (uint) staticInterceptor.Invoke("toTitleCase$", "toTitleCase(uint)", typeof(uint), typeof(uint), ucs4);
		}
		public static ushort ToTitleCase(ushort ucs2) {
			return (ushort) staticInterceptor.Invoke("toTitleCase$", "toTitleCase(ushort)", typeof(ushort), typeof(ushort), ucs2);
		}
		public static uint ToCaseFolded(uint ucs4) {
			return (uint) staticInterceptor.Invoke("toCaseFolded$", "toCaseFolded(uint)", typeof(uint), typeof(uint), ucs4);
		}
		public static ushort ToCaseFolded(ushort ucs2) {
			return (ushort) staticInterceptor.Invoke("toCaseFolded$", "toCaseFolded(ushort)", typeof(ushort), typeof(ushort), ucs2);
		}
		public static char unicodeVersion(uint ucs4) {
			return (char) staticInterceptor.Invoke("unicodeVersion$", "unicodeVersion(uint)", typeof(char), typeof(uint), ucs4);
		}
		public static char unicodeVersion(ushort ucs2) {
			return (char) staticInterceptor.Invoke("unicodeVersion$", "unicodeVersion(ushort)", typeof(char), typeof(ushort), ucs2);
		}
		public static string decomposition(uint ucs4) {
			return (string) staticInterceptor.Invoke("decomposition$", "decomposition(uint)", typeof(string), typeof(uint), ucs4);
		}
	}
}
