//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {
	using System;
	/// <remarks>*************************************************
	/// 
	/// * Copyright (C) 1992-2008 Trolltech ASA. All rights reserved.
	/// 
	/// * This file is part of the QtCore module of the Qt Toolkit.
	/// 
	/// * This file may be used under the terms of the GNU General Public
	///  License versions 2.0 or 3.0 as published by the Free Software
	///  Foundation and appearing in the files LICENSE.GPL2 and LICENSE.GPL3
	///  included in the packaging of this file.  Alternatively you may (at
	///  your option) use any later version of the GNU General Public
	///  License if such license has been publicly approved by Trolltech ASA
	///  (or its successors, if any) and the KDE Free Qt Foundation. In
	///  addition, as a special exception, Trolltech gives you certain
	///  additional rights. These rights are described in the Trolltech GPL
	///  Exception version 1.2, which can be found at
	///  http://www.trolltech.com/products/qt/gplexception/ and in the file
	///  GPL_EXCEPTION.txt in this package.
	/// 
	/// * Please review the following information to ensure GNU General
	///  Public Licensing requirements will be met:
	///  http://trolltech.com/products/qt/licenses/licensing/opensource/. If
	///  you are unsure which license is appropriate for your use, please
	///  review the following information:
	///  http://trolltech.com/products/qt/licenses/licensing/licensingoverview
	///  or contact the sales department at sales@trolltech.com.
	/// 
	/// * In addition, as a special exception, Trolltech, as the sole
	///  copyright holder for Qt Designer, grants users of the Qt/Eclipse
	///  Integration plug-in the right for the Qt/Eclipse Integration to
	///  link to functionality provided by Qt Designer and its related
	///  libraries.
	/// 
	/// * This file is provided "AS IS" with NO WARRANTY OF ANY KIND,
	///  INCLUDING THE WARRANTIES OF DESIGN, MERCHANTABILITY AND FITNESS FOR
	///  A PARTICULAR PURPOSE. Trolltech reserves all rights not expressly
	///  granted herein.
	/// 
	/// * This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
	///  WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
	/// 
	/// ************************************************** See <see cref="IQTimerSignals"></see> for signals emitted by QTimer
	/// </remarks>		<short>                                                                                 Copyright (C) 1992-2008 Trolltech ASA.</short>
	[SmokeClass("QTimer")]
	public class QTimer : QObject, IDisposable {
 		protected QTimer(Type dummy) : base((Type) null) {}
		protected new void CreateProxy() {
			interceptor = new SmokeInvocation(typeof(QTimer), this);
		}
		private static SmokeInvocation staticInterceptor = null;
		static QTimer() {
			staticInterceptor = new SmokeInvocation(typeof(QTimer), null);
		}
		[Q_PROPERTY("bool", "singleShot")]
		public bool SingleShot {
			get { return (bool) interceptor.Invoke("isSingleShot", "isSingleShot()", typeof(bool)); }
			set { interceptor.Invoke("setSingleShot$", "setSingleShot(bool)", typeof(void), typeof(bool), value); }
		}
		[Q_PROPERTY("int", "interval")]
		public int Interval {
			get { return (int) interceptor.Invoke("interval", "interval()", typeof(int)); }
			set { interceptor.Invoke("setInterval$", "setInterval(int)", typeof(void), typeof(int), value); }
		}
		[Q_PROPERTY("bool", "active")]
		public bool Active {
			get { return (bool) interceptor.Invoke("isActive", "isActive()", typeof(bool)); }
		}
		public QTimer(QObject parent) : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QTimer#", "QTimer(QObject*)", typeof(void), typeof(QObject), parent);
		}
		public QTimer() : this((Type) null) {
			CreateProxy();
			interceptor.Invoke("QTimer", "QTimer()", typeof(void));
		}
		public int TimerId() {
			return (int) interceptor.Invoke("timerId", "timerId() const", typeof(int));
		}
		[Q_SLOT("void start(int)")]
		public void Start(int msec) {
			interceptor.Invoke("start$", "start(int)", typeof(void), typeof(int), msec);
		}
		[Q_SLOT("void start()")]
		public void Start() {
			interceptor.Invoke("start", "start()", typeof(void));
		}
		[Q_SLOT("void stop()")]
		public void Stop() {
			interceptor.Invoke("stop", "stop()", typeof(void));
		}
		[SmokeMethod("timerEvent(QTimerEvent*)")]
		protected override void TimerEvent(QTimerEvent arg1) {
			interceptor.Invoke("timerEvent#", "timerEvent(QTimerEvent*)", typeof(void), typeof(QTimerEvent), arg1);
		}
		~QTimer() {
			interceptor.Invoke("~QTimer", "~QTimer()", typeof(void));
		}
		public new void Dispose() {
			interceptor.Invoke("~QTimer", "~QTimer()", typeof(void));
		}
		public static new string Tr(string s, string c) {
			return (string) staticInterceptor.Invoke("tr$$", "tr(const char*, const char*)", typeof(string), typeof(string), s, typeof(string), c);
		}
		public static new string Tr(string s) {
			return (string) staticInterceptor.Invoke("tr$", "tr(const char*)", typeof(string), typeof(string), s);
		}
		public static void singleShot(int msec, QObject receiver, string member) {
			staticInterceptor.Invoke("singleShot$#$", "singleShot(int, QObject*, const char*)", typeof(void), typeof(int), msec, typeof(QObject), receiver, typeof(string), member);
		}
		protected new IQTimerSignals Emit {
			get { return (IQTimerSignals) Q_EMIT; }
		}
	}

	public interface IQTimerSignals : IQObjectSignals {
		[Q_SIGNAL("void timeout()")]
		void Timeout();
	}
}
