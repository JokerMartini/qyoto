//Auto-generated by ../../kalyptus/kalyptus. DO NOT EDIT.
namespace Qt {

	using System;
	using System.Text;

	/// See <see cref="IQTcpServerSignals"></see> for signals emitted by QTcpServer
	public class QTcpServer : QObject, IDisposable {
 		protected QTcpServer(Type dummy) : base((Type) null) {}
		interface IQTcpServerProxy {
			string Tr(string s, string c);
			string Tr(string s);
		}

		protected void CreateQTcpServerProxy() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(QTcpServer), this);
			_interceptor = (QTcpServer) realProxy.GetTransparentProxy();
		}
		private QTcpServer ProxyQTcpServer() {
			return (QTcpServer) _interceptor;
		}
		private static Object _staticInterceptor = null;
		static QTcpServer() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(IQTcpServerProxy), null);
			_staticInterceptor = (IQTcpServerProxy) realProxy.GetTransparentProxy();
		}
		private static IQTcpServerProxy StaticQTcpServer() {
			return (IQTcpServerProxy) _staticInterceptor;
		}

		public new virtual QMetaObject MetaObject() {
			return ProxyQTcpServer().MetaObject();
		}
		// void* qt_metacast(const char* arg1); >>>> NOT CONVERTED
		// int qt_metacall(QMetaObject::Call arg1,int arg2,void** arg3); >>>> NOT CONVERTED
		public QTcpServer(QObject parent) : this((Type) null) {
			CreateQTcpServerProxy();
			NewQTcpServer(parent);
		}
		private void NewQTcpServer(QObject parent) {
			ProxyQTcpServer().NewQTcpServer(parent);
		}
		public QTcpServer() : this((Type) null) {
			CreateQTcpServerProxy();
			NewQTcpServer();
		}
		private void NewQTcpServer() {
			ProxyQTcpServer().NewQTcpServer();
		}
		public bool Listen(QHostAddress address, ushort port) {
			return ProxyQTcpServer().Listen(address,port);
		}
		public bool Listen(QHostAddress address) {
			return ProxyQTcpServer().Listen(address);
		}
		public bool Listen() {
			return ProxyQTcpServer().Listen();
		}
		public void Close() {
			ProxyQTcpServer().Close();
		}
		public bool IsListening() {
			return ProxyQTcpServer().IsListening();
		}
		public void SetMaxPendingConnections(int numConnections) {
			ProxyQTcpServer().SetMaxPendingConnections(numConnections);
		}
		public int MaxPendingConnections() {
			return ProxyQTcpServer().MaxPendingConnections();
		}
		public ushort ServerPort() {
			return ProxyQTcpServer().ServerPort();
		}
		public QHostAddress ServerAddress() {
			return ProxyQTcpServer().ServerAddress();
		}
		public int SocketDescriptor() {
			return ProxyQTcpServer().SocketDescriptor();
		}
		public bool SetSocketDescriptor(int socketDescriptor) {
			return ProxyQTcpServer().SetSocketDescriptor(socketDescriptor);
		}
		public bool WaitForNewConnection(int msec, out bool timedOut) {
			return ProxyQTcpServer().WaitForNewConnection(msec,out timedOut);
		}
		public bool WaitForNewConnection(int msec) {
			return ProxyQTcpServer().WaitForNewConnection(msec);
		}
		public bool WaitForNewConnection() {
			return ProxyQTcpServer().WaitForNewConnection();
		}
		public virtual bool HasPendingConnections() {
			return ProxyQTcpServer().HasPendingConnections();
		}
		public virtual QTcpSocket NextPendingConnection() {
			return ProxyQTcpServer().NextPendingConnection();
		}
		public int ServerError() {
			return ProxyQTcpServer().ServerError();
		}
		public string ErrorString() {
			return ProxyQTcpServer().ErrorString();
		}
		public static new string Tr(string s, string c) {
			return StaticQTcpServer().Tr(s,c);
		}
		public static new string Tr(string s) {
			return StaticQTcpServer().Tr(s);
		}
		protected virtual void IncomingConnection(int handle) {
			ProxyQTcpServer().IncomingConnection(handle);
		}
		~QTcpServer() {
			ProxyQTcpServer().Dispose();
		}
		public new void Dispose() {
			ProxyQTcpServer().Dispose();
		}
	}

	public interface IQTcpServerSignals {
		void NewConnection();
	}
}
