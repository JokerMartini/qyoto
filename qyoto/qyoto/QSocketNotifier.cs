//Auto-generated by ../../kalyptus/kalyptus. DO NOT EDIT.
namespace Qt {

	using System;
	using System.Text;

	///<remarks>*************************************************
	///
	///* Copyright (C) 1992-2005 Trolltech AS. All rights reserved.
	///
	///* This file is part of the QtCore module of the Qt Toolkit.
	///
	///* This file may be used under the terms of the GNU General Public
	/// License version 2.0 as published by the Free Software Foundation
	/// and appearing in the file LICENSE.GPL included in the packaging of
	/// this file.  Please review the following information to ensure GNU
	/// General Public Licensing requirements will be met:
	/// http://www.trolltech.com/products/qt/opensource.html
	///
	///* If you are unsure which license is appropriate for your use, please
	/// review the following information:
	/// http://www.trolltech.com/products/qt/licensing.html or contact the
	/// sales department at sales@trolltech.com.
	///
	///* This file is provided AS IS with NO WARRANTY OF ANY KIND, INCLUDING THE
	/// WARRANTY OF DESIGN, MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
	///
	///************************************************** See <see cref="IQSocketNotifierSignals"></see> for signals emitted by QSocketNotifier
	///</remarks>		<short>                                                                                 Copyright (C) 1992-2005 Trolltech AS.</short>

	public class QSocketNotifier : QObject, IDisposable {
 		protected QSocketNotifier(Type dummy) : base((Type) null) {}
		interface IQSocketNotifierProxy {
			string Tr(string s, string c);
			string Tr(string s);
		}

		protected void CreateQSocketNotifierProxy() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(QSocketNotifier), this);
			_interceptor = (QSocketNotifier) realProxy.GetTransparentProxy();
		}
		private QSocketNotifier ProxyQSocketNotifier() {
			return (QSocketNotifier) _interceptor;
		}
		private static Object _staticInterceptor = null;
		static QSocketNotifier() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(IQSocketNotifierProxy), null);
			_staticInterceptor = (IQSocketNotifierProxy) realProxy.GetTransparentProxy();
		}
		private static IQSocketNotifierProxy StaticQSocketNotifier() {
			return (IQSocketNotifierProxy) _staticInterceptor;
		}

		enum E_Type {
			Read = 0,
			Write = 1,
			Exception = 2,
		}
		public new virtual QMetaObject MetaObject() {
			return ProxyQSocketNotifier().MetaObject();
		}
		// void* qt_metacast(const char* arg1); >>>> NOT CONVERTED
		// int qt_metacall(QMetaObject::Call arg1,int arg2,void** arg3); >>>> NOT CONVERTED
		public QSocketNotifier(int socket, int arg2, QObject parent) : this((Type) null) {
			CreateQSocketNotifierProxy();
			NewQSocketNotifier(socket,arg2,parent);
		}
		private void NewQSocketNotifier(int socket, int arg2, QObject parent) {
			ProxyQSocketNotifier().NewQSocketNotifier(socket,arg2,parent);
		}
		public QSocketNotifier(int socket, int arg2) : this((Type) null) {
			CreateQSocketNotifierProxy();
			NewQSocketNotifier(socket,arg2);
		}
		private void NewQSocketNotifier(int socket, int arg2) {
			ProxyQSocketNotifier().NewQSocketNotifier(socket,arg2);
		}
		public int Socket() {
			return ProxyQSocketNotifier().Socket();
		}
		public bool IsEnabled() {
			return ProxyQSocketNotifier().IsEnabled();
		}
		public void SetEnabled(bool arg1) {
			ProxyQSocketNotifier().SetEnabled(arg1);
		}
		public static new string Tr(string s, string c) {
			return StaticQSocketNotifier().Tr(s,c);
		}
		public static new string Tr(string s) {
			return StaticQSocketNotifier().Tr(s);
		}
		public new bool Event(QEvent arg1) {
			return ProxyQSocketNotifier().Event(arg1);
		}
		~QSocketNotifier() {
			ProxyQSocketNotifier().Dispose();
		}
		public new void Dispose() {
			ProxyQSocketNotifier().Dispose();
		}
	}

	public interface IQSocketNotifierSignals {
		void Activated(int socket);
	}
}
