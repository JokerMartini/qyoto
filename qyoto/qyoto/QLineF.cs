//Auto-generated by ../../kalyptus/kalyptus. DO NOT EDIT.
namespace Qt {

	using System;

	public class QLineF : MarshalByRefObject, IDisposable {
		protected Object _interceptor = null;
 
		private IntPtr _smokeObject;
 		protected QLineF(Type dummy) {}
		interface IQLineFProxy {
			bool op_equals(QLineF lhs, QLineF d);
		}

		protected void CreateQLineFProxy() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(QLineF), this);
			_interceptor = (QLineF) realProxy.GetTransparentProxy();
		}
		private QLineF ProxyQLineF() {
			return (QLineF) _interceptor;
		}
		private static Object _staticInterceptor = null;
		static QLineF() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(IQLineFProxy), null);
			_staticInterceptor = (IQLineFProxy) realProxy.GetTransparentProxy();
		}
		private static IQLineFProxy StaticQLineF() {
			return (IQLineFProxy) _staticInterceptor;
		}

		enum IntersectType {
			NoIntersection = 0,
			BoundedIntersection = 1,
			UnboundedIntersection = 2,
		}
		public QLineF() : this((Type) null) {
			CreateQLineFProxy();
			NewQLineF();
		}
		private void NewQLineF() {
			ProxyQLineF().NewQLineF();
		}
		public QLineF(QPointF pt1, QPointF pt2) : this((Type) null) {
			CreateQLineFProxy();
			NewQLineF(pt1,pt2);
		}
		private void NewQLineF(QPointF pt1, QPointF pt2) {
			ProxyQLineF().NewQLineF(pt1,pt2);
		}
		// QLineF* QLineF(qreal arg1,qreal arg2,qreal arg3,qreal arg4); >>>> NOT CONVERTED
		public QLineF(QLine line) : this((Type) null) {
			CreateQLineFProxy();
			NewQLineF(line);
		}
		private void NewQLineF(QLine line) {
			ProxyQLineF().NewQLineF(line);
		}
		public bool IsNull() {
			return ProxyQLineF().IsNull();
		}
		public QPointF P1() {
			return ProxyQLineF().P1();
		}
		public QPointF P2() {
			return ProxyQLineF().P2();
		}
		// qreal x1(); >>>> NOT CONVERTED
		// qreal y1(); >>>> NOT CONVERTED
		// qreal x2(); >>>> NOT CONVERTED
		// qreal y2(); >>>> NOT CONVERTED
		// qreal dx(); >>>> NOT CONVERTED
		// qreal dy(); >>>> NOT CONVERTED
		// qreal length(); >>>> NOT CONVERTED
		// void setLength(qreal arg1); >>>> NOT CONVERTED
		public QLineF UnitVector() {
			return ProxyQLineF().UnitVector();
		}
		public QLineF NormalVector() {
			return ProxyQLineF().NormalVector();
		}
		public int Intersect(QLineF l, QPointF intersectionPoint) {
			return ProxyQLineF().Intersect(l,intersectionPoint);
		}
		// qreal angle(const QLineF& arg1); >>>> NOT CONVERTED
		// QPointF pointAt(qreal arg1); >>>> NOT CONVERTED
		public void Translate(QPointF p) {
			ProxyQLineF().Translate(p);
		}
		// void translate(qreal arg1,qreal arg2); >>>> NOT CONVERTED
		public static bool operator==(QLineF lhs, QLineF d) {
			return StaticQLineF().op_equals(lhs,d);
		}
		public static bool operator!=(QLineF lhs, QLineF d) {
			return !StaticQLineF().op_equals(lhs,d);
		}
		public override bool Equals(object o) {
			if (!(o is QLineF)) { return false; }
			return this == (QLineF) o;
		}
		public override int GetHashCode() {
			return ProxyQLineF().GetHashCode();
		}
		public QLine ToLine() {
			return ProxyQLineF().ToLine();
		}
		~QLineF() {
			ProxyQLineF().Dispose();
		}
		public void Dispose() {
			ProxyQLineF().Dispose();
		}
	}
}
