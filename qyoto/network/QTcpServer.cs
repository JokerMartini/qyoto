//Auto-generated by kalyptus. DO NOT EDIT.
namespace Qyoto {

	using System;

	/// See <see cref="IQTcpServerSignals"></see> for signals emitted by QTcpServer
	[SmokeClass("QTcpServer")]
	public class QTcpServer : QObject, IDisposable {
 		protected QTcpServer(Type dummy) : base((Type) null) {}
		[SmokeClass("QTcpServer")]
		interface IQTcpServerProxy {
			[SmokeMethod("tr", "(const char*, const char*)", "$$")]
			string Tr(string s, string c);
			[SmokeMethod("tr", "(const char*)", "$")]
			string Tr(string s);
		}
		protected new void CreateProxy() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(QTcpServer), this);
			interceptor = (QTcpServer) realProxy.GetTransparentProxy();
		}
		private static IQTcpServerProxy staticInterceptor = null;
		static QTcpServer() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(IQTcpServerProxy), null);
			staticInterceptor = (IQTcpServerProxy) realProxy.GetTransparentProxy();
		}
		public QTcpServer(QObject parent) : this((Type) null) {
			CreateProxy();
			NewQTcpServer(parent);
		}
		[SmokeMethod("QTcpServer", "(QObject*)", "#")]
		private void NewQTcpServer(QObject parent) {
			((QTcpServer) interceptor).NewQTcpServer(parent);
		}
		public QTcpServer() : this((Type) null) {
			CreateProxy();
			NewQTcpServer();
		}
		[SmokeMethod("QTcpServer", "()", "")]
		private void NewQTcpServer() {
			((QTcpServer) interceptor).NewQTcpServer();
		}
		[SmokeMethod("listen", "(const QHostAddress&, quint16)", "#$")]
		public bool Listen(QHostAddress address, ushort port) {
			return ((QTcpServer) interceptor).Listen(address,port);
		}
		[SmokeMethod("listen", "(const QHostAddress&)", "#")]
		public bool Listen(QHostAddress address) {
			return ((QTcpServer) interceptor).Listen(address);
		}
		[SmokeMethod("listen", "()", "")]
		public bool Listen() {
			return ((QTcpServer) interceptor).Listen();
		}
		[SmokeMethod("close", "()", "")]
		public void Close() {
			((QTcpServer) interceptor).Close();
		}
		[SmokeMethod("isListening", "() const", "")]
		public bool IsListening() {
			return ((QTcpServer) interceptor).IsListening();
		}
		[SmokeMethod("setMaxPendingConnections", "(int)", "$")]
		public void SetMaxPendingConnections(int numConnections) {
			((QTcpServer) interceptor).SetMaxPendingConnections(numConnections);
		}
		[SmokeMethod("maxPendingConnections", "() const", "")]
		public int MaxPendingConnections() {
			return ((QTcpServer) interceptor).MaxPendingConnections();
		}
		[SmokeMethod("serverPort", "() const", "")]
		public ushort ServerPort() {
			return ((QTcpServer) interceptor).ServerPort();
		}
		[SmokeMethod("serverAddress", "() const", "")]
		public QHostAddress ServerAddress() {
			return ((QTcpServer) interceptor).ServerAddress();
		}
		[SmokeMethod("socketDescriptor", "() const", "")]
		public int SocketDescriptor() {
			return ((QTcpServer) interceptor).SocketDescriptor();
		}
		[SmokeMethod("setSocketDescriptor", "(int)", "$")]
		public bool SetSocketDescriptor(int socketDescriptor) {
			return ((QTcpServer) interceptor).SetSocketDescriptor(socketDescriptor);
		}
		[SmokeMethod("waitForNewConnection", "(int, bool*)", "$$")]
		public bool WaitForNewConnection(int msec, out bool timedOut) {
			return ((QTcpServer) interceptor).WaitForNewConnection(msec,out timedOut);
		}
		[SmokeMethod("waitForNewConnection", "(int)", "$")]
		public bool WaitForNewConnection(int msec) {
			return ((QTcpServer) interceptor).WaitForNewConnection(msec);
		}
		[SmokeMethod("waitForNewConnection", "()", "")]
		public bool WaitForNewConnection() {
			return ((QTcpServer) interceptor).WaitForNewConnection();
		}
		[SmokeMethod("hasPendingConnections", "() const", "")]
		public virtual bool HasPendingConnections() {
			return ((QTcpServer) interceptor).HasPendingConnections();
		}
		[SmokeMethod("nextPendingConnection", "()", "")]
		public virtual QTcpSocket NextPendingConnection() {
			return ((QTcpServer) interceptor).NextPendingConnection();
		}
		[SmokeMethod("serverError", "() const", "")]
		public QAbstractSocket.SocketError ServerError() {
			return ((QTcpServer) interceptor).ServerError();
		}
		[SmokeMethod("errorString", "() const", "")]
		public string ErrorString() {
			return ((QTcpServer) interceptor).ErrorString();
		}
		[SmokeMethod("setProxy", "(const QNetworkProxy&)", "#")]
		public void SetProxy(QNetworkProxy networkProxy) {
			((QTcpServer) interceptor).SetProxy(networkProxy);
		}
		[SmokeMethod("proxy", "() const", "")]
		public QNetworkProxy Proxy() {
			return ((QTcpServer) interceptor).Proxy();
		}
		[SmokeMethod("incomingConnection", "(int)", "$")]
		protected virtual void IncomingConnection(int handle) {
			((QTcpServer) interceptor).IncomingConnection(handle);
		}
		~QTcpServer() {
			DisposeQTcpServer();
		}
		public new void Dispose() {
			DisposeQTcpServer();
		}
		[SmokeMethod("~QTcpServer", "()", "")]
		private void DisposeQTcpServer() {
			((QTcpServer) interceptor).DisposeQTcpServer();
		}
		public static string Tr(string s, string c) {
			return staticInterceptor.Tr(s,c);
		}
		public static string Tr(string s) {
			return staticInterceptor.Tr(s);
		}
		protected new IQTcpServerSignals Emit {
			get { return (IQTcpServerSignals) Q_EMIT; }
		}
	}

	public interface IQTcpServerSignals : IQObjectSignals {
		[Q_SIGNAL("void newConnection()")]
		void NewConnection();
	}
}
