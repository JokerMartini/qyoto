//Auto-generated by ../../kalyptus/kalyptus. DO NOT EDIT.
namespace Qyoto {

	using System;

	/// See <see cref="IQTextDocumentSignals"></see> for signals emitted by QTextDocument
	[SmokeClass("QTextDocument")]
	public class QTextDocument : QObject, IDisposable {
 		protected QTextDocument(Type dummy) : base((Type) null) {}
		[SmokeClass("QTextDocument")]
		interface IQTextDocumentProxy {
			[SmokeMethod("tr", "(const char*, const char*)", "$$")]
			string Tr(string s, string c);
			[SmokeMethod("tr", "(const char*)", "$")]
			string Tr(string s);
		}
		protected new void CreateProxy() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(QTextDocument), this);
			_interceptor = (QTextDocument) realProxy.GetTransparentProxy();
		}
		private QTextDocument ProxyQTextDocument() {
			return (QTextDocument) _interceptor;
		}
		private static Object _staticInterceptor = null;
		static QTextDocument() {
			SmokeInvocation realProxy = new SmokeInvocation(typeof(IQTextDocumentProxy), null);
			_staticInterceptor = (IQTextDocumentProxy) realProxy.GetTransparentProxy();
		}
		private static IQTextDocumentProxy StaticQTextDocument() {
			return (IQTextDocumentProxy) _staticInterceptor;
		}
		public enum MetaInformation {
			DocumentTitle = 0,
		}
		public enum FindFlag {
			FindBackward = 0x00001,
			FindCaseSensitively = 0x00002,
			FindWholeWords = 0x00004,
		}
		public enum ResourceType {
			HtmlResource = 1,
			ImageResource = 2,
			StyleSheetResource = 3,
			UserResource = 100,
		}
		[Q_PROPERTY("bool", "undoRedoEnabled")]
		public bool UndoRedoEnabled {
			get {
				return Property("undoRedoEnabled").Value<bool>();
			}
			set {
				SetProperty("undoRedoEnabled", QVariant.FromValue<bool>(value));
			}
		}
		[Q_PROPERTY("bool", "modified")]
		public bool Modified {
			get {
				return Property("modified").Value<bool>();
			}
			set {
				SetProperty("modified", QVariant.FromValue<bool>(value));
			}
		}
		[Q_PROPERTY("QSizeF", "pageSize")]
		public QSizeF PageSize {
			get {
				return Property("pageSize").Value<QSizeF>();
			}
			set {
				SetProperty("pageSize", QVariant.FromValue<QSizeF>(value));
			}
		}
		[Q_PROPERTY("QFont", "defaultFont")]
		public QFont DefaultFont {
			get {
				return Property("defaultFont").Value<QFont>();
			}
			set {
				SetProperty("defaultFont", QVariant.FromValue<QFont>(value));
			}
		}
		[Q_PROPERTY("bool", "useDesignMetrics")]
		public bool UseDesignMetrics {
			get {
				return Property("useDesignMetrics").Value<bool>();
			}
			set {
				SetProperty("useDesignMetrics", QVariant.FromValue<bool>(value));
			}
		}
		[Q_PROPERTY("QSizeF", "size")]
		public QSizeF Size {
			get {
				return Property("size").Value<QSizeF>();
			}
		}
		[Q_PROPERTY("qreal", "textWidth")]
		public double TextWidth {
			get {
				return Property("textWidth").Value<double>();
			}
			set {
				SetProperty("textWidth", QVariant.FromValue<double>(value));
			}
		}
		[Q_PROPERTY("int", "blockCount")]
		public int BlockCount {
			get {
				return Property("blockCount").Value<int>();
			}
		}
		[Q_PROPERTY("QString", "defaultStyleSheet")]
		public string DefaultStyleSheet {
			get {
				return Property("defaultStyleSheet").Value<string>();
			}
			set {
				SetProperty("defaultStyleSheet", QVariant.FromValue<string>(value));
			}
		}
		[Q_PROPERTY("int", "maximumBlockCount")]
		public int MaximumBlockCount {
			get {
				return Property("maximumBlockCount").Value<int>();
			}
			set {
				SetProperty("maximumBlockCount", QVariant.FromValue<int>(value));
			}
		}
		// int qt_metacall(QMetaObject::Call arg1,int arg2,void** arg3); >>>> NOT CONVERTED
		// QTextDocument* QTextDocument(QObject* arg1); >>>> NOT CONVERTED
		// QTextDocument* QTextDocument(); >>>> NOT CONVERTED
		// QTextDocument* QTextDocument(const QString& arg1,QObject* arg2); >>>> NOT CONVERTED
		// QTextDocument* QTextDocument(const QString& arg1); >>>> NOT CONVERTED
		// QTextDocument* clone(QObject* arg1); >>>> NOT CONVERTED
		// QTextDocument* clone(); >>>> NOT CONVERTED
		[SmokeMethod("isEmpty", "() const", "")]
		public bool IsEmpty() {
			return ProxyQTextDocument().IsEmpty();
		}
		[SmokeMethod("clear", "()", "")]
		public virtual void Clear() {
			ProxyQTextDocument().Clear();
		}
		[SmokeMethod("isUndoRedoEnabled", "() const", "")]
		public bool IsUndoRedoEnabled() {
			return ProxyQTextDocument().IsUndoRedoEnabled();
		}
		[SmokeMethod("isUndoAvailable", "() const", "")]
		public bool IsUndoAvailable() {
			return ProxyQTextDocument().IsUndoAvailable();
		}
		[SmokeMethod("isRedoAvailable", "() const", "")]
		public bool IsRedoAvailable() {
			return ProxyQTextDocument().IsRedoAvailable();
		}
		[SmokeMethod("setDocumentLayout", "(QAbstractTextDocumentLayout*)", "#")]
		public void SetDocumentLayout(QAbstractTextDocumentLayout layout) {
			ProxyQTextDocument().SetDocumentLayout(layout);
		}
		[SmokeMethod("documentLayout", "() const", "")]
		public QAbstractTextDocumentLayout DocumentLayout() {
			return ProxyQTextDocument().DocumentLayout();
		}
		// void setMetaInformation(QTextDocument::MetaInformation arg1,const QString& arg2); >>>> NOT CONVERTED
		// QString metaInformation(QTextDocument::MetaInformation arg1); >>>> NOT CONVERTED
		[SmokeMethod("toHtml", "(const QByteArray&) const", "#")]
		public string ToHtml(QByteArray encoding) {
			return ProxyQTextDocument().ToHtml(encoding);
		}
		[SmokeMethod("toHtml", "() const", "")]
		public string ToHtml() {
			return ProxyQTextDocument().ToHtml();
		}
		[SmokeMethod("setHtml", "(const QString&)", "$")]
		public void SetHtml(string html) {
			ProxyQTextDocument().SetHtml(html);
		}
		[SmokeMethod("toPlainText", "() const", "")]
		public string ToPlainText() {
			return ProxyQTextDocument().ToPlainText();
		}
		[SmokeMethod("setPlainText", "(const QString&)", "$")]
		public void SetPlainText(string text) {
			ProxyQTextDocument().SetPlainText(text);
		}
		// QTextCursor find(const QString& arg1,int arg2,FindFlags arg3); >>>> NOT CONVERTED
		// QTextCursor find(const QString& arg1,int arg2); >>>> NOT CONVERTED
		// QTextCursor find(const QString& arg1); >>>> NOT CONVERTED
		// QTextCursor find(const QString& arg1,const QTextCursor& arg2,FindFlags arg3); >>>> NOT CONVERTED
		// QTextCursor find(const QString& arg1,const QTextCursor& arg2); >>>> NOT CONVERTED
		// QTextCursor find(const QRegExp& arg1,int arg2,FindFlags arg3); >>>> NOT CONVERTED
		// QTextCursor find(const QRegExp& arg1,int arg2); >>>> NOT CONVERTED
		// QTextCursor find(const QRegExp& arg1); >>>> NOT CONVERTED
		// QTextCursor find(const QRegExp& arg1,const QTextCursor& arg2,FindFlags arg3); >>>> NOT CONVERTED
		// QTextCursor find(const QRegExp& arg1,const QTextCursor& arg2); >>>> NOT CONVERTED
		[SmokeMethod("frameAt", "(int) const", "$")]
		public QTextFrame FrameAt(int pos) {
			return ProxyQTextDocument().FrameAt(pos);
		}
		[SmokeMethod("rootFrame", "() const", "")]
		public QTextFrame RootFrame() {
			return ProxyQTextDocument().RootFrame();
		}
		[SmokeMethod("object", "(int) const", "$")]
		public QTextObject Object(int objectIndex) {
			return ProxyQTextDocument().Object(objectIndex);
		}
		// QTextObject* objectForFormat(const QTextFormat& arg1); >>>> NOT CONVERTED
		[SmokeMethod("findBlock", "(int) const", "$")]
		public QTextBlock FindBlock(int pos) {
			return ProxyQTextDocument().FindBlock(pos);
		}
		[SmokeMethod("begin", "() const", "")]
		public QTextBlock Begin() {
			return ProxyQTextDocument().Begin();
		}
		[SmokeMethod("end", "() const", "")]
		public QTextBlock End() {
			return ProxyQTextDocument().End();
		}
		[SmokeMethod("pageCount", "() const", "")]
		public int PageCount() {
			return ProxyQTextDocument().PageCount();
		}
		[SmokeMethod("isModified", "() const", "")]
		public bool IsModified() {
			return ProxyQTextDocument().IsModified();
		}
		[SmokeMethod("print", "(QPrinter*) const", "#")]
		public void Print(QPrinter printer) {
			ProxyQTextDocument().Print(printer);
		}
		[SmokeMethod("resource", "(int, const QUrl&) const", "$#")]
		public QVariant Resource(int type, IQUrl name) {
			return ProxyQTextDocument().Resource(type,name);
		}
		[SmokeMethod("addResource", "(int, const QUrl&, const QVariant&)", "$##")]
		public void AddResource(int type, IQUrl name, QVariant resource) {
			ProxyQTextDocument().AddResource(type,name,resource);
		}
		// QVector<QTextFormat> allFormats(); >>>> NOT CONVERTED
		[SmokeMethod("markContentsDirty", "(int, int)", "$$")]
		public void MarkContentsDirty(int from, int length) {
			ProxyQTextDocument().MarkContentsDirty(from,length);
		}
		[SmokeMethod("drawContents", "(QPainter*, const QRectF&)", "##")]
		public void DrawContents(QPainter painter, QRectF rect) {
			ProxyQTextDocument().DrawContents(painter,rect);
		}
		[SmokeMethod("drawContents", "(QPainter*)", "#")]
		public void DrawContents(QPainter painter) {
			ProxyQTextDocument().DrawContents(painter);
		}
		[SmokeMethod("idealWidth", "() const", "")]
		public double IdealWidth() {
			return ProxyQTextDocument().IdealWidth();
		}
		[SmokeMethod("adjustSize", "()", "")]
		public void AdjustSize() {
			ProxyQTextDocument().AdjustSize();
		}
		// void undo(QTextCursor* arg1); >>>> NOT CONVERTED
		// void redo(QTextCursor* arg1); >>>> NOT CONVERTED
		// QTextDocumentPrivate* docHandle(); >>>> NOT CONVERTED
		// void appendUndoItem(QAbstractUndoItem* arg1); >>>> NOT CONVERTED
		public static new string Tr(string s, string c) {
			return StaticQTextDocument().Tr(s,c);
		}
		public static new string Tr(string s) {
			return StaticQTextDocument().Tr(s);
		}
		// QTextObject* createObject(const QTextFormat& arg1); >>>> NOT CONVERTED
		[SmokeMethod("loadResource", "(int, const QUrl&)", "$#")]
		protected virtual QVariant LoadResource(int type, IQUrl name) {
			return ProxyQTextDocument().LoadResource(type,name);
		}
		~QTextDocument() {
			DisposeQTextDocument();
		}
		public new void Dispose() {
			DisposeQTextDocument();
		}
		[SmokeMethod("~QTextDocument", "()", "")]
		private void DisposeQTextDocument() {
			ProxyQTextDocument().DisposeQTextDocument();
		}
		protected new IQTextDocumentSignals Emit {
			get {
				return (IQTextDocumentSignals) Q_EMIT;
			}
		}
	}

	public interface IQTextDocumentSignals : IQObjectSignals {
		[Q_SIGNAL("void contentsChange(int, int, int)")]
		void ContentsChange(int from, int charsRemoves, int charsAdded);
		[Q_SIGNAL("void contentsChanged()")]
		void ContentsChanged();
		[Q_SIGNAL("void undoAvailable(bool)")]
		void UndoAvailable(bool arg1);
		[Q_SIGNAL("void redoAvailable(bool)")]
		void RedoAvailable(bool arg1);
		[Q_SIGNAL("void modificationChanged(bool)")]
		void ModificationChanged(bool m);
		// void cursorPositionChanged(const QTextCursor& arg1); >>>> NOT CONVERTED
	}
}
